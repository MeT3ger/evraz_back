{"http-api-3.1": {}, ".flake8": "[flake8]\nmax-line-length = 88\nmax-complexity = 36\nselect = B,C,E,F,W,T4,B9\nignore = E203, E266, E501, W503, F403, F401, E704\nextend-ignore = B905\n", ".gitattributes": "* text=auto\n\n*.py text eol=lf diff=python\n\n", ".github": {}, "workflows": {}, "mypy.yml": "name: MyPy\n\non:\n  push:\n  pull_request:\n  workflow_dispatch:\n\n# Cancel previous running jobs on the same branch in case of new pushs\nconcurrency:\n  group: http-api-mypy-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  mypy:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.12\"\n      - name: Install MyPy and pre-commit\n        run: |\n          sudo apt-get install --yes libgeos-dev\n          python -m pip install --upgrade pip pre-commit\n          pip install --upgrade --no-cache-dir --editable .[types]\n\n      - name: Run MyPy\n        run: |\n\n          echo \"[mypy]\" > mypy.ini\n          echo \"mypy_path = ./stubs\" >> mypy.ini\n\n          for lib in \\\n            flask_apispec \\\n            flask_cors \\\n            neobolt \\\n            redbeat \\\n            plumbum \\\n            psutil \\\n            ; do\n            echo \"[mypy-${lib}.*]\" >> mypy.ini\n            echo \"ignore_missing_imports = True\" >> mypy.ini\n            \n          done\n\n          mypy --disallow-untyped-defs --disallow-incomplete-defs --disallow-any-unimported --disallow-any-generics --check-untyped-defs --disallow-untyped-calls --warn-redundant-casts --warn-unused-ignores --warn-unused-configs --warn-return-any --warn-unreachable --txt-report report --html-report report restapi/ tests/\n          cat report/index.txt\n\n      - name: Save Report\n        uses: actions/upload-artifact@v4\n        with:\n          name: mypy-report\n          path: report\n\n      - name: Run Pre-commit\n        run: |\n          export GITGUARDIAN_API_KEY=${{ secrets.GITGUARDIAN_API_KEY }}\n          pre-commit run --all\n", "publish-to-pypi.yml": "name: Publish to PyPI\n\non:\n  push:\n    tags:\n      - \"*\"\n\njobs:\n  publish:\n    name: Publish to PyPI\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.12\"\n\n      - name: Build dist\n        run: |\n          python -m pip install --upgrade build\n          python -m build\n\n      - name: Publish to PyPI\n        uses: pypa/gh-action-pypi-publish@master\n        with:\n          user: __token__\n          password: ${{ secrets.pypi_password }}\n", "pytest.yml": "name: Test\n\non:\n  push:\n  pull_request:\n  workflow_dispatch:\n\n# Cancel previous running jobs on the same branch in case of new pushs\nconcurrency:\n  group: http-api-tests-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    timeout-minutes: 20\n\n    strategy:\n      matrix:\n        template:\n          [\n            noauth,\n            low_security,\n            extra,\n            legacy39,\n            legacy310,\n            legacy311,\n            neo4j,\n            postgres,\n            celery-redis-redis,\n            celery-rabbit-redis,\n            celery-rabbit-rabbit,\n          ]\n        mode: [dev, prod]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.12\"\n      - name: Install\n        env:\n          REF_BRANCH: ${{ github.ref }}\n          HEAD_REF_BRANCH: ${{ github.head_ref }}\n\n        run: |\n\n          # Randomize auth service to test some services\n          # double neo4j to balance with sql databases\n          auth_services=(postgres neo4j)\n          RANDOM_AUTH=${auth_services[$(($RANDOM % ${#auth_services[@]}))]}\n          echo \"Selected random authentication service = ${RANDOM_AUTH}\"\n          # Make the environment variable available to next steps\n          echo \"RANDOM_AUTH=${RANDOM_AUTH}\" >> $GITHUB_ENV\n\n          python -m pip install --upgrade pip\n          CURRENT_VERSION=$(grep __version__ restapi/__init__.py | sed 's/__version__ = //' | tr -d '\"')\n          pip install --upgrade --no-cache-dir git+https://github.com/rapydo/do.git@${CURRENT_VERSION}\n          rapydo --version\n\n          mkdir ${{ matrix.template }}.${{ matrix.mode }}\n          cd ${{ matrix.template }}.${{ matrix.mode }}\n          rapydo install compose\n          bash ../tests/create_template.sh ${{ matrix.template }} ${RANDOM_AUTH}\n\n      - name: DEV Tests\n        if: ${{ matrix.mode == 'dev' }}\n        run: |\n          cd ${{ matrix.template }}.${{ matrix.mode }}\n          rapydo --testing --project prj init\n          rapydo pull --quiet\n          bash ../tests/customize_template.sh ${{ matrix.template }}\n          rapydo start\n          sleep 25\n          rapydo logs\n\n          if [[ \"${{github.actor}}\" == \"renovate[bot]\" ]] || [[ \"${{github.event_name}}\" == \"pull_request\" ]] || [[ \"${{github.event.pull_request.merged}}\" == \"true\" ]]; then\n            # Do not install at root level to prevent:\n            # ERROR: Could not install packages due to an OSError:\n            #        [Errno 16] Device or resource busy: '/usr/local/lib/python3.10/dist-packages/restapi/'\n            rapydo shell backend -u developer 'bash -c \"pip3 install /http-api-package\"'\n          fi\n\n          rapydo shell backend 'restapi tests --core --wait --destroy'\n\n          LOGURU_LEVEL=WARNING rapydo list services\n          # This should fail if at least one container is in Exit status\n          [[ ! $(LOGURU_LEVEL=WARNING rapydo list services | grep -E \"Exit|Restarting|Created\") ]]\n\n      - name: PROD Tests\n        if: ${{ matrix.mode == 'prod' }}\n        run: |\n          cd ${{ matrix.template }}.${{ matrix.mode }}\n\n          rapydo --testing --production --project prj init --force\n          rapydo pull --quiet\n          bash ../tests/customize_template.sh ${{ matrix.template }}\n          rapydo ssl --volatile\n          rapydo start\n          # wait for all services to start (60 is needed in case of rabbit + neo4j)\n          sleep 60\n          rapydo logs\n          curl --insecure -X GET --max-time 5 https://localhost/api/status | grep \"Server is alive\"\n          rapydo logs --tail 20 proxy backend\n\n          if [[ \"${{github.actor}}\" == \"renovate[bot]\" ]] || [[ \"${{github.event_name}}\" == \"pull_request\" ]] || [[ \"${{github.event.pull_request.merged}}\" == \"true\" ]]; then\n            # Do not install at root level to prevent:\n            # ERROR: Could not install packages due to an OSError:\n            #        [Errno 16] Device or resource busy: '/usr/local/lib/python3.10/dist-packages/restapi/'\n            rapydo shell backend -u developer 'bash -c \"pip3 install /http-api-package\"'\n            rapydo reload backend\n          fi\n\n          rapydo shell backend 'restapi tests --core --wait'\n\n          LOGURU_LEVEL=WARNING rapydo list services\n          # This should fail if at least one container is in Exit status\n          # Except for frontend that is expected to be exited in prod mode\n          [[ ! $(LOGURU_LEVEL=WARNING rapydo list services | grep -v frontend | grep -E \"Exit|Restarting|Created\") ]]\n\n      - name: Coverage\n        uses: rapydo/actions/coverage@v2\n        with:\n          repository: ${{ matrix.template }}.${{ matrix.mode }}/submodules/http-api\n          project: prj\n          step: backend\n\n      - name: Print Logs\n        if: failure()\n        run: tail -200 ${{ matrix.template }}.${{ matrix.mode }}/data/logs/backend-server.log\n\n      - name: Print Events\n        if: failure()\n        run: tail -100 ${{ matrix.template }}.${{ matrix.mode }}/data/logs/security-events.log\n\n      - name: Print mocked email on failure\n        if: failure()\n        run: cat ${{ matrix.template }}.${{ matrix.mode }}/data/logs/mock.mail.*.body 2>/dev/null || true\n\n      - name: Docker Logs\n        if: failure()\n        run: |\n          cd ${{ matrix.template }}.${{ matrix.mode }}\n\n          rapydo logs\n", "static-analysis.yml": "name: \"Static Analysis\"\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"0 5 * * *\"\n\njobs:\n  codeql:\n    name: CodeQL\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      # Initializes the CodeQL tools for scanning.\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v3\n        with:\n          languages: \"python\"\n          # If you wish to specify custom queries, you can do so here or in a config file.\n          # By default, queries listed here will override any specified in a config file.\n          # Prefix the list here with \"+\" to use these queries and those in the config file.\n          # queries: ./path/to/local/query, your-org/your-repo/queries@main\n\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v3\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v3\n\n  ossar:\n    name: OSSAR\n    # OSSAR runs on windows-latest.\n    # ubuntu-latest and macos-latest support coming soon\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      # Ensure a compatible version of dotnet is installed.\n      # The [Microsoft Security Code Analysis CLI](https://aka.ms/mscadocs) is built with dotnet v3.1.201.\n      # A version greater than or equal to v3.1.201 of dotnet must be installed on the agent in order to run this action.\n      # GitHub hosted runners already have a compatible version of dotnet installed and this step may be skipped.\n      # For self-hosted runners, ensure dotnet version 3.1.201 or later is installed by including this action:\n      # - name: Install .NET\n      #   uses: actions/setup-dotnet@v1\n      #   with:\n      #     dotnet-version: '3.1.x'\n      # Run open source static analysis tools\n      - name: Run OSSAR\n        uses: github/ossar-action@v1\n        id: ossar\n\n        # Upload results to the Security tab\n      - name: Upload OSSAR results\n        uses: github/codeql-action/upload-sarif@v3\n        with:\n          sarif_file: ${{ steps.ossar.outputs.sarifFile }}\n\n  semgrep:\n    name: Semgrep\n    runs-on: ubuntu-latest\n    steps:\n      # Checkout project source\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \"3.10\"\n      - name: Install Semgrep\n        run: python3 -m pip install semgrep\n      - name: Run Semgrep\n        env:\n          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}\n        run: semgrep ci --sarif > semgrep.sarif\n\n      # Upload SARIF file generated in previous step\n      - name: Upload SARIF file\n        uses: github/codeql-action/upload-sarif@v3\n        with:\n          sarif_file: semgrep.sarif\n        if: always()\n", ".gitignore": "# Unit test / coverage reports\ncover/\nhtmlcov/\n.tox/\n*.cover\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\nindex.txt\n\n# sqllite dbs\n*.db\nbackup*\nmodels/*json\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\ndocs/_autosummary/\n\n# PyBuilder\ntarget/\n\n# GitGuardian\n.cache_ggshield\n\n", ".pre-commit-config.yaml": "repos:\n  - repo: https://github.com/timothycrosley/isort\n    rev: 5.13.2\n    hooks:\n      - id: isort\n  - repo: https://github.com/pre-commit/mirrors-prettier\n    rev: v4.0.0-alpha.8\n    hooks:\n      - id: prettier\n  - repo: https://github.com/asottile/pyupgrade\n    rev: v3.15.2\n    hooks:\n      - id: pyupgrade\n        args: [--py39-plus]\n  - repo: https://github.com/ambv/black\n    rev: 24.4.2\n    hooks:\n      - id: black\n  - repo: https://github.com/pycqa/flake8\n    rev: 7.0.0\n    hooks:\n      - id: flake8\n        additional_dependencies:\n          - flake8-bugbear==22.12.6\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.10.0\n    hooks:\n      - id: mypy\n        additional_dependencies:\n          [\n            \"git+https://github.com/rapydo/http-api.git@3.1#egg=rapydo_http[types]\",\n          ]\n\n        # https://mypy.readthedocs.io/en/stable/command_line.html\n        args: [\n            # -> Base type Model becomes \"Any\" due to an unfollowed import\n            # \"--disallow-any-unimported\",\n\n            # Disable errors like:\n            # found module but no type hints\n            # \"--ignore-missing-imports\",\n\n            # This flag disallows usage of generic types that do not specify explicit type parameters.\n            # Moreover, built-in collections (such as list and dict)\n            # become disallowed as you should use their aliases from the typing module\n            # (such as List[int] and Dict[str, str]).\n            \"--disallow-any-generics\",\n            # This flag type checks the body of every function, regardless of whether it has type annotations.\n            # (By default the bodies of functions without annotations are not type checked.)\n            \"--check-untyped-defs\",\n            \"--warn-redundant-casts\",\n            \"--warn-unused-ignores\",\n            \"--warn-return-any\",\n            \"--warn-unreachable\",\n            \"--warn-unused-configs\",\n\n            # This flag reports an error whenever a function with type annotations\n            # calls a function defined without annotations\n            # -> Call to untyped function \"xyz\" in typed context\n            \"--disallow-untyped-calls\",\n\n            # This flag reports an error whenever it encounters a\n            # function definition without type annotations.\n            # -> xyz Function is missing a type annotation\n            \"--disallow-untyped-defs\",\n\n            # This flag reports an error whenever it encounters a\n            # partly annotated function definition.\n            \"--disallow-incomplete-defs\",\n            \"--txt-report\",\n            \".\",\n          ]\n", ".readthedocs.yaml": "# .readthedocs.yaml\n# Read the Docs configuration file\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\n\n# Required\nversion: 2\n\n# Set the version of Python and other tools you might need\nbuild:\n  os: ubuntu-22.04\n  tools:\n    python: \"3.12\"\n  apt_packages:\n    - libgeos-dev\n\n# Build documentation in the docs/ directory with Sphinx\nsphinx:\n  configuration: docs/conf.py\n\n# If using Sphinx, optionally build your docs in additional formats such as PDF\n# formats:\n#    - pdf\n\n# Optionally declare the Python requirements required to build your docs\npython:\n  install:\n    - method: pip\n      path: .\n    - requirements: docs/requirements.txt\n", ".whitesource": "{\n  \"scanSettings\": {\n    \"baseBranches\": []\n  },\n  \"checkRunSettings\": {\n    \"vulnerableCheckRunConclusionLevel\": \"failure\",\n    \"displayMode\": \"diff\",\n    \"useMendCheckNames\": true\n  },\n  \"issueSettings\": {\n    \"minSeverityLevel\": \"LOW\",\n    \"issueType\": \"DEPENDENCY\"\n  }\n}", "LICENSE": "The MIT License\n\nCopyright (c) 2011-2022: Paolo D'Onorio De Meo, Mattia D'Antonio\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n", "README.md": "# RAPyDo REST APIs\n\nREST APIs integrated with the RAPyDo framework\n\nBased on:\n\n- Flask\n- flask-apispec with apispec\n- marshmallow\n- webargs\n- Flask-Caching\n- PyJWT\n- pyotp With segno\n- Neomodel\n- SQLAlchemy\n- Redis-py\n- pika with amqp\n- celery with celery-redbeat\n- gunicorn with gevent\n", "_config.yml": "theme: jekyll-theme-modernist\n", "codecov.yml": "ignore:\n  - \"restapi/__main__.py\" # cannot be tested\n  - \"restapi/__init__.py\" # cannot be tested\n  - \"restapi/mocks.py\" # cannot be tested, only used to build docs\n  - \"restapi/alembic_env.py\" # cannot be tested, only used as a template\n  - \"restapi/connectors/celery/worker.py\" # cannot be tested\n  - \"restapi/connectors/celery/beat.py\" # cannot be tested\n", "docs": {}, "Makefile": "# Minimal makefile for Sphinx documentation\n#\n\n# You can set these variables from the command line, and also\n# from the environment for the first two.\nSPHINXOPTS    ?=\nSPHINXBUILD   ?= sphinx-build\nSOURCEDIR     = .\nBUILDDIR      = _build\n\n# Put it first so that \"make\" without argument is like \"make help\".\nhelp:\n\t@$(SPHINXBUILD) -M help \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O)\n\n.PHONY: help Makefile\n\n# Catch-all target: route all unknown targets to Sphinx using the new\n# \"make mode\" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).\n%: Makefile\n\t@$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O)\n\t@$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O) -b coverage", "_templates": {}, "autosummary": {}, "class.rst": "{{ fullname | escape | underline}}\n\n.. currentmodule:: {{ module }}\n\n.. autoclass:: {{ objname }}\n\n   {% block methods %}\n   .. automethod:: __init__\n\n   {% if methods %}\n   .. rubric:: {{ _('Methods') }}\n\n   .. autosummary::\n      :toctree:\n   {% for item in methods %}\n      ~{{ name }}.{{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block attributes %}\n   {% if attributes %}\n   .. rubric:: {{ _('Attributes') }}\n\n   .. autosummary::\n      :toctree:\n   {% for item in attributes %}\n      ~{{ name }}.{{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n", "module.rst": "{{ fullname | escape | underline}}\n\n.. automodule:: {{ fullname }}\n  \n   {% block attributes %}\n   {% if attributes %}\n   .. rubric:: Module Attributes\n\n   .. autosummary::\n      :toctree:\n   {% for item in attributes %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block functions %}\n   {% if functions %}\n   .. rubric:: {{ _('Functions') }}\n\n   .. autosummary::\n      :toctree:\n   {% for item in functions %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block classes %}\n   {% if classes %}\n   .. rubric:: {{ _('Classes') }}\n\n   .. autosummary::\n      :toctree:\n   {% for item in classes %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block exceptions %}\n   {% if exceptions %}\n   .. rubric:: {{ _('Exceptions') }}\n\n   .. autosummary::\n      :toctree:\n   {% for item in exceptions %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n{% block modules %}\n{% if modules %}\n.. rubric:: Modules\n\n.. autosummary::\n   :toctree:\n   :recursive:\n{% for item in modules %}\n   {{ item }}\n{%- endfor %}\n{% endif %}\n{% endblock %}\n", "conf.py": "# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath(\"..\"))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \"RAPyDo HTTP-APIs\"\ncopyright = \"RAPyDo\"\nauthor = \"RAPyDo\"\n\n# The full version, including alpha/beta/rc tags\nrelease = \"3.1\"\n\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx_autodoc_typehints\",\n    \"sphinx.ext.coverage\",\n]\n\nautosummary_generate = True  # Turn on sphinx.ext.autosummary\n# autodoc_mock_imports = [\"mymodule\"]\n# autodoc_typehints = \"description\"\nautodoc_typehints = \"both\"\nalways_document_param_types = True\ntypehints_defaults = \"comma\"\n\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"sphinx_rtd_theme\"\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n", "index.rst": ".. RAPyDo HTTP-APIs documentation master file, created by\n   sphinx-quickstart on Thu Feb 17 15:41:53 2022.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\nWelcome to RAPyDo HTTP-APIs's documentation!\n============================================\n\n.. autosummary::\n   :toctree: _autosummary\n   :recursive:\n\n   restapi\n\n\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n", "make.bat": "@ECHO OFF\n\npushd %~dp0\n\nREM Command file for Sphinx documentation\n\nif \"%SPHINXBUILD%\" == \"\" (\n\tset SPHINXBUILD=sphinx-build\n)\nset SOURCEDIR=.\nset BUILDDIR=_build\n\nif \"%1\" == \"\" goto help\n\n%SPHINXBUILD% >NUL 2>NUL\nif errorlevel 9009 (\n\techo.\n\techo.The 'sphinx-build' command was not found. Make sure you have Sphinx\n\techo.installed, then set the SPHINXBUILD environment variable to point\n\techo.to the full path of the 'sphinx-build' executable. Alternatively you\n\techo.may add the Sphinx directory to PATH.\n\techo.\n\techo.If you don't have Sphinx installed, grab it from\n\techo.https://www.sphinx-doc.org/\n\texit /b 1\n)\n\n%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%\ngoto end\n\n:help\n%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%\n\n:end\npopd\n", "requirements.txt": "Flask==2.3.3\nflask-apispec==0.11.4\nFlask-Caching==2.2.0\nFlask-Cors==4.0.0\nSQLAlchemy==2.0.29\nalembic==1.13.1\nWerkzeug==3.0.2\nPyJWT==2.8.0\npyOpenSSL==24.1.0\nmarshmallow==3.21.1\nwebargs==8.4.0\napispec==6.3.1\nneomodel==5.3.0\nneobolt==1.7.17\npsycopg2-binary==2.9.9\nPyMySQL==1.1.0\nredis==5.0.4\npika==1.3.2\ncelery[redis]==5.4.0\nflower==2.0.1\ncelery-redbeat==2.2.0\namqp==5.2.0\npyotp==2.9.0\nsegno==1.6.1\nPyYAML==6.0.1\nloguru==0.7.2\nglom==23.5.0\nrequests==2.31.0\npsutil==5.9.8\nplumbum==1.8.2\nhtml2text==2024.2.26\norjson==3.10.1\nsentry-sdk[flask]==2.0.1\nbcrypt==4.1.2\n\n# Redis 5.0.3 dropped this dependency, but it's currently still used\n# To be checked in the future if could be removed:\n# - uninstall async-timeout\n# - add @decorators.cache\n# - start backend and verify it is loaded with no errors\nasync-timeout==4.0.3", "mypy.ini": "[mypy]\nmypy_path = ./stubs\n\n[mypy-plumbum.*]\nignore_missing_imports = True\n\n[mypy-glom.*]\nignore_missing_imports = True\n\n[mypy-neo4j.*]\nignore_missing_imports = True\n\n[mypy-neomodel.*]\nignore_missing_imports = True\n\n[mypy-flask_apispec.*]\nignore_missing_imports = True\n\n[mypy-flask_cors.*]\nignore_missing_imports = True\n\n[mypy-psutil.*]\nignore_missing_imports = True\n\n[mypy-neobolt.*]\nignore_missing_imports = True\n\n[mypy-redbeat.schedulers.*]\nignore_missing_imports = True\n", "pyproject.toml": "[project]\nname = \"rapydo_http\"\nversion = \"3.1\"\ndescription = \"HTTP API server working on top of the RAPyDo framework\"\nrequires-python = \">=3.9\"\nlicense = {file = \"LICENSE\"}\ndynamic = [\"dependencies\", \"optional-dependencies\"]\nreadme = \"README.md\"\nkeywords = [\"http\", \"api\", \"rest\", \"web\", \"backend\", \"rapydo\"]\nclassifiers=[\n    \"Programming Language :: Python\",\n    \"Intended Audience :: Developers\",\n    \"Development Status :: 5 - Production/Stable\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Framework :: Flask\",\n]\n\n[tool.setuptools.dynamic]\ndependencies = {file = [\"requirements.txt\"]}\noptional-dependencies = {dev = {file = [\"requirements.dev.txt\"]}, types = {file = [\"requirements.types.txt\"]}}\n\n[project.urls]\nhomepage = \"https://rapydo.github.io/docs\"\ndocumentation = \"https://http-api.readthedocs.io\"\nrepository = \"https://github.com/rapydo/http-api\"\n# changelog = \"https://github.com/rapydo/http-ap\"\n\n[project.scripts]\nrestapi = \"restapi.__commands__:cli\"\n\n[build-system]\nrequires = [\"setuptools>=64.0\", \"wheel>=0.34.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools.package-data]\nrestapi = [\"py.typed\", \"templates/*\", \"connectors/smtp/templates/*\"]\n\n[tool.setuptools.packages.find]\nexclude = [\"stubs\"]\n\n[tool.black]\nline-length = 88\ntarget_version = ['py39', 'py310', 'py311', 'py312']\ninclude = '\\.pyi?$'\nexclude = '''\n/(\n    \\.git\n  | \\.hg\n  | \\.mypy_cache\n  | \\.tox\n  | \\.venv\n  | _build\n  | buck-out\n  | build\n  | dist\n  # The following are specific to Black, you probably don't want those.\n  | blib2to3\n  | tests/data\n)/\n'''\n\n[tool.isort]\npy_version = 39\nline_length = 88\nmulti_line_output = 3\ninclude_trailing_comma = true\nensure_newline_before_comments = true\n", "renovate.json": "{\n  \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\",\n  \"extends\": [\"config:base\"],\n  \"commitMessageAction\": \"Bump\",\n  \"commitMessageTopic\": \"{{depName}}\",\n  \"commitMessageExtra\": \"to {{newVersion}}\",\n  \"branchConcurrentLimit\": 0,\n  \"pre-commit\": {\n    \"enabled\": true,\n    \"groupName\": \"pre-commit-and-mypy\",\n    \"automerge\": true,\n    \"automergeStrategy\": \"squash\"\n  },\n  \"pip_requirements\": {\n    \"fileMatch\": [\"^requirements.dev.txt$\", \"^requirements.types.txt$\"]\n  },\n  \"packageRules\": [\n    {\n      \"matchUpdateTypes\": [\"patch\"],\n      \"automerge\": true,\n      \"automergeStrategy\": \"squash\"\n    },\n    {\n      \"groupName\": \"pre-commit-and-mypy\",\n      \"matchManagers\": [\"pip_requirements\"],\n      \"matchPackageNames\": [\"mypy\"],\n      \"automerge\": true,\n      \"automergeStrategy\": \"squash\"\n    }\n  ]\n}\n", "requirements.dev.txt": "pytest==8.2.0\npytest-flask==1.3.0\npytest-cov==5.0.0\npytest-timeout==2.3.1\npytest-sugar==1.0.0\nFaker==24.14.0", "requirements.types.txt": "rapydo_http[dev]\nmypy==1.10.0\nlxml==5.2.1\nhtml5lib==1.1\ncelery-types==0.22.0\npika-stubs==0.1.3\ntypes-certifi==2021.10.8.3\ntypes-click==7.1.8\ntypes-orjson==3.6.2\ntypes-python-dateutil==2.9.0.20240316\ntypes-pytz==2024.1.0.20240417\ntypes-PyYAML==6.0.12.20240311\ntypes-redis==4.6.0.20240425\ntypes-requests==2.31.0.20240406\ntypes-psycopg2==2.9.21.20240417\ntypes-urllib3==1.26.25.14\npyyaml>=5.4 # not directly required, pinned by Snyk to avoid a vulnerability\nsentry-sdk>=1.4.1 # not directly required, pinned by Snyk to avoid a vulnerability\n", "restapi": {}, "__commands__.py": "import os\nimport sys\nimport time\nfrom pathlib import Path\nfrom typing import Optional\n\nimport click\nfrom flask.cli import FlaskGroup\n\nfrom restapi import __package__ as current_package\nfrom restapi.config import BACKEND_PACKAGE, CUSTOM_PACKAGE, PRODUCTION\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.server import ServerModes\nfrom restapi.utilities import print_and_exit\nfrom restapi.utilities.globals import mem\nfrom restapi.utilities.logs import log\nfrom restapi.utilities.processes import find_process, wait_socket\n\nBIND_INTERFACE = \"0.0.0.0\"\n\n\n@click.group()\ndef cli() -> None:  # pragma: no cover\n    click.echo(\"*** RESTful HTTP API ***\")\n\n\ndef initializing() -> bool:\n    return find_process(current_package, keywords=[\"init\"], prefix=\"/usr/local/bin/\")\n\n\n# Too dangerous to launch it during tests... skipping tests\n@cli.command()\ndef launch() -> None:  # pragma: no cover\n    \"\"\"Launch the RAPyDo-based HTTP API server\"\"\"\n\n    mywait()\n\n    if initializing():\n        print_and_exit(\n            \"Please wait few more seconds: initialization is still in progress\"\n        )\n\n    current_app = Env.get(\"FLASK_APP\", \"\").strip()\n    if not current_app:\n        os.environ[\"FLASK_APP\"] = f\"{current_package}.__main__\"\n\n    args = [\n        \"run\",\n        \"--host\",\n        BIND_INTERFACE,\n        \"--port\",\n        Env.get(\"FLASK_PORT\", \"8080\"),\n        \"--reload\",\n        \"--no-debugger\",\n        \"--with-threads\",\n    ]\n\n    # Call to untyped function \"FlaskGroup\" in typed context\n    fg_cli = FlaskGroup()\n    # Call to untyped function \"main\" in typed context\n    fg_cli.main(prog_name=\"restapi\", args=args)\n    log.warning(\"Server shutdown\")\n\n\n@cli.command()\n@click.option(\"--service\", \"-s\")\ndef verify(service: str) -> None:\n    \"\"\"Verify if a service is connected\"\"\"\n\n    mem.boot_completed = False\n    if not Connector.check_availability(service):\n        print_and_exit(\"Service {} not detected\", service)\n\n    log.info(\"Verifying service: {}\", service)\n    variables = Connector.services.get(service, {})\n    host, port = get_service_address(variables, \"host\", \"port\", service)\n    if host != \"nohost\":\n        wait_socket(host, port, service)\n\n    connector_module = Connector.get_module(service, BACKEND_PACKAGE)\n    if not connector_module:  # pragma: no cover\n        print_and_exit(\"Connector {} not detected\", service)\n\n    c = connector_module.get_instance()\n    log.info(\n        \"{} successfully authenticated on {}\", service, c.variables.get(\"host\", service)\n    )\n    # log.info(\"Completed successfully\")\n\n\n@cli.command()\n@click.option(\n    \"--wait/--no-wait\",\n    default=False,\n    help=\"Wait for services availability before starting the initialization\",\n)\n@click.option(\n    \"--force-user/--no-force-user\",\n    default=False,\n    help=\"Force the creation of default user\",\n)\n@click.option(\n    \"--force-group/--no-force-group\",\n    default=False,\n    help=\"Force the creation of default group\",\n)\ndef init(wait: bool, force_user: bool, force_group: bool) -> None:\n    \"\"\"Initialize data for connected services\"\"\"\n    if wait:\n        mywait()\n\n    from restapi.server import ServerModes, create_app\n\n    log.info(\"Launching initialization app\")\n\n    options = {\n        \"force_user\": force_user,\n        \"force_group\": force_group,\n    }\n    create_app(name=\"Initializing services\", mode=ServerModes.INIT, options=options)\n\n    log.info(\"Initialization requested\")\n\n\n@cli.command()\ndef wait() -> None:\n    \"\"\"Wait critical service(s) startup\"\"\"\n    mywait()\n\n\ndef get_service_address(\n    variables: dict[str, str], host_var: str, port_var: str, service: str\n) -> tuple[str, int]:\n    host = variables.get(host_var)\n    if host is None:\n        print_and_exit(\"Cannot find any variable matching {} for {}\", host_var, service)\n\n    port = variables.get(port_var)\n    if port is None:\n        print_and_exit(\"Cannot find any variable matching {} for {}\", port_var, service)\n\n    log.info(\"Connecting to {} ({}:{})...\", service, host, port)\n\n    return host, int(port)\n\n\ndef mywait() -> None:\n    \"\"\"\n    Wait for a service on his host:port configuration\n    This check is merely based on a socket connection\n    \"\"\"\n    for name, variables in Connector.services.items():\n        if name == \"smtp\" or name == \"ftp\":\n            log.info(\"Service {} is enabled but not tested at startup time\", name)\n            continue\n\n        if name == \"celery\":\n            broker = variables.get(\"broker_service\", \"N/A\")\n\n            if broker == \"RABBIT\":\n                service_vars = Env.load_variables_group(prefix=\"rabbitmq\")\n            elif broker == \"REDIS\":\n                service_vars = Env.load_variables_group(prefix=\"redis\")\n            else:\n                print_and_exit(\"Invalid celery broker: {}\", broker)  # pragma: no cover\n\n            label = f\"{broker.lower()} as celery broker\"\n            host, port = get_service_address(service_vars, \"host\", \"port\", label)\n\n            wait_socket(host, port, label)\n\n            backend = variables.get(\"backend_service\", \"N/a\")\n            if backend == \"RABBIT\":\n                service_vars = Env.load_variables_group(prefix=\"rabbitmq\")\n            elif backend == \"REDIS\":\n                service_vars = Env.load_variables_group(prefix=\"redis\")\n            else:\n                print_and_exit(\n                    \"Invalid celery backend: {}\", backend\n                )  # pragma: no cover\n\n            label = f\"{backend.lower()} as celery backend\"\n            host, port = get_service_address(service_vars, \"host\", \"port\", label)\n\n            wait_socket(host, port, label)\n\n        else:\n            host, port = get_service_address(variables, \"host\", \"port\", name)\n\n            if host != \"nohost\":\n                wait_socket(host, port, name)\n\n\n# Too dangerous to launch it during tests... skipping tests\n@cli.command()\n@click.confirmation_option(help=\"Are you sure you want to drop data?\")\ndef clean() -> None:  # pragma: no cover\n    \"\"\"Destroy current services data\"\"\"\n\n    from restapi.server import ServerModes, create_app\n\n    log.info(\"Launching destruction app\")\n\n    create_app(name=\"Removing data\", mode=ServerModes.DESTROY, options={})\n\n    log.info(\"Destruction completed\")\n\n\n@cli.command()\ndef forced_clean() -> None:  # pragma: no cover\n    \"\"\"DANGEROUS: Destroy current data without asking yes/no\"\"\"\n\n    from restapi.server import ServerModes, create_app\n\n    log.info(\"Launching destruction app\")\n\n    create_app(name=\"Removing data\", mode=ServerModes.DESTROY, options={})\n\n    log.info(\"Destruction completed\")\n\n\n@cli.command()\n@click.option(\"--wait/--no-wait\", default=False, help=\"Wait for startup to finish\")\n@click.option(\n    \"--core/--no-core\", default=False, help=\"Test for core instead of vanilla code\"\n)\n@click.option(\"--file\", default=None, help=\"Test a single file of tests\")\n@click.option(\"--folder\", default=None, help=\"Test a single folder of tests\")\n@click.option(\n    \"--destroy/--no-destroy\", default=False, help=\"Destroy database after tests\"\n)\ndef tests(\n    wait: bool, core: bool, file: Optional[str], folder: Optional[str], destroy: bool\n) -> None:  # pragma: no cover\n    \"\"\"Compute tests and coverage\"\"\"\n\n    # Forced a change from DEV to TEST mode when using the restapi tests wrapper\n    if not PRODUCTION:\n        os.environ[\"APP_MODE\"] = \"test\"\n\n    if wait:\n        while initializing():\n            log.debug(\"Waiting services initialization\")\n            time.sleep(5)\n        mywait()\n\n    num_opt = 0\n    if core:\n        num_opt += 1\n    if file is not None:\n        num_opt += 1\n    if folder is not None:\n        num_opt += 1\n\n    if num_opt > 1:\n        print_and_exit(\n            \"Please specify only one option between --core, --file and --folder\"\n        )\n\n    parameters = [\"tests/tests.sh\"]\n    if core:\n        parameters.append(current_package)\n    else:\n        parameters.append(CUSTOM_PACKAGE)\n\n    test_folder = Path(\"tests\")\n    if file is not None:\n        filepath = Path(file)\n        if test_folder not in filepath.parents:\n            filepath = test_folder.joinpath(filepath)\n\n        if not filepath.is_file():\n            print_and_exit(\"File not found: {}\", file)\n        parameters.append(str(filepath.relative_to(test_folder)))\n    elif folder is not None:\n        folderpath = Path(folder)\n        if test_folder not in folderpath.parents:\n            folderpath = test_folder.joinpath(folderpath)\n\n        if not folderpath.is_dir():\n            print_and_exit(\"Folder not found: {}\", folder)\n        parameters.append(str(folderpath.relative_to(test_folder)))\n\n    # In prod mode tests are execute with the server running.\n    # Destroy test fails with alchemy due to db locks\n    if destroy and not PRODUCTION:\n        os.environ[\"TEST_DESTROY_MODE\"] = \"1\"\n    try:\n        log.info(\"Running tests... this may take some time\")\n        log.debug(\"Executing: {}\", parameters)\n        from plumbum import local\n\n        command = local[\"bash\"]\n        command(parameters, stdout=sys.stdout, stderr=sys.stderr)\n        sys.exit(0)\n\n    except Exception as e:\n        print_and_exit(str(e))\n\n\n@cli.command()\ndef clearcache() -> None:\n    \"\"\"Clear all data from the endpoints cache\"\"\"\n    from restapi.server import create_app\n    from restapi.services.cache import Cache\n\n    create_app(name=\"Cache clearing\", mode=ServerModes.NORMAL, options={})\n\n    Cache.clear()\n\n    log.info(\"Cache cleared\")\n", "__init__.py": "", "__main__.py": "#!/usr/bin/env python\nfrom restapi.config import MAIN_SERVER_NAME\nfrom restapi.server import ServerModes, create_app\n\napp = create_app(name=\"REST_API\", mode=ServerModes.NORMAL, options={})\n\nif __name__ == MAIN_SERVER_NAME:\n    app.run(host=\"0.0.0.0\", threaded=True)\n", "alembic_env.py": "\"\"\"\nThis is the RAPyDo version of the env.py for alembic.\nIt is copied into the migrations folder to create the\nconnection engine used by the migrate commands\n\"\"\"\n\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine.url import URL\n\nfrom restapi.connectors import Connector\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nconfig.set_main_option(\"script_location\", \"sql/migrations\")\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    variables = Connector.services.get(\"sqlalchemy\", {})\n    url = URL.create(\n        drivername=variables.get(\"dbtype\", \"postgresql\"),\n        username=variables.get(\"user\"),\n        password=variables.get(\"password\"),\n        host=variables.get(\"host\"),\n        port=int(variables.get(\"port\") or \"5432\"),\n        database=variables.get(\"db\"),\n    )\n    context.configure(\n        url=str(url),\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    variables = Connector.services.get(\"sqlalchemy\", {})\n    url = URL.create(\n        drivername=variables.get(\"dbtype\", \"postgresql\"),\n        username=variables.get(\"user\"),\n        password=variables.get(\"password\"),\n        host=variables.get(\"host\"),\n        port=int(variables.get(\"port\") or \"5432\"),\n        database=variables.get(\"db\"),\n    )\n    connectable = create_engine(url, future=True)\n\n    with connectable.connect() as connection:\n        context.configure(connection=connection, target_metadata=target_metadata)\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n", "config.py": "\"\"\"\nConfiguration variables set for the server instance\n\"\"\"\n\nfrom functools import lru_cache\nfrom pathlib import Path\n\nfrom glom import glom\n\nfrom restapi.env import Env\nfrom restapi.utilities.globals import mem\n\n# ENDPOINTS bases\nAPI_URL = \"/api\"\nAUTH_URL = \"/auth\"\n\nAPP_MODE: str = Env.get(\"APP_MODE\", \"development\")\nFORCE_PRODUCTION_TESTS: bool = Env.get_bool(\"FORCE_PRODUCTION_TESTS\")\nTESTING: bool = APP_MODE == \"test\" or FORCE_PRODUCTION_TESTS\nPRODUCTION: bool = APP_MODE == \"production\"\nSTACKTRACE: bool = False\nREMOVE_DATA_AT_INIT_TIME: bool = False\n\nHOSTNAME: str = Env.get(\"HOSTNAME\", \"backend-server\")\n# hostnames as defined in backend.yml\n\nMAIN_SERVER_NAME = \"REST_API\"\nBACKEND_HOSTNAME = \"backend-server\"\nFLOWER_HOSTNAME = \"flower\"\nCELERYBEAT_HOSTNAME = \"celery-beat\"\nCELERY_HOSTNAME = \"celery\"\nDOCS = \"docs-generation\"\n\n\ndef get_host_type(HOSTNAME: str) -> str:\n    if HOSTNAME == DOCS:\n        return DOCS\n\n    if HOSTNAME == BACKEND_HOSTNAME:\n        return BACKEND_HOSTNAME\n\n    if HOSTNAME == FLOWER_HOSTNAME:\n        return FLOWER_HOSTNAME\n\n    if HOSTNAME == CELERYBEAT_HOSTNAME:\n        return CELERYBEAT_HOSTNAME\n\n    # Celery has not a fixed hostname\n    return CELERY_HOSTNAME\n\n\nHOST_TYPE = get_host_type(HOSTNAME)\n\nDEFAULT_HOST = \"127.0.0.1\"\nDEFAULT_PORT = \"8080\"\nDATA_PATH: Path = Path(Env.get(\"DATA_PATH\", \"/uploads\"))\nIMPORT_PATH: Path = Path(Env.get(\"DATA_IMPORT_FOLDER\", \"/imports\"))\nCODE_DIR: Path = Path(Env.get(\"CODE_DIR\", \"/code\"))\nAPP_SECRETS = Path(Env.get(\"APP_SECRETS\", \"/secrets\"))\nJWT_SECRET_FILE = APP_SECRETS.joinpath(\"jwt_secret.key\")\nTOTP_SECRET_FILE = APP_SECRETS.joinpath(\"totp_secret.key\")\nSSL_CERTIFICATE = \"/etc/letsencrypt/real/fullchain1.pem\"\nSSL_SECRET = \"/etc/letsencrypt/real/privkey1.pem\"\nDOMAIN = Env.get(\"DOMAIN\", \"\")\nPROXIED_CONNECTION: bool = Env.get_bool(\"PROXIED_CONNECTION\")\n\nMODELS_DIR = \"models\"\nCONF_PATH = Path(\"confs\")\n# Also configured in controller\nEXTENDED_PROJECT_DISABLED = \"no_extended_project\"\nBACKEND_PACKAGE = \"restapi\"  # package inside rapydo-http\n\nCUSTOM_PACKAGE = Env.get(\"PROJECT_NAME\", \"custom\")\nEXTENDED_PACKAGE = Env.get(\"EXTENDED_PACKAGE\", EXTENDED_PROJECT_DISABLED)\n\nSENTRY_URL = Env.get(\"SENTRY_URL\", \"\").strip() or None\n\nABS_RESTAPI_PATH = Path(__file__).resolve().parent\n\nGZIP_ENABLE = Env.get_bool(\"GZIP_COMPRESSION_ENABLE\")\nGZIP_THRESHOLD = max(0, Env.get_int(\"GZIP_COMPRESSION_THRESHOLD\"))\nGZIP_LEVEL = max(1, min(9, Env.get_int(\"GZIP_COMPRESSION_LEVEL\")))\n\n\n@lru_cache\ndef get_project_configuration(key: str, default: str) -> str:\n    return glom(mem.configuration, key, default=default)\n\n\n@lru_cache\ndef get_backend_url() -> str:\n    BACKEND_URL = Env.get(\"BACKEND_URL\", \"\")\n\n    if BACKEND_URL:\n        return BACKEND_URL\n\n    BACKEND_PREFIX = Env.get(\"BACKEND_PREFIX\", \"\").strip(\"/\")\n    if BACKEND_PREFIX:\n        BACKEND_PREFIX = f\"/{BACKEND_PREFIX}\"\n\n    if PRODUCTION:\n        return f\"https://{DOMAIN}{BACKEND_PREFIX}\"\n\n    port = Env.get(\"FLASK_PORT\", \"8080\")\n    return f\"http://{DOMAIN}{BACKEND_PREFIX}:{port}\"\n\n\n@lru_cache\ndef get_frontend_url() -> str:\n    FRONTEND_URL = Env.get(\"FRONTEND_URL\", \"\")\n\n    if FRONTEND_URL:\n        return FRONTEND_URL\n\n    FRONTEND_PREFIX = Env.get(\"FRONTEND_PREFIX\", \"\").strip(\"/\")\n    if FRONTEND_PREFIX:\n        FRONTEND_PREFIX = f\"/{FRONTEND_PREFIX}\"\n\n    protocol = \"https\" if PRODUCTION else \"http\"\n\n    return f\"{protocol}://{DOMAIN}{FRONTEND_PREFIX}\"\n", "connectors": {}, "celery": {}, "beat.py": "\"\"\"\nCelery pattern. Some interesting read here:\n\nhttp://blog.miguelgrinberg.com/post/celery-and-the-flask-application-factory-pattern\n\nOf course that discussion is not enough for\na flask templating framework like ours.\nSo we made some improvement along the code.\n\n\"\"\"\n\nfrom flask import Flask\n\nfrom restapi.connectors import Connector, celery\nfrom restapi.utilities.logs import log\n\napp = Flask(\"beat\")\n\n# Explicit init_app is needed because the app is created directly from Flask\n# instead of using the create_app method from server\nConnector.init_app(app=app)\n\ninstance = celery.get_instance()\n# Used by Celery to run the instance (--app app)\ncelery_app = instance.celery_app\n\n# Reload Flask app code for the worker (needed to have the app context available)\ncelery.CeleryExt.app = app\n\n\nlog.debug(\"Celery beat is ready {}\", celery_app)\n", "worker.py": "from restapi.config import DOCS, HOST_TYPE\nfrom restapi.connectors import celery\nfrom restapi.server import ServerModes, create_app\nfrom restapi.utilities.logs import log\n\ninstance = celery.get_instance()\n# Used by Celery to run the instance (--app app)\ncelery_app = instance.celery_app\n\nif HOST_TYPE != DOCS:\n    # Reload Flask app code for the worker (needed to have the app context available)\n    celery.CeleryExt.app = create_app(\n        name=\"Celery Worker\", mode=ServerModes.WORKER, options={}\n    )\n\n    log.debug(\"Celery worker is ready {}\", celery_app)\n", "ftp": {}, "neo4j": {}, "models.py": "\"\"\" Models for the relational database \"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlalchemy import Column, DateTime, ForeignKey, String, Table\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\n# Define multi-multi relation\nroles_users = Table(\n    \"roles_users\",\n    Base.metadata,\n    Column(\"user_id\", ForeignKey(\"user.id\")),\n    Column(\"role_id\", ForeignKey(\"role.id\")),\n)\n\n\nclass Role(Base):\n    __tablename__ = \"role\"\n\n    def __repr__(self) -> str:  # pragma: no cover\n        name = self.__class__.__name__\n        return f\"{name}({self.id}, {self.name})\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(80), unique=True, nullable=False)\n    description: Mapped[str] = mapped_column(String(255), nullable=False)\n\n    users: Mapped[list[\"User\"]] = relationship(\n        \"User\",\n        secondary=roles_users,\n        back_populates=\"roles\",\n        cascade_backrefs=False,\n    )\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    def __repr__(self) -> str:  # pragma: no cover\n        name = self.__class__.__name__\n        return f\"{name}({self.id}, {self.email})\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    uuid: Mapped[str] = mapped_column(String(36), unique=True, nullable=False)\n    email: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)\n    name: Mapped[str] = mapped_column(String(255, collation=None), nullable=False)\n    surname: Mapped[str] = mapped_column(String(255, collation=None), nullable=False)\n    authmethod: Mapped[str] = mapped_column(String(20), nullable=False)\n    password: Mapped[str] = mapped_column(String(255), nullable=False)\n    mfa_hash: Mapped[Optional[str]] = mapped_column(String(255))\n    first_login: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))\n    last_login: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))\n    last_password_change: Mapped[Optional[datetime]] = mapped_column(\n        DateTime(timezone=True)\n    )\n    is_active: Mapped[bool] = mapped_column(default=True)\n    privacy_accepted: Mapped[bool] = mapped_column(default=True)\n    expiration: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))\n\n    roles: Mapped[list[\"Role\"]] = relationship(\n        \"Role\",\n        secondary=roles_users,\n        back_populates=\"users\",\n    )\n    group_id: Mapped[int] = mapped_column(ForeignKey(\"group.id\"))\n    belongs_to: Mapped[\"Group\"] = relationship(\n        \"Group\",\n        back_populates=\"members\",\n        cascade_backrefs=False,\n        foreign_keys=[group_id],\n    )\n    tokens: Mapped[list[\"Token\"]] = relationship(\n        \"Token\",\n        back_populates=\"emitted_for\",\n        cascade_backrefs=False,\n        cascade=\"delete\",\n    )\n    logins: Mapped[list[\"Login\"]] = relationship(\n        \"Login\",\n        back_populates=\"user\",\n        cascade_backrefs=False,\n        cascade=\"delete\",\n    )\n\n\nclass Token(Base):\n    __tablename__ = \"token\"\n\n    def __repr__(self) -> str:  # pragma: no cover\n        name = self.__class__.__name__\n        return f\"{name}({self.id})\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    jti: Mapped[str] = mapped_column(String(36), unique=True, nullable=False)\n    token: Mapped[str] = mapped_column(nullable=False)\n    token_type: Mapped[str] = mapped_column(String(1), nullable=False)\n    creation: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)\n    expiration: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))\n    last_access: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))\n    IP: Mapped[Optional[str]] = mapped_column(String(46))\n    location: Mapped[Optional[str]] = mapped_column(String(256))\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user.id\"))\n    emitted_for: Mapped[\"User\"] = relationship(\n        \"User\",\n        back_populates=\"tokens\",\n        cascade_backrefs=False,\n    )\n\n\nclass Group(Base):\n    __tablename__ = \"group\"\n\n    def __repr__(self) -> str:  # pragma: no cover\n        name = self.__class__.__name__\n        return f\"{name}({self.id}, {self.shortname})\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    uuid: Mapped[str] = mapped_column(String(36), unique=True, nullable=False)\n    shortname: Mapped[str] = mapped_column(String(64), unique=True, nullable=False)\n    fullname: Mapped[str] = mapped_column(String(256), nullable=False)\n\n    members: Mapped[list[\"User\"]] = relationship(\n        \"User\",\n        back_populates=\"belongs_to\",\n        cascade_backrefs=False,\n    )\n\n\nclass Login(Base):\n    __tablename__ = \"login\"\n\n    def __repr__(self) -> str:  # pragma: no cover\n        name = self.__class__.__name__\n        return f\"{name}({self.id})\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    date: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)\n    username: Mapped[Optional[str]] = mapped_column(String(100))\n    IP: Mapped[Optional[str]] = mapped_column(String(46))\n    location: Mapped[Optional[str]] = mapped_column(String(256))\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user.id\"), nullable=True)\n    user: Mapped[\"User\"] = relationship(\n        \"User\",\n        back_populates=\"logins\",\n        cascade_backrefs=False,\n    )\n    failed: Mapped[bool] = mapped_column(default=False)\n    flushed: Mapped[bool] = mapped_column(default=False)\n", "parser.py": "import csv\nfrom typing import Any\n\nfrom restapi.config import IMPORT_PATH\nfrom restapi.connectors import neo4j\nfrom restapi.utilities.logs import log\n\n\nclass DataDump:\n    def __init__(self, filename: str, fields: list[str]) -> None:\n        for f in fields:\n            if \":\" not in f:\n                raise ValueError(\n                    f\"Wrong field syntax, type is missing in {f}. Expected {f}:TYPE. \"\n                    \"Supported types: string,int,float\"\n                )\n\n        # This will be used by the backend to write the file\n        self.filepath = IMPORT_PATH.joinpath(filename)\n        # This will be used by neo4j to read the file\n        self.filename = filename\n        self.cache: dict[str, bool] = {}\n        self.fields = fields\n        self.counter = 0\n\n        with open(self.filepath, \"w+\") as out_handle:\n            tsv_node_writer = csv.writer(out_handle, delimiter=\"\\t\")\n            fields_without_types: list[str] = []\n            for f in fields:\n                fields_without_types.append(f.split(\":\")[0])\n            tsv_node_writer.writerow(fields_without_types)\n\n        self.handle = open(self.filepath, \"a+\")\n        self.writer = csv.writer(self.handle, delimiter=\"\\t\")\n\n    @property\n    def count(self) -> int:\n        return self.counter + len(self.cache)\n\n    def flush_cache(self) -> None:\n        self.counter += len(self.cache)\n        self.cache.clear()\n\n    def clean(self) -> None:\n        self.flush_cache()\n        self.close()\n        self.filepath.unlink()\n\n    def print_line(self, args: Any) -> None:\n        for a in args:\n            if a is None:\n                raise ValueError(f\"Found NULL value in line: {args}\")\n\n        h = str(args)\n        if h in self.cache:\n            return\n        self.cache[h] = True\n\n        self.writer.writerow(args)\n\n    @staticmethod\n    def cypher_exec(cypher: str) -> Any:\n        graph = neo4j.get_instance()\n        return graph.cypher(cypher)\n\n    @staticmethod\n    def get_properties(fields: list[str]) -> str:\n        properties: list[str] = []\n\n        for f in fields:\n            tokens = f.split(\":\")\n            if tokens[1] == \"string\":\n                properties.append(f\"{tokens[0]}: line.{tokens[0]}\")\n            elif tokens[1] == \"int\":\n                properties.append(f\"{tokens[0]}: toInteger(line.{tokens[0]})\")\n            elif tokens[1] == \"float\":\n                properties.append(f\"{tokens[0]}: toFloat(line.{tokens[0]})\")\n\n        return \",\".join(properties)\n\n    @classmethod\n    def switch_label(cls, old_label: str, new_label: str, limit: int = 10000) -> None:\n        cypher = f\"\"\"\n            MATCH (n:{old_label})\n            WITH n\n            LIMIT {limit}\n            SET n:{new_label}\n            REMOVE n:{old_label}\n            RETURN count(n)\n        \"\"\"\n        result = cls.cypher_exec(cypher)\n\n        num = result[0][0]\n        log.info(\"{} {} > {}\", num, old_label, new_label)\n        if num > 0:\n            cls.switch_label(old_label, new_label, limit=limit)\n\n    @classmethod\n    def delete_nodes(cls, label: str, limit: int = 10000) -> None:\n        cypher = f\"\"\"\n            MATCH (n:{label})\n            WITH n\n            LIMIT {limit}\n            DETACH DELETE n\n            RETURN count(n)\n        \"\"\"\n\n        result = cls.cypher_exec(cypher)\n\n        num = result[0][0]\n        log.info(\"Deleted {} {} nodes\", num, label)\n        if num == limit:\n            cls.delete_nodes(label, limit=limit)\n\n    @classmethod\n    def delete_relationships(\n        cls, label1: str, relation: str, label2: str, limit: int = 50000\n    ) -> None:\n        cypher = f\"\"\"\n            MATCH (:{label1})-[r:{relation}]->(:{label2})\n            WITH r\n            LIMIT {limit}\n            DELETE r\n            RETURN count(r)\n        \"\"\"\n\n        result = cls.cypher_exec(cypher)\n\n        num = result[0][0]\n        log.info(\n            \"Deleted {} (:{}-[{}]->(:{}) relationships\", num, label1, relation, label2\n        )\n        if num == limit:\n            cls.delete_relationships(label1, relation, label2, limit=limit)\n\n    def close(self) -> None:\n        if self.handle:\n            self.handle.close()\n\n    def __del__(self) -> None:\n        self.close()\n\n\nclass NodeDump(DataDump):\n    def __init__(self, label: str, fields: list[str]) -> None:\n        filename = f\"{label}.tsv\".lower()\n        super().__init__(filename, fields)\n        self.label = label\n\n    # def bulk_delete(self, limit: int = 10000) -> None:\n    #     self.delete_nodes(self.label, limit=limit)\n\n    def dump(self, *args: Any) -> None:\n        if len(args) != len(self.fields):\n            raise ValueError(\n                f\"Unexpected number of fields\\nReceived {len(args)} ({args})\\n\"\n                f\"Expected {len(self.fields)} ({self.fields})\"\n            )\n        self.print_line(args)\n\n    def store(self, chunk_size: int = 10000) -> None:\n        self.close()\n\n        log.info(\"Storing {} ({}) nodes\", self.count, self.label)\n\n        properties: str = self.get_properties(self.fields)\n\n        cypher = f\"\"\"\nLOAD CSV WITH HEADERS FROM 'file:///{self.filename}' AS line FIELDTERMINATOR '\\t'\nCALL {{\n    WITH line\n    MERGE (:{self.label} {{\n        {properties}\n    }}\n    )\n}} IN TRANSACTIONS OF {chunk_size} ROWS\n\"\"\"\n\n        self.cypher_exec(cypher)\n\n\nclass RelationDump(DataDump):\n    NODE1_LABEL = \"node1\"\n    NODE2_LABEL = \"node2\"\n\n    def __init__(\n        self,\n        label1: str,\n        relation: str,\n        label2: str,\n        fields: list[str],\n        ignore_indexes: bool = False,\n    ) -> None:\n        filename = f\"{label1}_{relation}_{label2}.tsv\".lower()\n        # This is to prevent duplicates in node keys\n        self.key1 = fields[0]\n        self.key2 = fields[1]\n        fields[0] = f\"{self.NODE1_LABEL}:string\"\n        fields[1] = f\"{self.NODE2_LABEL}:string\"\n        super().__init__(filename, fields)\n\n        self.label1 = label1\n        self.relation = relation\n        self.label2 = label2\n\n        if not ignore_indexes:\n            self.verify_indexes(self.label1, self.key1)\n            self.verify_indexes(self.label2, self.key2)\n\n    # def bulk_delete(self, limit: int = 10000) -> None:\n    #     self.delete_relationships(\n    #         self.label1, self.relation, self.label2, limit=limit\n    #     )\n\n    def dump(self, *args: Any) -> None:\n        if len(args) != len(self.fields):\n            raise ValueError(\n                f\"Unexpected number of fields\\nReceived {len(args)} ({args})\\n\"\n                f\"Expected {len(self.fields)} ({self.fields})\"\n            )\n        self.print_line(args)\n\n    def store(self, chunk_size: int = 10000) -> None:\n        self.close()\n\n        log.info(\n            \"Storing {} ({})-[:{}]->({}) relationships\",\n            self.count,\n            self.label1,\n            self.relation,\n            self.label2,\n        )\n\n        field1 = self.fields[0].split(\":\")[0]\n        field2 = self.fields[1].split(\":\")[0]\n\n        properties: str = self.get_properties(self.fields[2:])\n\n        cypher = f\"\"\"\nLOAD CSV WITH HEADERS FROM 'file:///{self.filename}' AS line FIELDTERMINATOR '\\t'\nCALL {{\n    WITH line\n    MATCH (node1: {self.label1} {{{self.key1}: line.{field1}}})\n    MATCH (node2: {self.label2} {{{self.key2}: line.{field2}}})\n    MERGE (node1)-[:{self.relation} {{{properties}}}]->(node2)\n}} IN TRANSACTIONS OF {chunk_size} ROWS\n\"\"\"\n\n        self.cypher_exec(cypher)\n\n    @staticmethod\n    def verify_indexes(label: str, key: str) -> None:\n        graph = neo4j.get_instance()\n        indexes = graph.cypher(\"CALL db.indexes()\")\n        for index in indexes:\n            labelsOrTypes = index[7]\n            properties = index[8]\n\n            if len(labelsOrTypes) == 1 and len(properties) == 1:\n                if labelsOrTypes[0] == label and properties[0] == key:\n                    log.debug(\"Found an index for {}.{}\", label, key)\n                    break\n        else:\n            raise ValueError(\n                f\"Can't find an index for {label}.{key}: \"\n                \"add an index or skip this check with ignore_indexes=True\"\n            )\n", "types.py": "\"\"\"\nPython hints definitions\n\"\"\"\n\nfrom typing import Any, Callable, Optional, TypeVar, Union\n\nfrom flask import Response as FlaskResponse\nfrom werkzeug.wrappers import Response as WerkzeugResponse\n\nResponse = Union[FlaskResponse, WerkzeugResponse, tuple[Any, int, dict[str, str]]]\nResponseContent = Optional[Any]\nProps = dict[str, Any]\nFlaskRequest = Any\n# instead of ... should be [EndpointResource, anything else]\n# but mypy only allows to specify all or none input parameters\nEndpointFunction = TypeVar(\"EndpointFunction\", bound=Callable[..., Response])\n", "rabbitmq": {}, "redis": {}, "smtp": {}, "mailmock.py": "import email\nfrom smtplib import SMTPException, SMTPServerDisconnected\nfrom types import TracebackType\nfrom typing import Optional, TypeVar\n\nimport orjson\n\nfrom restapi.utilities.logs import LOGS_FOLDER, log\n\nT = TypeVar(\"T\", bound=\"SMTP\")\n\n\nclass SMTP:\n    \"\"\"\n    This is a very rough replacement of smtplib.SMTP class\n    \"\"\"\n\n    def __init__(self, host: str) -> None:\n        log.info(\"Mail mock initialized with host = {}\", host)\n        self.disconnected = False\n\n    def __enter__(self: T) -> T:  # pragma: no cover\n        return self\n\n    def __exit__(\n        self,\n        _type: Optional[type[Exception]],\n        value: Optional[Exception],\n        tb: Optional[TracebackType],\n    ) -> bool:  # pragma: no cover\n        # return False if the exception is not handled:\n        # -> return True if the exception is None (nothing to be handled)\n        # -> return False if the exception is not None (because it is not handled here)\n        # always return False is not accepted by mypy...\n        return _type is None\n\n    @staticmethod\n    def set_debuglevel(intval: int) -> None:\n        log.info(\"Mail mock set debug level = {}\", intval)\n\n    @staticmethod\n    def connect(host: str, port: int) -> None:\n        log.info(\"Mail mock connected to {}:{}\", host, port)\n\n    @staticmethod\n    def login(user: str, pwd: str) -> None:\n        log.info(\"Mail mock login ok\")\n\n    def quit(self) -> None:\n        self.disconnected = True\n        log.info(\"Mail mock sent quit message\")\n\n    @staticmethod\n    def ehlo() -> None:\n        log.info(\"Mail mock sent ehlo message\")\n\n    @staticmethod\n    def sendmail(from_address: str, dest_addresses: str, msg: str) -> None:\n        if from_address == \"invalid1\":\n            raise SMTPException(\"SMTP Error\")\n\n        if from_address == \"invalid2\":\n            raise Exception(\"Generic Error\")\n\n        json_fpath = LOGS_FOLDER.joinpath(\"mock.mail.lastsent.json\")\n        body_fpath = LOGS_FOLDER.joinpath(\"mock.mail.lastsent.body\")\n        json_fpath_prev = LOGS_FOLDER.joinpath(\"mock.mail.prevsent.json\")\n        body_fpath_perv = LOGS_FOLDER.joinpath(\"mock.mail.prevsent.body\")\n\n        if json_fpath.exists():\n            json_fpath.rename(json_fpath_prev)\n\n        if body_fpath.exists():\n            body_fpath.rename(body_fpath_perv)\n\n        data = {\"from\": from_address, \"cc\": dest_addresses, \"msg\": msg}\n        log.info(\"Mail mock sending email from {} to {}\", from_address, dest_addresses)\n        with open(json_fpath, \"w+\") as file:\n            file.write(orjson.dumps(data).decode(\"UTF-8\"))\n        log.info(\"Mail mock sent email from {} to {}\", from_address, dest_addresses)\n        log.info(\"Mail mock mail written in {}\", json_fpath)\n\n        log.info(\"Extracting body\")\n        b = email.message_from_string(msg)\n        if b.is_multipart():\n            # get the first payload (the non html version)\n            first_payload = b.get_payload()[0]  # type: ignore\n            # This is enough when the message is not based64-encoded\n            # payload = first_payload.get_payload()\n            # Otherwise this is needed:\n            payload = first_payload.get_payload(decode=True).decode(\"utf-8\")  # type: ignore\n        else:\n            # This is enough when the message is not based64-encoded\n            # payload = b.get_payload()\n            # Otherwise this is needed:\n            payload = b.get_payload(decode=True).decode(\"utf-8\")  # type: ignore\n\n        with open(body_fpath, \"w+\") as file:\n            file.write(payload)\n\n        log.info(\"Mail body written in {}\", body_fpath)\n\n    def noop(self) -> tuple[int]:\n        if self.disconnected:\n            raise SMTPServerDisconnected  # pragma: no cover\n\n        return (250,)\n\n\nclass SMTP_SSL(SMTP):\n    pass\n", "notifications.py": "from collections.abc import Iterator\nfrom typing import Any, Optional\n\nimport html2text\nimport jinja2\n\nfrom restapi.config import (\n    ABS_RESTAPI_PATH,\n    CODE_DIR,\n    CUSTOM_PACKAGE,\n    MODELS_DIR,\n    get_frontend_url,\n    get_project_configuration,\n)\nfrom restapi.connectors import CONNECTORS_FOLDER, Connector, smtp\nfrom restapi.connectors.smtp import Mail\nfrom restapi.env import Env\nfrom restapi.services.authentication import Login, User\nfrom restapi.utilities.logs import log\nfrom restapi.utilities.time import seconds_to_human\n\n\ndef get_html_template(\n    template_file: str, replaces: dict[str, Any]\n) -> tuple[Optional[str], Optional[str]]:\n    html = _get_html_template(template_file, replaces)\n    header_html = _get_html_template(\"email_header.html\", replaces)\n    footer_html = _get_html_template(\"email_footer.html\", replaces)\n\n    if html is None or header_html is None or footer_html is None:\n        return None, None\n\n    html_body = f\"{header_html}{html}{footer_html}\"\n    plain_body = convert_html2text(html_body)\n    return html_body, plain_body\n\n\ndef convert_html2text(html_body: str) -> str:\n    h2t = html2text.HTML2Text()\n    h2t.unicode_snob = False\n    h2t.ignore_emphasis = True\n    h2t.single_line_break = True\n    h2t.ignore_images = True\n    # zero for no wrap of long lines [otherwise tokens in urls will be broken]\n    # but since the maximum allowed line length on email is 998 octets\n    # I set a very long wrap, that should not break any tokens\n    h2t.body_width = 512\n    return h2t.handle(html_body)\n\n\ndef _get_html_template(template_file: str, replaces: dict[str, Any]) -> Optional[str]:\n    # Custom templates from project backend/models/email/\n    template_path = CODE_DIR.joinpath(\n        CUSTOM_PACKAGE, MODELS_DIR, \"emails\", template_file\n    )\n\n    if not template_path.exists():\n        # Core templates from restapi/connectors/smtp/templates/\n        template_path = ABS_RESTAPI_PATH.joinpath(\n            CONNECTORS_FOLDER,\n            \"smtp\",\n            \"templates\",\n            template_file,\n        )\n\n    if not template_path.exists():\n        log.info(\"Template not found: {}\", template_path)\n        return None\n\n    try:\n        templateLoader = jinja2.FileSystemLoader(searchpath=template_path.parent)\n        templateEnv = jinja2.Environment(loader=templateLoader, autoescape=True)\n        template = templateEnv.get_template(template_file)\n\n        replaces.setdefault(\"host\", get_frontend_url())\n\n        return template.render(**replaces)\n    except Exception as e:  # pragma: no cover\n        log.error(\"Error loading template {}: {}\", template_file, e)\n        return None\n\n\ndef get_reply_to() -> str:\n    if addr := Env.get(\"SMTP_REPLYTO\", \"\"):\n        return addr\n    if addr := Env.get(\"SMTP_NOREPLY\", \"\"):\n        return addr\n    return Env.get(\"SMTP_ADMIN\", \"\")\n\n\ndef send_notification(\n    subject: str,\n    template: str,\n    # if None will be sent to the administrator\n    to_address: Optional[str] = None,\n    data: Optional[dict[str, Any]] = None,\n    user: Optional[User] = None,\n    send_async: bool = False,\n) -> bool:\n    # Always enabled during tests\n    if not Connector.check_availability(\"smtp\"):  # pragma: no cover\n        return False\n\n    title = get_project_configuration(\"project.title\", default=\"Unkown title\")\n\n    reply_to = get_reply_to()\n\n    if data is None:\n        data = {}\n\n    data.setdefault(\"project\", title)\n    data.setdefault(\"reply_to\", reply_to)\n\n    if user:\n        data.setdefault(\"username\", user.email)\n        data.setdefault(\"name\", user.name)\n        data.setdefault(\"surname\", user.surname)\n\n    html_body, plain_body = get_html_template(template, data)\n\n    if not html_body:  # pragma: no cover\n        log.error(\"Can't load {}\", template)\n        return False\n\n    subject = f\"{title}: {subject}\"\n\n    if send_async:\n        Mail.send_async(\n            subject=subject,\n            body=html_body,\n            to_address=to_address,\n            plain_body=plain_body,\n        )\n        return False\n\n    smtp_client = smtp.get_instance()\n    return smtp_client.send(\n        subject=subject,\n        body=html_body,\n        to_address=to_address,\n        plain_body=plain_body,\n    )\n\n\ndef send_registration_notification(user: User) -> None:\n    # no return value since it is a send_async\n    send_notification(\n        subject=\"New user registered\",\n        template=\"new_user_registered.html\",\n        to_address=None,\n        data=None,\n        user=user,\n        send_async=True,\n    )\n\n\ndef send_activation_link(user: User, url: str) -> bool:\n    return send_notification(\n        subject=Env.get(\"EMAIL_ACTIVATION_SUBJECT\", \"Account activation\"),\n        template=\"activate_account.html\",\n        to_address=user.email,\n        data={\"url\": url},\n        user=user,\n    )\n\n\ndef send_password_reset_link(user: User, uri: str, reset_email: str) -> bool:\n    return send_notification(\n        subject=\"Password Reset\",\n        template=\"reset_password.html\",\n        to_address=reset_email,\n        data={\"url\": uri},\n        user=user,\n    )\n\n\ndef notify_login_block(\n    user: User, events: Iterator[Login], duration: int, url: str\n) -> None:\n    # no return value since it is a send_async\n    send_notification(\n        subject=\"Your credentials have been blocked\",\n        template=\"blocked_credentials.html\",\n        to_address=user.email,\n        data={\"events\": events, \"duration\": seconds_to_human(duration), \"url\": url},\n        user=user,\n        send_async=True,\n    )\n\n\ndef notify_new_credentials_to_user(user: User, unhashed_password: str) -> None:\n    # no return value since it is a send_async\n    send_notification(\n        subject=\"New credentials\",\n        template=\"new_credentials.html\",\n        to_address=user.email,\n        data={\"password\": unhashed_password},\n        user=user,\n        send_async=True,\n    )\n\n\ndef notify_update_credentials_to_user(user: User, unhashed_password: str) -> None:\n    # no return value since it is a send_async\n    send_notification(\n        subject=\"Password changed\",\n        template=\"update_credentials.html\",\n        to_address=user.email,\n        data={\"password\": unhashed_password},\n        user=user,\n        send_async=True,\n    )\n\n\ndef send_celery_error_notification(\n    task_id: str, task_name: str, arguments: str, error_stack: Any, retry_num: int\n) -> None:\n    if retry_num > 0:\n        subject = f\"Task {task_name} failed (failure #{retry_num})\"\n    else:\n        subject = f\"Task {task_name} failed\"\n\n    # no return value since it is a send_async\n    send_notification(\n        subject=subject,\n        template=\"celery_error_notification.html\",\n        to_address=None,\n        data={\n            \"task_id\": task_id,\n            \"task_name\": task_name,\n            \"arguments\": arguments,\n            \"error_stack\": error_stack,\n        },\n        user=None,\n        send_async=True,\n    )\n", "templates": {}, "activate_account.html": "Dear {{name}} {{surname}},<br />\n<br />\n<a href=\"{{url}}\">click here</a> to activate your account. If you did not\nrequest a new account, please ignore this email.\n\n<br /><br /><br />\nThank you and sincere greetings\n<br /><br />\n", "blocked_credentials.html": "Dear {{name}} {{surname}},<br />\n<br />\nthis email is to inform you that\n<b>your credentials have been temporarily blocked</b> due to the number of\nfailed login attempts.<br />\n<br />\nPlease inspect the list below to detect any unwanted access attempts:<br />\n<br />\n<ol>\n  {% for value in events -%}\n  <li>\n    {{value[\"date\"].strftime('%d %b %Y, %H:%M:%S')}} UTC from {{value[\"IP\"]}}\n    ({{value[\"location\"]}})\n  </li>\n  {% endfor -%}\n</ol>\n<br />\nIf you do not recognize these accesses please consider to change your password\nto improve your account security.<br />\nTo prevent any further attempt,\n<b\n  >your account has been blocked and will be automatically unlocked in\n  {{duration}}</b\n>.<br />\nIf you recognize all the access attempts above, you can unlock your credentials\nby <a href=\"{{url}}\">clicking here</a>.\n\n<br /><br />\nThis is an automated message, please do not reply to this email.\n", "celery_error_notification.html": "Dear Administrator of {{project}},<br /><br />\nthis email is to notify you that a Celery task failed!<br />\n<br />\nTask ID: <b>{{task_id}}</b><br />\n<br />\nTask name: <b>{{task_name}}</b><br />\n<br />\nArguments: {{arguments}}<br />\n<br />\nError Stack<br />\n<pre>\n{{error_stack}}\n</pre>\n<br />\n<br />\n", "email_footer.html": "<br /><br /><br />\n<i style=\"color: #666; font-size: 0.6em\">\n  This is an automated message, please do not reply to this email if not\n  explicitly requested. The content of this email is intended solely for the\n  addressee(s) and may contain confidential and/or privileged information and\n  may be legally protected from disclosure. It is strictly forbidden to share\n  any part of this message with any third party, without a written consent of\n  the sender. If you received this message by mistake, please notify the sender\n  and follow with its deletion, so that we can ensure such a mistake does not\n  occur in the future. We also want to inform you that we put security at a high\n  priority and we have put efforts into ensuring that the message is error and\n  virus-free. Unfortunately, full security of the email cannot be ensured as,\n  despite our efforts, the data included in emails could be infected,\n  intercepted, or corrupted. Therefore, the recipient should check the email for\n  threats with proper software, as the sender does not accept liability for any\n  damage inflicted by viewing the content of this email.<br />\n  Please do not print this email unless it is necessary, save paper, save\n  trees.<br />\n</i>\n", "email_header.html": "", "new_credentials.html": "Dear {{name}} {{surname}},<br />\n<br />\nplease find below your credentials to access {{project}} on {{host}}:<br /><br />\n<i>Username: {{username}}</i><br />\n<i>Password: {{password}}</i><br />\n<br />\n<b>Once authenticated you will be asked to change this temporary password.</b>\n<br /><br />\nThis is an automated message, please do not reply to this email\n", "new_user_registered.html": "Dear Administrator of {{project}},<br /><br />\nthis email is to notify you that a new user just registered from email\n<b>{{username}}</b> with name <b>{{name}} {{surname}}</b><br />\n<br />\n", "reset_password.html": "Dear {{name}} {{surname}},<br />\n<br />\nuse <a href=\"{{url}}\">this link</a> to force the change of your password.<br /><br />\nIf you never requested to change your password, please ignore this email\n", "update_credentials.html": "Dear {{name}} {{surname}},<br />\n<br />\nyour credentials to access {{project}} on {{host}} are changed:\n<br /><br />\n<i>Username: {{username}}</i><br />\n<i>Password: {{password}}</i><br />\n<br />\n<b>Once authenticated you will be asked to change this temporary password.</b>\n<br /><br />\nThis is an automated message, please do not reply to this email.\n", "sqlalchemy": {}, "customizer.py": "\"\"\"\nBase class to let projects to customize core functionalities\n\"\"\"\n\nimport abc\n\nfrom flask import Flask\n\nfrom restapi.connectors import Connector\nfrom restapi.rest.definition import EndpointResource\nfrom restapi.services.authentication import User\nfrom restapi.types import FlaskRequest, Props\n\nFlaskApp = Flask\n\n\nclass BaseCustomizer(metaclass=abc.ABCMeta):\n    # These are scopes used in get_custom_input_fields\n    ADMIN = 1\n    PROFILE = 2\n    REGISTRATION = 3\n\n    @staticmethod\n    @abc.abstractmethod\n    def custom_user_properties_pre(\n        properties: Props,\n    ) -> tuple[Props, Props]:  # pragma: no cover\n        \"\"\"\n        executed just before user creation\n        use this method to removed or manipulate input properties\n        before sending to the database\n        \"\"\"\n        return properties, {}\n\n    @staticmethod\n    @abc.abstractmethod\n    def custom_user_properties_post(\n        user: User, properties: Props, extra_properties: Props, db: Connector\n    ) -> None:  # pragma: no cover\n        \"\"\"\n        executed just after user creation\n        use this method to implement extra operation needed to create a user\n        e.g. store additional relationships\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abc.abstractmethod\n    def manipulate_profile(\n        ref: EndpointResource, user: User, data: Props\n    ) -> Props:  # pragma: no cover\n        \"\"\"\n        execute before sending data from the profile endpoint\n        use this method to add additonal information to the user profile\n        \"\"\"\n        return data\n\n    @staticmethod\n    @abc.abstractmethod\n    def get_custom_input_fields(\n        request: FlaskRequest, scope: int\n    ) -> Props:  # pragma: no cover\n        # required = request and request.method == \"POST\"\n        \"\"\"\n        if scope == BaseCustomizer.ADMIN:\n            return {\n                'custom_field': fields.Int(\n                    required=required,\n                    # validate=validate.Range(min=0, max=???),\n                    validate=validate.Range(min=0),\n                    label=\"CustomField\",\n                    description=\"This is a custom field\",\n                )\n            }\n        # these are editable fields in profile\n        if scope == BaseCustomizer.PROFILE:\n            return {}\n\n        # these are additional fields in registration form\n        if scope == BaseCustomizer.REGISTRATION:\n            return {}\n        \"\"\"\n        return {}\n\n    @staticmethod\n    @abc.abstractmethod\n    def get_custom_output_fields(request: FlaskRequest) -> Props:  # pragma: no cover\n        \"\"\"\n        this method is used to extend the output model of admin users\n        \"\"\"\n\n        return {}\n", "decorators.py": "\"\"\"\nDecorators used to configure endpoints with metadata, authentication, caching\n, pagination, input validation, output serialization, etc\n\"\"\"\n\nimport inspect\nfrom functools import wraps\nfrom typing import (\n    Any,\n    Callable,\n    Optional,\n    Union,\n    cast,\n    get_args,\n    get_origin,\n    get_type_hints,\n)\n\nimport werkzeug.exceptions\nfrom amqp.exceptions import AccessRefused  # type: ignore\nfrom flask import request\nfrom flask_apispec import marshal_with  # also imported from endpoints\nfrom flask_apispec import use_kwargs as original_use_kwargs\nfrom marshmallow import post_load\nfrom sentry_sdk import capture_exception\n\nfrom restapi.config import API_URL, AUTH_URL, SENTRY_URL\nfrom restapi.connectors import Connector\nfrom restapi.exceptions import RestApiException, ServerError\nfrom restapi.models import PartialSchema, fields, validate\nfrom restapi.rest.annotations import inject_apispec_docs\nfrom restapi.rest.bearer import TOKEN_VALIDATED_KEY\nfrom restapi.rest.bearer import HTTPTokenAuth as auth  # imported as alias for endpoints\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.types import EndpointFunction\nfrom restapi.utilities import print_and_exit\nfrom restapi.utilities.globals import mem\nfrom restapi.utilities.logs import log\nfrom restapi.utilities.uuid import getUUID\n\nlog.debug(\"Auth loaded {}\", auth)\nlog.debug(\"Marshal loaded {}\", marshal_with)\n\n\n# same definition as in:\n# https://github.com/jmcarp/flask-apispec/blob/master/flask_apispec/annotations.py\n# TODO: the original function is not type-hinted... to be fixed in a future\ndef use_kwargs(\n    args: Optional[Any],\n    location: Optional[str] = None,\n    inherit: Optional[Any] = None,\n    apply: Optional[Any] = None,\n    **kwargs: Optional[Any],\n) -> Any:\n    # this use_kwargs is used override the default location (json)\n    # with a more extensive default location (body)\n    # This trick will prevent to add location='body' to mostly all models\n    # Please note that body is also used as \"in\" parameter in swagger specs\n    if location is None:\n        location = \"body\"\n\n    return original_use_kwargs(\n        args=args, location=location, inherit=inherit, apply=apply, **kwargs\n    )\n\n\ndef endpoint(\n    path: str,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    responses: Optional[dict[Union[str, int], str]] = None,\n    **kwargs: Any,\n) -> Callable[[EndpointFunction], EndpointFunction]:\n    def decorator(func: EndpointFunction) -> EndpointFunction:\n        specs: dict[str, Any] = {}\n\n        specs[\"summary\"] = summary\n        specs[\"description\"] = description\n\n        specs_responses: dict[str, dict[str, str]] = {}\n        if responses:\n            for code, message in responses.items():\n                specs_responses[str(code)] = {\"description\": message}\n        specs[\"responses\"] = specs_responses\n        if not path.startswith(\"/\"):\n            normalized_path = f\"/{path}\"\n        else:\n            normalized_path = path\n\n        if not normalized_path.startswith(API_URL) and not normalized_path.startswith(\n            AUTH_URL\n        ):\n            normalized_path = f\"{API_URL}{normalized_path}\"\n\n        if hasattr(func, \"uri\"):  # pragma: no cover\n            print_and_exit(\n                \"Unsupported multiple endpoint mapping found: {}, {}\",\n                func.uri,\n                normalized_path,\n            )\n\n        # \"EndpointFunction\" has no attribute \"uri\"\n        func.uri = normalized_path  # type: ignore[attr-defined]\n        inject_apispec_docs(func, specs, None)\n\n        @wraps(func)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> EndpointFunction:\n            return cast(EndpointFunction, func(self, *args, **kwargs))\n\n        return cast(EndpointFunction, wrapper)\n\n    return decorator\n\n\ndef match_types(static_type: Any, runtime_value: Any) -> bool:\n    # parameters annotated as Any are always accepted, regardless the runtime type\n    if static_type == Any:\n        return True\n\n    if inspect.isclass(runtime_value):\n        runtime_type = runtime_value\n    else:\n        runtime_type = type(runtime_value)\n\n    # If the parameter is annotated with a class (e.g. MyClassName or str)\n    # issubclass is enough to check the runtime type\n    if inspect.isclass(static_type):\n        return issubclass(runtime_type, static_type)\n\n    # In this case the static_type is a generic and cannot be matched with\n    # issubclass or the following error will be raised:\n    # TypeError: Subscripted generics cannot be used with class and instance checks\n\n    origin_type = get_origin(static_type)\n\n    # This can happens if static type is an instance, instead of a Type or a typing\n    if not origin_type:\n        return False\n\n    if origin_type == Union:\n        return any(\n            match_types(arg_type, runtime_value) for arg_type in get_args(static_type)\n        )\n\n    # TODO: typing.get_args(static_type) is not verified\n    # This means that [1] will be accepted as List[str]\n    return match_types(origin_type, runtime_value)\n\n\n# This function takes as input the callback function signature and extracts from both\n# view_args and kwargs the corresponding parameters to be injected at runtime\n# If the parameter is not found in view_args and kwargs or it is found with a wrong\n# type, then a None is returned and the preload decorator will raise a ServerError\n# REVIEW: \u0414\u043b\u0438\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f, \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0443\u0441\u043b\u043e\u0432\u0438\u0439\ndef inject_callback_parameters(\n    callback_fn: Callable[..., Optional[Any]],\n    kwargs: dict[str, Any],\n    view_args: Optional[dict[str, Any]],\n) -> Optional[dict[str, Any]]:\n    callback_name = callback_fn.__name__\n    parameters = get_type_hints(callback_fn)\n\n    if \"endpoint\" not in parameters:\n        log.critical(\n            \"Missing (endpoint: EndpointResource) parameter in {}\", callback_name\n        )\n        return None\n\n    if not match_types(EndpointResource, parameters[\"endpoint\"]):\n        log.critical(\n            \"Wrong type annotation for parameter 'endpoint' in {}, \"\n            \"expected EndpointResource but found {}\",\n            callback_name,\n            parameters[\"endpoint\"].__name__,\n        )\n        return None\n\n    injected_parameters: dict[str, Any] = {}\n    for name, parameter in parameters.items():\n        # endpoint will be injected by the preload decorator and it is not expected\n        # to be found in kwargs / view_args\n        if name == \"endpoint\":\n            continue\n\n        # This is the annotation of the function return, not needed here\n        if name == \"return\":\n            continue\n\n        if view_args and name in view_args:\n            input_param = view_args[name]\n\n        elif name in kwargs:\n            input_param = kwargs[name]\n\n        else:\n            p = inspect.signature(callback_fn).parameters[name]\n            # Parameter is missing but it has a default value, so can be safely skipped\n            if p.default is not p.empty:  # pragma: no cover\n                continue\n\n            log.critical(\n                \"Parameter ({}:{}) in {} isn't found and can't be injected\",\n                name,\n                parameters[name],\n                callback_name,\n            )\n            return None\n\n        if match_types(parameter, input_param):\n            injected_parameters[name] = input_param\n        else:\n            log.critical(\n                \"Wrong type annotation for parameter '{}' in {}, \"\n                \"expected {} but found {}\",\n                name,\n                callback_name,\n                parameter,\n                type(input_param).__name__,\n            )\n            return None\n\n    return injected_parameters\n\n\n# The callback is expected to have a first argument of type EndpointResource and then\n# optional additional parameters automatically injected from kwargs and url parameters\n# I can't define with mypy something like:\n# Callable[[EndpointResource, ...],\ndef preload(\n    callback: Callable[..., dict[str, Any]]\n) -> Callable[[EndpointFunction], EndpointFunction]:\n    \"\"\"\n    callback example:\n\n    from flask import request\n    def myfunc(endpoint: EndpointResource, user: User) -> dict[str, Any]:\n\n        if (\n            not user\n            or not request.view_args\n            or request.view_args.get(\"uuid\") != user.uuid\n        ):\n            raise Unauthorized(\"You are not authorized\")\n\n        # Returned values, if any, will be injected as endpoint parameters\n        return {\"user\": user}\n        # Otherwise can simply return None to inject nothing\n        # return None\n    \"\"\"\n\n    def decorator(func: EndpointFunction) -> EndpointFunction:\n        @wraps(func)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:\n            injected_parameters = inject_callback_parameters(\n                callback, kwargs, request.view_args\n            )\n            if injected_parameters is None:  # pragma: no cover\n                raise ServerError(\"Invalid endpoint signature\")\n\n            # callback can raise exceptions to stop che execution and e.g. implement\n            # custom authorization policies\n            # or can optionally return values (as dict) to be injected\n            # into the endpoint as function parameters\n            if inject := callback(self, **injected_parameters):\n                kwargs.update(inject)\n\n            return func(self, *args, **kwargs)\n\n        return cast(EndpointFunction, wrapper)\n\n    return decorator\n\n\ndef cache_response_filter(response: Response) -> bool:\n    \"\"\"\n    Prevent caching of 5xx errors responses\n    \"\"\"\n    if not isinstance(response, tuple):\n        return True\n\n    if len(response) < 3:  # pragma: no cover\n        return True  # type: ignore[unreachable]\n\n    return response[1] < 500\n\n\ndef make_cache_function_name(name: str) -> str:\n    \"\"\"\n    This is used to manipulate the function name to append a string depending\n    by the Bearer token. This way all cache entries for authenticated endpoints\n    will always user-dependent.\n    \"\"\"\n    # Non authenticated endpoints do not validate the token.\n    # Function name is not expanded by any token that could be provided (are ignored)\n    if not request.environ.get(TOKEN_VALIDATED_KEY):\n        return name\n\n    # If the token is validated, the function name is expanded by a token-dependent key\n    token = auth.get_authorization_token(allow_access_token_parameter=True)\n    new_name = f\"{name}-{hash(token)}\"\n    return new_name\n\n\ndef cache(*args: Any, **kwargs: Any) -> Any:\n    \"\"\"\n    Used to cache endpoint with @decorators.cache(timeout=60)\n    \"\"\"\n    if \"response_filter\" not in kwargs:\n        kwargs[\"response_filter\"] = cache_response_filter\n    if \"make_name\" not in kwargs:\n        kwargs[\"make_name\"] = make_cache_function_name\n\n    if not hasattr(mem, \"cache\"):\n        print_and_exit(\"Cannot load @decorators.cache, is Redis connector available?\")\n\n    return mem.cache.memoize(*args, **kwargs)\n\n# REVIEW: \u0414\u043b\u0438\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f, \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0443\u0441\u043b\u043e\u0432\u0438\u0439\ndef database_transaction(func: EndpointFunction) -> EndpointFunction:\n    @wraps(func)\n    def wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:\n        neo4j_enabled = Connector.check_availability(\"neo4j\")\n        sqlalchemy_enabled = Connector.check_availability(\"sqlalchemy\")\n        if neo4j_enabled:\n            from neomodel import db as neo4j_db\n\n        if sqlalchemy_enabled:\n            # thanks to connectors cache this should always match the\n            # same instance that will be used from inside the endpoint\n            from restapi.connectors import sqlalchemy\n\n            alchemy_db = sqlalchemy.get_instance()\n\n        try:\n            if neo4j_enabled:\n                neo4j_db.begin()\n\n            # Transaction is already open...\n            # if sqlalchemy_enabled:\n            #     pass\n\n            out = func(self, *args, **kwargs)\n\n            if neo4j_enabled:\n                neo4j_db.commit()\n\n            if sqlalchemy_enabled:\n                alchemy_db.session.commit()\n\n            return out\n        except Exception as e:\n            log.debug(\"Rolling backend database transaction\")\n            try:\n                if neo4j_enabled:\n                    neo4j_db.rollback()\n\n                if sqlalchemy_enabled:\n                    alchemy_db.session.rollback()\n\n            except Exception as sub_ex:  # pragma: no cover\n                log.warning(\"Exception raised during rollback: {}\", sub_ex)\n            raise e\n\n    return cast(EndpointFunction, wrapper)\n\n\nclass Pagination(PartialSchema):\n    get_total = fields.Boolean(\n        required=False,\n        metadata={\"description\": \"Request the total number of elements\"},\n    )\n    page = fields.Int(\n        required=False,\n        validate=validate.Range(min=1),\n        metadata={\"description\": \"Current page number\"},\n    )\n    size = fields.Int(\n        required=False,\n        validate=validate.Range(min=1, max=100),\n        metadata={\"description\": \"Number of elements to retrieve\"},\n    )\n    sort_order = fields.Str(\n        validate=validate.OneOf([\"asc\", \"desc\"]), required=False, load_default=\"asc\"\n    )\n    sort_by = fields.Str(required=False, load_default=None)\n    input_filter = fields.Str(required=False, load_default=None)\n\n    @post_load\n    def verify_parameters(self, data: dict[str, Any], **kwargs: Any) -> dict[str, Any]:\n        if \"get_total\" in data:\n            data[\"page\"] = None\n            data[\"size\"] = None\n        else:\n            data.setdefault(\"get_total\", False)\n            data.setdefault(\"page\", 1)\n            data.setdefault(\"size\", 20)\n\n        return data\n\n\ndef get_pagination(func: EndpointFunction) -> EndpointFunction:\n    @wraps(func)\n    # Should be converted in use_args, if/when available\n    # https://github.com/jmcarp/flask-apispec/issues/189\n    @use_kwargs(Pagination, location=\"query\")\n    def get_wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:\n        return func(self, *args, **kwargs)\n\n    @wraps(func)\n    # Should be converted in use_args, if/when available\n    # https://github.com/jmcarp/flask-apispec/issues/189\n    @use_kwargs(Pagination)\n    def wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:\n        return func(self, *args, **kwargs)\n\n    if func.__name__ == \"get\":\n        return cast(EndpointFunction, get_wrapper)\n    return cast(EndpointFunction, wrapper)\n\n\nclass ChunkUpload(PartialSchema):\n    name = fields.Str(required=True)\n    mimeType = fields.Str(required=True)\n    size = fields.Int(required=True, validate=validate.Range(min=1))\n    lastModified = fields.Int(required=True, validate=validate.Range(min=1))\n\n\ndef init_chunk_upload(func: EndpointFunction) -> EndpointFunction:\n    @wraps(func)\n    # Should be converted in use_args, if/when available\n    # https://github.com/jmcarp/flask-apispec/issues/189\n    @use_kwargs(ChunkUpload)\n    def wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:\n        return func(self, *args, **kwargs)\n\n    return cast(EndpointFunction, wrapper)\n\n\n# This decorator is automatically added to every endpoints... do not use it explicitly\ndef catch_exceptions(**kwargs: Any) -> Callable[[EndpointFunction], EndpointFunction]:\n    \"\"\"\n    A decorator to preprocess an API class method,\n    and catch a specific error.\n    \"\"\"\n\n    def decorator(func: EndpointFunction) -> EndpointFunction:\n        @wraps(func)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:\n            out = None\n\n            try:\n                out = func(self, *args, **kwargs)\n            # Catch the exception requested by the user\n            except RestApiException as e:\n                if e.is_warning:\n                    log.warning(e)\n                else:\n                    log.exception(e)\n                    log.error(e)\n\n                return self.response(\n                    e.args[0],\n                    code=e.status_code,\n                    force_json=True,\n                )\n\n            except werkzeug.exceptions.BadRequest:  # pragma: no cover\n                # do not stop werkzeug BadRequest\n                raise\n\n            except werkzeug.exceptions.UnprocessableEntity:\n                # do not stop werkzeug UnprocessableEntity, it will be\n                # catched by handle_marshmallow_errors\n                raise\n\n            # raised in case of malformed Range header\n            except werkzeug.exceptions.RequestedRangeNotSatisfiable:\n                raise\n            # Catch any other exception\n\n            # errors with RabbitMQ credentials raised when sending Celery tasks\n            except AccessRefused as e:  # pragma: no cover\n                log.error(e)\n                return self.response(\n                    \"Unexpected Server Error\", code=500, force_json=True\n                )\n            except Exception as e:  # pragma: no cover\n                if SENTRY_URL is not None:\n                    capture_exception(e)\n\n                excname = e.__class__.__name__\n                message = str(e)\n                if not message:  # pragma: no cover\n                    message = \"Unknown error\"\n\n                error_id = getUUID()\n\n                log.error(\n                    \"Catched {} exception with ID {}: {}\", excname, error_id, message\n                )\n                log.exception(message)\n\n                if excname in [\"SystemError\"]:\n                    return self.response(\n                        \"Unexpected Server Error\", code=500, force_json=True\n                    )\n\n                return self.response(\n                    {excname: f\"There was an unexpected error. ErrorID: {error_id}\"},\n                    code=400,\n                )\n\n            return out\n\n        return cast(EndpointFunction, wrapper)\n\n    return decorator\n", "endpoints": {}, "admin_groups.py": "import orjson\nimport pytest\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication, Role\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import Events, log\n\n\ndef get_random_group_name(faker: Faker) -> str:\n    # faker.company alone is not always enough and some\n    # \"Group already exists with shortname\" occasionally occur during tests\n    return f\"{faker.company()}-{faker.pyint(2, 100)}\"\n\n\nclass TestApp(BaseTests):\n    def test_admin_groups(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/groups tests\")\n            return\n\n        auth = Connector.get_authentication_instance()\n        staff_role_enabled = Role.STAFF.value in [r.name for r in auth.get_roles()]\n        for role in (\n            Role.ADMIN,\n            Role.STAFF,\n        ):\n            if not staff_role_enabled:  # pragma: no cover\n                log.warning(\n                    \"Skipping tests of admin/groups endpoints, role Staff not enabled\"\n                )\n                continue\n            else:\n                log.warning(\"Testing admin/groups endpoints as {}\", role)\n\n            if role == Role.ADMIN:\n                user_email = BaseAuthentication.default_user\n                user_password = BaseAuthentication.default_password\n            elif role == Role.STAFF:\n                _, user_data = self.create_user(client, roles=[Role.STAFF])\n                user_email = user_data.get(\"email\")\n                user_password = user_data.get(\"password\")\n\n            headers, _ = self.do_login(client, user_email, user_password)\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n\n            schema = self.get_dynamic_input_schema(client, \"admin/groups\", headers)\n            data = self.buildData(schema)\n\n            # Event 1: create\n            r = client.post(f\"{API_URI}/admin/groups\", json=data, headers=headers)\n            assert r.status_code == 200\n            uuid = self.get_content(r)\n            assert isinstance(uuid, str)\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            assert events[0].event == Events.create.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"Group\"\n            assert events[0].url == \"/api/admin/groups\"\n            assert \"fullname\" in events[0].payload\n            assert \"shortname\" in events[0].payload\n\n            # Save it for the following tests\n            event_target_id = events[0].target_id\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            assert len(groups) > 0\n\n            assert \"uuid\" in groups[0]\n            assert \"shortname\" in groups[0]\n            assert \"fullname\" in groups[0]\n            assert \"members\" in groups[0]\n            assert len(groups[0][\"members\"]) > 0\n            assert \"coordinators\" in groups[0]\n\n            fullname = None\n            for g in groups:\n                if g.get(\"uuid\") == uuid:\n                    fullname = g.get(\"fullname\")\n                    break\n            else:  # pragma: no cover\n                pytest.fail(\"Group not found\")\n\n            assert fullname is not None\n\n            newdata = {\n                \"shortname\": get_random_group_name(faker),\n                \"fullname\": get_random_group_name(faker),\n            }\n\n            # Test the differences between post and put schema\n            post_schema = {s[\"key\"]: s for s in schema}\n\n            tmp_schema = self.get_dynamic_input_schema(\n                client, f\"admin/groups/{uuid}\", headers, method=\"put\"\n            )\n            put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n            assert \"shortname\" in post_schema\n            assert post_schema[\"shortname\"][\"required\"]\n            assert \"shortname\" in put_schema\n            assert put_schema[\"shortname\"][\"required\"]\n\n            assert \"fullname\" in post_schema\n            assert post_schema[\"fullname\"][\"required\"]\n            assert \"fullname\" in put_schema\n            assert put_schema[\"fullname\"][\"required\"]\n\n            # Event 2: modify\n            r = client.put(\n                f\"{API_URI}/admin/groups/{uuid}\", json=newdata, headers=headers\n            )\n            assert r.status_code == 204\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            # Group modified (same target_id as above)\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"Group\"\n            assert events[0].target_id == event_target_id\n            assert events[0].url == f\"/api/admin/groups/{event_target_id}\"\n            assert \"fullname\" in events[0].payload\n            assert \"shortname\" in events[0].payload\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            for g in groups:\n                if g.get(\"uuid\") == uuid:\n                    assert g.get(\"fullname\") == newdata.get(\"fullname\")\n                    assert g.get(\"fullname\") != data.get(\"fullname\")\n                    assert g.get(\"fullname\") != fullname\n\n            r = client.put(f\"{API_URI}/admin/groups/xyz\", json=data, headers=headers)\n            assert r.status_code == 404\n\n            # members = auth.get_group_members(group)\n            # with pytest.raises(\n            #     Forbidden,\n            #     match=rf\"Cannot delete this group, it is assigned to {len(members)} user(s)\",\n            # ):\n\n            # Event 3: delete\n            r = client.delete(f\"{API_URI}/admin/groups/{uuid}\", headers=headers)\n            assert r.status_code == 204\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            # Group is deleted (same target_id as above)\n            assert events[0].event == Events.delete.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"Group\"\n            assert events[0].target_id == event_target_id\n            assert events[0].url == f\"/api/admin/groups/{event_target_id}\"\n            assert len(events[0].payload) == 0\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            for g in groups:\n                if g.get(\"uuid\") == uuid:  # pragma: no cover\n                    pytest.fail(\"Group not deleted!\")\n\n            r = client.delete(f\"{API_URI}/admin/groups/xyz\", headers=headers)\n            assert r.status_code == 404\n\n            # Create a group and assign it to the main user\n            # Profile and AdminUsers will react to this change\n            # Very important: admin_groups must be tested before admin_users and profile\n\n            r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, dict)\n            user_uuid = content.get(\"uuid\")\n\n            data = {\n                \"fullname\": \"Default group\",\n                \"shortname\": get_random_group_name(faker),\n            }\n\n            # Event 4: create\n            new_group_uuid, _ = self.create_group(client, data=data)\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            # A new group is created\n            assert events[0].event == Events.create.value\n            # Created via admin utility\n            assert events[0].user == BaseAuthentication.default_user\n            assert events[0].target_type == \"Group\"\n            assert events[0].target_id != event_target_id\n            assert events[0].url == \"/api/admin/groups\"\n            assert \"fullname\" in events[0].payload\n            assert \"shortname\" in events[0].payload\n            # Save it for the following tests\n            event_group_uuid = events[0].target_id\n\n            data = {\n                \"group\": new_group_uuid,\n                # very important, otherwise the default user will lose its role\n                # adding coordinator to enforce the role and use it for additional tests\n                \"roles\": orjson.dumps([role, \"group_coordinator\"]).decode(\"UTF8\"),\n            }\n\n            # a new login is required due to the use of create_group utility\n            headers, _ = self.do_login(client, user_email, user_password)\n\n            # Event 5: modify\n            r = client.put(\n                f\"{API_URI}/admin/users/{user_uuid}\", json=data, headers=headers\n            )\n            assert r.status_code == 204\n\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            # User modified, payload contains the created group\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == user_uuid\n            assert events[0].url == f\"/api/admin/users/{user_uuid}\"\n            assert \"fullname\" not in events[0].payload\n            assert \"shortname\" not in events[0].payload\n            assert \"group\" in events[0].payload\n            assert events[0].payload[\"group\"] == event_group_uuid\n\n            # Event 6: verify the assigned group\n            r = client.get(f\"{API_URI}/admin/users/{user_uuid}\", headers=headers)\n            assert r.status_code == 200\n            users_list = self.get_content(r)\n            assert isinstance(users_list, dict)\n            assert len(users_list) > 0\n            assert \"group\" in users_list\n            assert \"uuid\" in users_list[\"group\"]\n            assert \"fullname\" in users_list[\"group\"]\n            assert \"shortname\" in users_list[\"group\"]\n            assert users_list[\"group\"][\"uuid\"] == new_group_uuid\n\n            # Verify coordinators:\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            assert len(groups) > 0\n\n            # Extract all coordinators:\n            coordinators: set[str] = set()\n            for group in groups:\n                for coordinator in group[\"coordinators\"]:\n                    coordinators.add(coordinator[\"email\"])\n\n            assert user_email in coordinators\n\n            if role == Role.ADMIN:\n                assert BaseAuthentication.default_user in coordinators\n            else:\n                assert BaseAuthentication.default_user not in coordinators\n", "admin_logins.py": "import pytest\nfrom faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_admin_stats(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/logins tests\")\n            return\n\n        r = client.get(f\"{API_URI}/admin/logins\")\n        assert r.status_code == 401\n\n        random_username = faker.ascii_email()\n        self.do_login(client, random_username, faker.pystr(), status_code=401)\n\n        headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/admin/logins\", headers=headers)\n        assert r.status_code == 200\n        logins = self.get_content(r)\n        assert isinstance(logins, list)\n        assert len(logins) > 0\n        assert \"username\" in logins[0]\n        assert \"date\" in logins[0]\n        assert \"IP\" in logins[0]\n        assert \"location\" in logins[0]\n        assert \"failed\" in logins[0]\n        assert \"flushed\" in logins[0]\n\n        for login in logins:\n            if login[\"username\"] == BaseAuthentication.default_user:\n                break\n        else:  # pragma: no cover\n            pytest.fail(\"Default user not found in logins table\")\n\n        for login in logins:\n            if login[\"username\"] == random_username:\n                assert login[\"failed\"] is True\n                assert login[\"flushed\"] is False\n                break\n        else:  # pragma: no cover\n            pytest.fail(\"Random user not found in logins table\")\n", "admin_server_stats.py": "import os\nimport re\nimport shutil\nfrom datetime import datetime\n\nfrom plumbum import local\n\nfrom restapi import decorators\nfrom restapi.endpoints.schemas import StatsSchema, StatsType\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import Role, User\n\n\nclass AdminStats(EndpointResource):\n    labels = [\"helpers\"]\n    depends_on = [\"AUTH_ENABLE\"]\n    private = True\n\n    @decorators.auth.require_all(Role.ADMIN)\n    @decorators.marshal_with(StatsSchema(), code=200)\n    @decorators.endpoint(\n        path=\"/admin/stats\",\n        summary=\"Retrieve stats from the server\",\n        responses={\"200\": \"Stats retrieved\"},\n    )\n    def get(self, user: User) -> Response:\n        # This is the average system load calculated over a given period of time\n        # of 1, 5 and 15 minutes.\n        # In our case, we will show the load average over a period of 15 minutes.\n        # The numbers returned by os.getloadavg() only make sense if\n        # related to the number of CPU cores installed on the system.\n\n        # Here we are converting the load average into percentage.\n        # The higher the percentage the higher the load\n        load_percentage = (100 * os.getloadavg()[-1]) / (os.cpu_count() or 1)\n\n        vmstat = local[\"vmstat\"]\n\n        vmstat_out1 = vmstat().split(\"\\n\")\n        vmstat_out1 = re.split(r\"\\s+\", vmstat_out1[2])\n\n        # convert list in dict\n        vmstat_out1 = {k: v for k, v in enumerate(vmstat_out1)}\n\n        # summarize disk statistics\n        # vmstat_out2 = vmstat([\"-D\"]).split('\\n')\n        # Example:\n        #       22 disks\n        #        0 partitions\n        #   273820 total reads\n        #    63034 merged reads\n        # 27787446 read sectors\n        #  2395193 milli reading\n        #   116450 writes\n        #   438666 merged writes\n        #  4467248 written sectors\n        # 15377932 milli writing\n        #        0 inprogress IO\n        #     1412 milli spent IO\n\n        # event counter statistics\n        vmstat_out2 = vmstat([\"-s\", \"-S\", \"M\"]).split(\"\\n\")\n\n        boot_time = datetime.fromtimestamp(int(vmstat_out2[24].strip().split(\" \")[0]))\n\n        # Disk usage\n        # Get total disk size, used disk space, and free disk\n        total, used, free = shutil.disk_usage(\"/\")\n\n        # Network latency\n        # Here we will ping google at an interval of five seconds for five times\n        # min response time, average response time, and the max response time.\n        # ping = local[\"ping\"]\n        # ping_result = ping([\"-c\", \"5\", \"google.com\"]).split(\"\\n\")\n\n        # ping_result = ping_result[-2].split(\"=\")[-1].split(\"/\")[:3]\n\n        statistics: StatsType = {\n            \"system\": {\"boot_time\": boot_time},\n            \"cpu\": {\n                # Get Physical and Logical CPU Count\n                \"count\": os.cpu_count() or 0,\n                \"load_percentage\": load_percentage,\n                # System\n                #     in: The number of interrupts per second, including the clock.\n                #     cs: The number of context switches per second.\n                # in = vm.get(11, 0)\n                # cs = vm.get(12, 0)\n                # CPU\n                #     These are percentages of total CPU time.\n                #     us: Time spent running non-kernel code. (user time and nice time)\n                #     sy: Time spent running kernel code. (system time)\n                #     id: Time spent idle.\n                #     wa: Time spent waiting for IO.\n                #     st: Time stolen from a virtual machine.\n                \"user\": vmstat_out1.get(13, 0),\n                \"system\": vmstat_out1.get(14, 0),\n                \"idle\": vmstat_out1.get(15, 0),\n                \"wait\": vmstat_out1.get(16, 0),\n                \"stolen\": vmstat_out1.get(17, 0),\n            },\n            \"ram\": {\n                \"total\": vmstat_out2[0].strip().split(\" \")[0],\n                \"used\": vmstat_out2[1].strip().split(\" \")[0],\n                \"active\": vmstat_out2[2].strip().split(\" \")[0],\n                \"inactive\": vmstat_out2[3].strip().split(\" \")[0],\n                \"free\": vmstat_out2[4].strip().split(\" \")[0],\n                \"buffer\": vmstat_out2[5].strip().split(\" \")[0],\n                \"cache\": vmstat_out2[6].strip().split(\" \")[0],\n            },\n            \"swap\": {\n                # Swap\n                #     si: Amount of memory swapped in from disk (/s).\n                #     so: Amount of memory swapped to disk (/s).\n                \"from_disk\": vmstat_out1.get(7, 0),\n                \"to_disk\": vmstat_out1.get(8, 0),\n                \"total\": vmstat_out2[7].strip().split(\" \")[0],\n                \"used\": vmstat_out2[8].strip().split(\" \")[0],\n                \"free\": vmstat_out2[9].strip().split(\" \")[0],\n            },\n            \"disk\": {\n                \"total_disk_space\": total / 1024**3,\n                \"used_disk_space\": used / 1024**3,\n                \"free_disk_space\": free / 1024**3,\n                \"occupacy\": 100 * used / total,\n            },\n            \"procs\": {\n                # Procs\n                # r: The number of processes waiting for run time.\n                # b: The number of processes in uninterruptible sleep.\n                \"waiting_for_run\": vmstat_out1.get(1, 0),\n                \"uninterruptible_sleep\": vmstat_out1.get(2, 0),\n            },\n            \"io\": {\n                # IO\n                #     bi: Blocks received from a block device (blocks/s).\n                #     bo: Blocks sent to a block device (blocks/s).\n                \"blocks_received\": vmstat_out1.get(9, 0),\n                \"blocks_sent\": vmstat_out1.get(10, 0),\n            },\n            \"network_latency\": {\n                # \"min\": ping_result[0].strip(),\n                # \"avg\": ping_result[1].strip(),\n                # \"max\": ping_result[2].strip(),\n                \"min\": 0,\n                \"avg\": 0,\n                \"max\": 0,\n            },\n        }\n\n        return self.response(statistics)\n", "admin_tokens.py": "from typing import Any\n\nfrom glom import glom\n\nfrom restapi import decorators\nfrom restapi.endpoints.schemas import TokenAdminSchema, TotalSchema\nfrom restapi.exceptions import BadRequest, NotFound\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import Role, Token, User\nfrom restapi.utilities.logs import log\n\n\ndef inject_token(endpoint: EndpointResource, token_id: str) -> dict[str, Any]:\n    tokens = endpoint.auth.get_tokens(token_jti=token_id)\n\n    if not tokens:\n        raise NotFound(\"This token does not exist\")\n\n    return {\"token\": tokens[0][\"token\"]}\n\n\nclass AdminTokens(EndpointResource):\n    \"\"\"List all tokens for all users\"\"\"\n\n    labels = [\"authentication\"]\n    depends_on = [\"AUTH_ENABLE\"]\n    private = True\n\n    @decorators.auth.require_all(Role.ADMIN)\n    @decorators.get_pagination\n    @decorators.marshal_with(TokenAdminSchema(many=True), code=200)\n    @decorators.marshal_with(TotalSchema, code=206)\n    @decorators.endpoint(\n        path=\"/admin/tokens\",\n        summary=\"Retrieve all tokens emitted for logged user\",\n        responses={\n            200: \"The list of tokens is returned\",\n            206: \"Total number of elements is returned\",\n        },\n    )\n    def get(\n        self,\n        get_total: bool,\n        page: int,\n        size: int,\n        sort_by: str,\n        sort_order: str,\n        input_filter: str,\n        user: User,\n    ) -> Response:\n        tokens = self.auth.get_tokens(get_all=True)\n\n        if input_filter:\n            filtered_tokens = []\n            for t in tokens:\n                token = t.get(\"token\", \"\").lower()\n                ip = t.get(\"IP\", \"\").lower()\n                location = t.get(\"location\", \"\").lower()\n                if user := t.get(\"user\"):\n                    email = user.email.lower()\n                else:\n                    email = \"\"\n\n                for value in [token, ip, location, email]:\n                    if value and input_filter in value:\n                        filtered_tokens.append(t)\n                        break\n\n            tokens = filtered_tokens\n\n        if get_total:\n            return self.pagination_total(len(tokens))\n\n        if sort_by:\n\n            def sorter(t: Token) -> str:\n                return glom(t, sort_by, default=\"\")  # type: ignore\n\n            tokens = sorted(\n                tokens,\n                # Raising error:\n                # Returning Any from function declared to return \"_SupportsLessThan\"\n                # https://github.com/python/mypy/issues/9656\n                key=sorter,\n                reverse=sort_order == \"desc\",\n            )\n\n        end = page * size\n        start = end - size\n        response = []\n        for t in tokens[start:end]:\n            if t.get(\"user\") is None:  # pragma: no cover\n                log.error(\"Found a token without any user assigned: {}\", t[\"id\"])\n                continue\n            response.append(t)\n\n        return self.response(response)\n\n    @decorators.auth.require_all(Role.ADMIN)\n    @decorators.preload(callback=inject_token)\n    @decorators.endpoint(\n        path=\"/admin/tokens/<token_id>\",\n        summary=\"Invalidate the specified token\",\n        responses={\n            204: \"Token has been invalidated\",\n            404: \"Specified token cannot be found\",\n            400: \"Token invalidation is failed\",\n        },\n    )\n    def delete(self, token_id: str, token: str, user: User) -> Response:\n        if not self.auth.invalidate_token(token=token):\n            raise BadRequest(f\"Failed token invalidation: {token}\")  # pragma: no cover\n\n        return self.empty_response()\n", "admin_users.py": "import orjson\nfrom faker import Faker\nfrom flask import escape\n\nfrom restapi.config import get_project_configuration\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication, Role\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import OBSCURE_VALUE, Events, log\n\n\nclass TestApp(BaseTests):\n    def test_admin_users(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/users tests\")\n            return\n\n        project_tile = get_project_configuration(\"project.title\", default=\"YourProject\")\n\n        auth = Connector.get_authentication_instance()\n        staff_role_enabled = Role.STAFF.value in [r.name for r in auth.get_roles()]\n\n        for role in (\n            Role.ADMIN,\n            Role.STAFF,\n        ):\n            if not staff_role_enabled:  # pragma: no cover\n                log.warning(\n                    \"Skipping tests of admin/users endpoints, role Staff not enabled\"\n                )\n                continue\n            else:\n                log.warning(\"Testing admin/users endpoints as {}\", role)\n\n            if role == Role.ADMIN:\n                user_email = BaseAuthentication.default_user\n                user_password = BaseAuthentication.default_password\n            elif role == Role.STAFF:\n                _, user_data = self.create_user(client, roles=[Role.STAFF])\n                user_email = user_data.get(\"email\")\n                user_password = user_data.get(\"password\")\n\n            headers, _ = self.do_login(client, user_email, user_password)\n            r = client.get(f\"{API_URI}/admin/users\", headers=headers)\n            assert r.status_code == 200\n\n            schema = self.get_dynamic_input_schema(client, \"admin/users\", headers)\n            data = self.buildData(schema)\n\n            data[\"email_notification\"] = True\n            data[\"is_active\"] = True\n            data[\"expiration\"] = None\n\n            # Event 1: create\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers)\n            assert r.status_code == 200\n            uuid = self.get_content(r)\n            assert isinstance(uuid, str)\n\n            # A new User is created\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.create.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].url == \"/api/admin/users\"\n            assert \"name\" in events[0].payload\n            assert \"surname\" in events[0].payload\n            assert \"email\" in events[0].payload\n\n            # Save it for the following tests\n            event_target_id1 = events[0].target_id\n\n            mail = self.read_mock_email()\n            body = mail.get(\"body\", \"\")\n\n            # Subject: is a key in the MIMEText\n            assert body is not None\n            assert mail.get(\"headers\") is not None\n            assert f\"Subject: {project_tile}: New credentials\" in mail.get(\n                \"headers\", \"\"\n            )\n            assert data.get(\"email\", \"MISSING\").lower() in body\n            assert (\n                data.get(\"password\", \"MISSING\") in body\n                or escape(str(data.get(\"password\"))) in body\n            )\n\n            # Test the differences between post and put schema\n            post_schema = {s[\"key\"]: s for s in schema}\n\n            tmp_schema = self.get_dynamic_input_schema(\n                client, f\"admin/users/{uuid}\", headers, method=\"put\"\n            )\n            put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n            assert \"email\" in post_schema\n            assert post_schema[\"email\"][\"required\"]\n            assert \"email\" not in put_schema\n\n            assert \"name\" in post_schema\n            assert post_schema[\"name\"][\"required\"]\n            assert \"name\" in put_schema\n            assert not put_schema[\"name\"][\"required\"]\n\n            assert \"surname\" in post_schema\n            assert post_schema[\"surname\"][\"required\"]\n            assert \"surname\" in put_schema\n            assert not put_schema[\"surname\"][\"required\"]\n\n            assert \"password\" in post_schema\n            assert post_schema[\"password\"][\"required\"]\n            assert \"password\" in put_schema\n            assert not put_schema[\"password\"][\"required\"]\n\n            assert \"group\" in post_schema\n            assert post_schema[\"group\"][\"required\"]\n            assert \"group\" in put_schema\n            assert not put_schema[\"group\"][\"required\"]\n\n            # Event 2: read\n            r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n            assert r.status_code == 200\n            users_list = self.get_content(r)\n            assert isinstance(users_list, dict)\n            assert len(users_list) > 0\n            # email is saved lowercase\n            assert users_list.get(\"email\") == data.get(\"email\", \"MISSING\").lower()\n\n            # Access to the user\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.access.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id1\n            assert events[0].url == f\"/api/admin/users/{event_target_id1}\"\n            assert len(events[0].payload) == 0\n\n            # Check duplicates\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers)\n            assert r.status_code == 409\n            assert (\n                self.get_content(r)\n                == f\"A User already exists with email: {data['email']}\"\n            )\n\n            data[\"email\"] = BaseAuthentication.default_user\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers)\n            assert r.status_code == 409\n            assert (\n                self.get_content(r)\n                == f\"A User already exists with email: {BaseAuthentication.default_user}\"\n            )\n\n            # Create another user\n            data2 = self.buildData(schema)\n            data2[\"email_notification\"] = True\n            data2[\"is_active\"] = True\n            data2[\"expiration\"] = None\n\n            # Event 3: create\n            r = client.post(f\"{API_URI}/admin/users\", json=data2, headers=headers)\n            assert r.status_code == 200\n            uuid2 = self.get_content(r)\n            assert isinstance(uuid2, str)\n\n            # Another User is created\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.create.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id != event_target_id1\n            assert events[0].url == \"/api/admin/users\"\n            assert \"name\" in events[0].payload\n            assert \"surname\" in events[0].payload\n            assert \"email\" in events[0].payload\n\n            # Save it for the following tests\n            event_target_id2 = events[0].target_id\n\n            mail = self.read_mock_email()\n            body = mail.get(\"body\", \"\")\n            # Subject: is a key in the MIMEText\n            assert body is not None\n            assert mail.get(\"headers\") is not None\n            assert f\"Subject: {project_tile}: New credentials\" in mail.get(\n                \"headers\", \"\"\n            )\n            assert data2.get(\"email\", \"MISSING\").lower() in body\n            pwd = data2.get(\"password\", \"MISSING\")\n            assert pwd in body or escape(str(pwd)) in body\n\n            # send and invalid user_id\n            r = client.put(\n                f\"{API_URI}/admin/users/invalid\",\n                json={\"name\": faker.name()},\n                headers=headers,\n            )\n            assert r.status_code == 404\n\n            # Event 4: modify\n            r = client.put(\n                f\"{API_URI}/admin/users/{uuid}\",\n                json={\"name\": faker.name()},\n                headers=headers,\n            )\n            assert r.status_code == 204\n\n            # User 1 modified (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id1\n            assert events[0].url == f\"/api/admin/users/{event_target_id1}\"\n            assert \"name\" in events[0].payload\n            assert \"surname\" not in events[0].payload\n            assert \"email\" not in events[0].payload\n            assert \"password\" not in events[0].payload\n\n            # email cannot be modified\n            new_data = {\"email\": data.get(\"email\")}\n            r = client.put(\n                f\"{API_URI}/admin/users/{uuid2}\", json=new_data, headers=headers\n            )\n            # from webargs >= 6 this endpoint no longer return a 204 but a 400\n            # because email is an unknown field\n            # assert r.status_code == 204\n            assert r.status_code == 400\n\n            # Event 5: read\n            r = client.get(f\"{API_URI}/admin/users/{uuid2}\", headers=headers)\n            assert r.status_code == 200\n            users_list = self.get_content(r)\n            assert isinstance(users_list, dict)\n            assert len(users_list) > 0\n            # email is not modified -> still equal to data2, not data1\n            assert users_list.get(\"email\") != data.get(\"email\", \"MISSING\").lower()\n            assert users_list.get(\"email\") == data2.get(\"email\", \"MISSING\").lower()\n\n            # Access to user 2\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.access.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id2\n            assert events[0].url == f\"/api/admin/users/{event_target_id2}\"\n            assert len(events[0].payload) == 0\n\n            r = client.delete(f\"{API_URI}/admin/users/invalid\", headers=headers)\n            assert r.status_code == 404\n\n            # Event 6: delete\n            r = client.delete(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n            assert r.status_code == 204\n\n            # User 1 is deleted (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.delete.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id1\n            assert events[0].url == f\"/api/admin/users/{event_target_id1}\"\n            assert len(events[0].payload) == 0\n\n            r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n            assert r.status_code == 404\n\n            # change password of user2\n            # Event 7: modify\n            newpwd = faker.password(strong=True)\n            data = {\"password\": newpwd, \"email_notification\": True}\n            r = client.put(f\"{API_URI}/admin/users/{uuid2}\", json=data, headers=headers)\n            assert r.status_code == 204\n\n            # User 2 modified (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id2\n            assert events[0].url == f\"/api/admin/users/{event_target_id2}\"\n            assert \"name\" not in events[0].payload\n            assert \"surname\" not in events[0].payload\n            assert \"email\" not in events[0].payload\n            assert \"password\" in events[0].payload\n            assert \"email_notification\" in events[0].payload\n            # Verify that the password is obfuscated in the log:\n            assert events[0].payload[\"password\"] == OBSCURE_VALUE\n\n            mail = self.read_mock_email()\n            # Subject: is a key in the MIMEText\n            assert mail.get(\"body\", \"\") is not None\n            assert mail.get(\"headers\", \"\") is not None\n            assert f\"Subject: {project_tile}: Password changed\" in mail.get(\n                \"headers\", \"\"\n            )\n            assert data2.get(\"email\", \"MISSING\").lower() in mail.get(\"body\", \"\")\n            assert newpwd in mail.get(\"body\", \"\") or escape(newpwd) in mail.get(\n                \"body\", \"\"\n            )\n\n            # login with a newly created user\n            headers2, _ = self.do_login(client, data2.get(\"email\"), newpwd)\n\n            # normal users cannot access to this endpoint\n            r = client.get(f\"{API_URI}/admin/users\", headers=headers2)\n            assert r.status_code == 401\n\n            r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers2)\n            assert r.status_code == 401\n\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers2)\n            assert r.status_code == 401\n\n            r = client.put(\n                f\"{API_URI}/admin/users/{uuid}\",\n                json={\"name\": faker.name()},\n                headers=headers2,\n            )\n            assert r.status_code == 401\n\n            r = client.delete(f\"{API_URI}/admin/users/{uuid}\", headers=headers2)\n            assert r.status_code == 401\n\n            # Users are not authorized to /admin/tokens\n            # These two tests should be moved in test_endpoints_tokens.py\n            r = client.get(f\"{API_URI}/admin/tokens\", headers=headers2)\n            assert r.status_code == 401\n            r = client.delete(f\"{API_URI}/admin/tokens/xyz\", headers=headers2)\n            assert r.status_code == 401\n\n            # let's delete the second user\n            # Event 8: delete\n            r = client.delete(f\"{API_URI}/admin/users/{uuid2}\", headers=headers)\n            assert r.status_code == 204\n\n            # User 2 is deleted (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.delete.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id2\n            assert events[0].url == f\"/api/admin/users/{event_target_id2}\"\n            assert len(events[0].payload) == 0\n\n            # Restore the default password (changed due to FORCE_FIRST_PASSWORD_CHANGE)\n            # or MAX_PASSWORD_VALIDITY errors\n            r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, dict)\n            uuid = str(content.get(\"uuid\"))\n\n            data = {\n                \"password\": user_password,\n                # very important, otherwise the default user will lose its role\n                \"roles\": orjson.dumps([role]).decode(\"UTF8\"),\n            }\n            # Event 9: modify\n            r = client.put(f\"{API_URI}/admin/users/{uuid}\", json=data, headers=headers)\n            assert r.status_code == 204\n\n            # Default user is modified\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id != event_target_id1\n            assert events[0].target_id != event_target_id2\n            assert events[0].url != f\"/api/admin/users/{event_target_id1}\"\n            assert events[0].url != f\"/api/admin/users/{event_target_id2}\"\n            assert \"name\" not in events[0].payload\n            assert \"surname\" not in events[0].payload\n            assert \"email\" not in events[0].payload\n            assert \"password\" in events[0].payload\n            assert \"roles\" in events[0].payload\n            assert \"email_notification\" not in events[0].payload\n            # Verify that the password is obfuscated in the log:\n            assert events[0].payload[\"password\"] == OBSCURE_VALUE\n\n            r = client.get(f\"{AUTH_URI}/logout\", headers=headers)\n            assert r.status_code == 204\n\n    def test_staff_restrictions(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/users tests\")\n            return\n\n        auth = Connector.get_authentication_instance()\n        staff_role_enabled = Role.STAFF.value in [r.name for r in auth.get_roles()]\n\n        if not staff_role_enabled:  # pragma: no cover\n            log.warning(\n                \"Skipping tests of admin/users restrictions, role Staff not enabled\"\n            )\n            return\n\n        staff_uuid, staff_data = self.create_user(client, roles=[Role.STAFF])\n        staff_email = staff_data.get(\"email\")\n        staff_password = staff_data.get(\"password\")\n        staff_headers, _ = self.do_login(client, staff_email, staff_password)\n\n        user_uuid, _ = self.create_user(client, roles=[Role.USER])\n\n        admin_headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{AUTH_URI}/profile\", headers=admin_headers)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        admin_uuid = content.get(\"uuid\")\n\n        # Staff users are not allowed to retrieve Admins' data\n        r = client.get(f\"{API_URI}/admin/users/{user_uuid}\", headers=admin_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{staff_uuid}\", headers=admin_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{admin_uuid}\", headers=admin_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{user_uuid}\", headers=staff_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{staff_uuid}\", headers=staff_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{admin_uuid}\", headers=staff_headers)\n        assert r.status_code == 404\n        content = self.get_content(r)\n        assert content == \"This user cannot be found or you are not authorized\"\n\n        # Staff users are not allowed to edit Admins\n        r = client.put(\n            f\"{API_URI}/admin/users/{admin_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.STAFF]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 404\n        content = self.get_content(r)\n        assert content == \"This user cannot be found or you are not authorized\"\n\n        r = client.put(\n            f\"{API_URI}/admin/users/{staff_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.STAFF]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 204\n\n        r = client.put(\n            f\"{API_URI}/admin/users/{user_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.USER]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 204\n\n        # Admin role is not allowed for Staff users\n        tmp_schema = self.get_dynamic_input_schema(client, \"admin/users\", admin_headers)\n        post_schema = {s[\"key\"]: s for s in tmp_schema}\n        assert \"roles\" in post_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" in post_schema[\"roles\"][\"options\"]\n\n        tmp_schema = self.get_dynamic_input_schema(\n            client, f\"admin/users/{user_uuid}\", admin_headers, method=\"put\"\n        )\n        put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n        assert \"roles\" in put_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" in post_schema[\"roles\"][\"options\"]\n\n        tmp_schema = self.get_dynamic_input_schema(client, \"admin/users\", staff_headers)\n        post_schema = {s[\"key\"]: s for s in tmp_schema}\n        assert \"roles\" in post_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" not in post_schema[\"roles\"][\"options\"]\n\n        tmp_schema = self.get_dynamic_input_schema(\n            client, f\"admin/users/{user_uuid}\", staff_headers, method=\"put\"\n        )\n        put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n        assert \"roles\" in put_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" not in post_schema[\"roles\"][\"options\"]\n\n        # Staff can't send role admin on put\n        r = client.put(\n            f\"{API_URI}/admin/users/{user_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.ADMIN]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 400\n\n        # Staff can't send role admin on post\n        schema = self.get_dynamic_input_schema(client, \"admin/users\", staff_headers)\n        data = self.buildData(schema)\n\n        data[\"email_notification\"] = True\n        data[\"is_active\"] = True\n        data[\"expiration\"] = None\n        data[\"roles\"] = orjson.dumps([Role.ADMIN]).decode(\"UTF8\")\n\n        r = client.post(f\"{API_URI}/admin/users\", json=data, headers=staff_headers)\n        assert r.status_code == 400\n\n        # Admin users are filtered out when asked from a Staff user\n        r = client.get(f\"{API_URI}/admin/users\", headers=admin_headers)\n        assert r.status_code == 200\n        users_list = self.get_content(r)\n        assert isinstance(users_list, list)\n        assert len(users_list) > 0\n        email_list = [u.get(\"email\") for u in users_list]\n        assert staff_email in email_list\n        assert BaseAuthentication.default_user in email_list\n\n        r = client.get(f\"{API_URI}/admin/users\", headers=staff_headers)\n        assert r.status_code == 200\n        users_list = self.get_content(r)\n        assert isinstance(users_list, list)\n        assert len(users_list) > 0\n        email_list = [u.get(\"email\") for u in users_list]\n        assert staff_email in email_list\n        assert BaseAuthentication.default_user not in email_list\n\n        # Staff users are not allowed to delete Admins\n        r = client.delete(f\"{API_URI}/admin/users/{admin_uuid}\", headers=staff_headers)\n        assert r.status_code == 404\n        content = self.get_content(r)\n        assert content == \"This user cannot be found or you are not authorized\"\n\n        r = client.delete(f\"{API_URI}/admin/users/{user_uuid}\", headers=staff_headers)\n        assert r.status_code == 204\n", "group_users.py": "from faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.services.authentication import Role\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_group_users(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping group/users tests\")\n            return\n\n        # Create group 1 with 1 Coordinator and 1 User\n        group1_uuid, _ = self.create_group(client)\n        _, user1_data = self.create_user(\n            client, roles=[Role.COORDINATOR], data={\"group\": group1_uuid}\n        )\n        _, user2_data = self.create_user(\n            client, roles=[Role.USER], data={\"group\": group1_uuid}\n        )\n\n        # Create group 2 with only 1 Coordinator\n        group2_uuid, _ = self.create_group(client)\n\n        _, user3_data = self.create_user(\n            client, roles=[Role.COORDINATOR], data={\"group\": group2_uuid}\n        )\n\n        # Verify POST / PUT and DELETE are not enabled\n        headers, _ = self.do_login(client, user1_data[\"email\"], user1_data[\"password\"])\n\n        r = client.post(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.put(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.delete(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.put(f\"{API_URI}/group/users/{group1_uuid}\", headers=headers)\n        assert r.status_code == 404\n\n        r = client.delete(f\"{API_URI}/group/users/{group1_uuid}\", headers=headers)\n        assert r.status_code == 404\n\n        # Verify GET response\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n\n        assert response is not None\n        assert len(response) == 2\n        assert \"email\" in response[0]\n        assert \"name\" in response[0]\n        assert \"surname\" in response[0]\n        assert \"roles\" in response[0]\n        assert \"password\" not in response[0]\n        assert \"uuid\" not in response[0]\n        assert \"group\" not in response[0]\n        assert \"belongs_to\" not in response[0]\n        assert \"first_login\" not in response[0]\n        assert \"last_login\" not in response[0]\n        assert \"last_password_change\" not in response[0]\n        assert \"is_active\" not in response[0]\n        assert \"privacy_accepted\" not in response[0]\n        assert \"expiration\" not in response[0]\n\n        email1 = response[0][\"email\"]\n        email2 = response[1][\"email\"]\n\n        assert email1 == user1_data[\"email\"] or email2 == user1_data[\"email\"]\n        assert email1 == user2_data[\"email\"] or email2 == user2_data[\"email\"]\n        assert email1 != user3_data[\"email\"] and email2 != user3_data[\"email\"]\n\n        # Verify GET response with the other group\n\n        headers, _ = self.do_login(client, user3_data[\"email\"], user3_data[\"password\"])\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n\n        assert response is not None\n        assert len(response) == 1\n        assert \"email\" in response[0]\n        assert \"name\" in response[0]\n        assert \"surname\" in response[0]\n        assert \"roles\" in response[0]\n        assert \"password\" not in response[0]\n        assert \"uuid\" not in response[0]\n        assert \"group\" not in response[0]\n        assert \"belongs_to\" not in response[0]\n        assert \"first_login\" not in response[0]\n        assert \"last_login\" not in response[0]\n        assert \"last_password_change\" not in response[0]\n        assert \"is_active\" not in response[0]\n        assert \"privacy_accepted\" not in response[0]\n        assert \"expiration\" not in response[0]\n\n        assert response[0][\"email\"] == user3_data[\"email\"]\n        assert response[0][\"email\"] != user1_data[\"email\"]\n        assert response[0][\"email\"] != user2_data[\"email\"]\n\n        # Add an admin to group1\n        _, user4_data = self.create_user(\n            client, roles=[Role.ADMIN, Role.COORDINATOR], data={\"group\": group1_uuid}\n        )\n\n        # Verify as Admin AND Coordinator (Expected: all members, including admins)\n        headers, _ = self.do_login(client, user4_data[\"email\"], user4_data[\"password\"])\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        members = {r[\"email\"] for r in response}\n        assert len(members) == 3\n\n        assert user1_data[\"email\"] in members\n        assert user2_data[\"email\"] in members\n        assert user3_data[\"email\"] not in members\n        assert user4_data[\"email\"] in members\n\n        # Verify as Coordinator only (Expected: admins to be filtered out)\n        headers, _ = self.do_login(client, user1_data[\"email\"], user1_data[\"password\"])\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        members = {r[\"email\"] for r in response}\n\n        assert len(members) == 2\n\n        assert user1_data[\"email\"] in members\n        assert user2_data[\"email\"] in members\n        assert user3_data[\"email\"] not in members\n        assert user4_data[\"email\"] not in members\n", "login.py": "from datetime import datetime\nfrom typing import Optional\n\nimport pytz\n\nfrom restapi import decorators\nfrom restapi.endpoints.schemas import Credentials\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import AuthMissingTOTP\n\n\nclass Login(EndpointResource):\n    \"\"\"Let a user login by using the configured method\"\"\"\n\n    depends_on = [\"MAIN_LOGIN_ENABLE\", \"AUTH_ENABLE\"]\n    labels = [\"authentication\"]\n\n    @decorators.use_kwargs(Credentials)\n    @decorators.endpoint(\n        path=\"/auth/login\",\n        summary=\"Login by proving your credentials\",\n        description=\"Login with basic credentials (username and password)\",\n        responses={\n            200: \"Credentials are valid\",\n            401: \"Invalid access credentials\",\n            403: \"Access to this account is not allowed\",\n        },\n    )\n    def post(\n        self,\n        username: str,\n        password: str,\n        new_password: Optional[str] = None,\n        password_confirm: Optional[str] = None,\n        totp_code: Optional[str] = None,\n    ) -> Response:\n        username = username.lower()\n        if not self.auth.SECOND_FACTOR_AUTHENTICATION:\n            totp_code = None\n\n        # ##################################################\n        # Authentication control\n\n        try:\n            token, payload, user = self.auth.make_login(username, password, totp_code)\n        except AuthMissingTOTP:\n            user = self.auth.get_user(username=username)\n            message = self.auth.check_password_validity(\n                user,\n                totp_authentication=self.auth.SECOND_FACTOR_AUTHENTICATION,\n            )\n            message[\"actions\"].append(\"TOTP\")\n            message[\"errors\"].append(\"You do not provided a valid verification code\")\n            if message[\"errors\"]:\n                return self.response(message, code=403)\n\n        # ##################################################\n        # If requested, change the password\n        if new_password is not None and password_confirm is not None:\n            pwd_changed = self.auth.change_password(\n                user, password, new_password, password_confirm\n            )\n\n            if pwd_changed:\n                password = new_password\n                token, payload, user = self.auth.make_login(\n                    username, password, totp_code\n                )\n\n        message = self.auth.check_password_validity(\n            user, totp_authentication=self.auth.SECOND_FACTOR_AUTHENTICATION\n        )\n        if message[\"errors\"]:  # pragma: no cover\n            return self.response(message, code=403)\n\n        # Everything is ok, let's save authentication information\n\n        now = datetime.now(pytz.utc)\n        if user.first_login is None:\n            user.first_login = now\n        user.last_login = now\n        self.auth.save_token(user, token, payload)\n\n        self.auth.flush_failed_logins(username)\n\n        return self.response(token)\n", "login_unlock.py": "\"\"\"\nThis endpoint validates an UNLOCK token to re-enable credentials\nafter a block due to too many failed attemps.\nUnlock URL (including token) is sent by email\n\"\"\"\n\nfrom jwt.exceptions import ExpiredSignatureError, ImmatureSignatureError\n\nfrom restapi import decorators\nfrom restapi.exceptions import BadRequest\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.utilities.logs import log\n\n\nclass LoginUnlock(EndpointResource):\n    depends_on = [\"AUTH_MAX_LOGIN_ATTEMPTS\", \"AUTH_ENABLE\"]\n    labels = [\"authentication\"]\n\n    @decorators.endpoint(\n        path=\"/auth/login/unlock/<token>\",\n        summary=\"Unlock credentials after a login block\",\n        description=\"The unlock sent by email is validated here to restore credentials\",\n        responses={\n            200: \"Credentials are now unlocked\",\n            400: \"Invalid token\",\n        },\n    )\n    def post(self, token: str) -> Response:\n        token = token.replace(\"%2B\", \".\")\n        token = token.replace(\"+\", \".\")\n\n        try:\n            # valid, token, jti, user\n            _, _, jti, user = self.auth.verify_token(\n                token, raiseErrors=True, token_type=self.auth.UNLOCK_CREDENTIALS\n            )\n\n        # If token is expired\n        except ExpiredSignatureError as e:\n            raise BadRequest(\n                \"Invalid unlock token: this request is expired\",\n            ) from e\n\n        # if token is not active yet\n        except ImmatureSignatureError as e:\n            raise BadRequest(\"Invalid unlock token\") from e\n\n        # if token does not exist (or other generic errors)\n        except Exception as e:\n            raise BadRequest(\"Invalid unlock token\") from e\n\n        if user is None:  # pragma: no cover\n            raise BadRequest(\"Invalid unlock token\")\n\n        # Recovering token object from jti\n        token_obj = self.auth.get_tokens(token_jti=jti)\n        # Cannot be tested, this is an extra test to prevent any unauthorized access...\n        # but invalid tokens are already refused above, with auth.verify_token\n        if len(token_obj) == 0:  # pragma: no cover\n            raise BadRequest(\"Invalid unlock token: this request is no longer valid\")\n\n        # If credentials are no longer locked, invalidate the token\n        if self.auth.count_failed_login(user.email) < self.auth.MAX_LOGIN_ATTEMPTS:\n            self.auth.invalidate_token(token)\n            raise BadRequest(\"Invalid unlock token: this request is no longer valid\")\n\n        # The unlock token is valid, do something\n        self.auth.flush_failed_logins(user.email)\n        log.info(\n            \"{} provided a valid unlock token and credentials block is now revoked\",\n            user.email,\n        )\n\n        # Bye bye token (unlock tokens are valid only once)\n        self.auth.invalidate_token(token)\n\n        self.log_event(self.events.login_unlock, user=user, target=user)\n\n        return self.response(\"Credentials unlocked\")\n", "logout.py": "import base64\nimport time\n\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.tests import AUTH_URI, BaseAuthentication, BaseTests, FlaskClient\nfrom restapi.utilities.logs import OBSCURE_VALUE, Events, log\n\n\nclass TestApp(BaseTests):\n    def test_01_login(self, client: FlaskClient, faker: Faker) -> None:\n        \"\"\"Check that you can login and receive back your token\"\"\"\n\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping login tests\")\n            return\n\n        log.info(\"*** VERIFY CASE INSENSITIVE LOGIN\")\n        # BaseAuthentication.load_default_user()\n        # BaseAuthentication.load_roles()\n        USER = BaseAuthentication.default_user or \"just-to-prevent-None\"\n        PWD = BaseAuthentication.default_password or \"just-to-prevent-None\"\n\n        # Login by using upper case username\n        self.do_login(client, USER.upper(), PWD)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.login.value\n        assert events[0].user == USER\n        assert events[0].url == \"/auth/login\"\n\n        auth = Connector.get_authentication_instance()\n        logins = auth.get_logins(USER)\n        login = logins[-1]\n        assert login.username == USER\n\n        # Wrong credentials\n        # Off course PWD cannot be upper :D\n        self.do_login(client, USER, PWD.upper(), status_code=401)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.failed_login.value\n        assert events[0].payload[\"username\"] == USER\n        assert events[0].url == \"/auth/login\"\n\n        logins = auth.get_logins(USER)\n        login = logins[-1]\n        assert login.username == USER\n\n        log.info(\"*** VERIFY valid credentials\")\n        # Login by using normal username (no upper case)\n        headers, _ = self.do_login(client, None, None)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.login.value\n        assert events[0].user == USER\n        assert events[0].url == \"/auth/login\"\n\n        time.sleep(5)\n        # Verify MAX_PASSWORD_VALIDITY, if set\n        headers, token = self.do_login(client, None, None)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.login.value\n        assert events[0].user == USER\n        assert events[0].url == \"/auth/login\"\n\n        self.save(\"auth_header\", headers)\n        self.save(\"auth_token\", token)\n\n        # Verify credentials\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, bool) and c\n\n        # this check verifies a BUG with neo4j causing crash of auth module\n        # when using a non-email-username to authenticate\n        log.info(\"*** VERIFY with a non-email-username\")\n\n        self.do_login(\n            client,\n            \"notanemail\",\n            \"[A-Za-z0-9]+\",\n            status_code=400,\n        )\n\n        # Check failure\n        log.info(\"*** VERIFY invalid credentials\")\n\n        random_email = faker.ascii_email()\n        self.do_login(\n            client,\n            random_email,\n            faker.password(strong=True),\n            status_code=401,\n        )\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.failed_login.value\n        assert events[0].payload[\"username\"] == random_email\n        assert events[0].url == \"/auth/login\"\n\n    def test_02_GET_profile(self, client: FlaskClient, faker: Faker) -> None:\n        \"\"\"Check if you can use your token for protected endpoints\"\"\"\n\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping profile tests\")\n            return\n\n        # Check success\n        log.info(\"*** VERIFY valid token\")\n        r = client.get(f\"{AUTH_URI}/profile\", headers=self.get(\"auth_header\"))\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        uuid = content.get(\"uuid\")\n\n        # Check failure\n        log.info(\"*** VERIFY invalid token\")\n        r = client.get(f\"{AUTH_URI}/profile\")\n        assert r.status_code == 401\n\n        # Token created for a fake user\n        token = self.get_crafted_token(\"f\")\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Token created for another user\n        token = self.get_crafted_token(\"x\")\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Token created for another user\n        token = self.get_crafted_token(\"f\", wrong_algorithm=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Token created for another user\n        token = self.get_crafted_token(\"f\", wrong_secret=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # token created for the correct user, but from outside the system!!\n        token = self.get_crafted_token(\"f\", user_id=uuid)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Immature token\n        token = self.get_crafted_token(\"f\", user_id=uuid, immature=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Expired token\n        token = self.get_crafted_token(\"f\", user_id=uuid, expired=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Sending malformed tokens\n        headers = {\"Authorization\": \"Bearer\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n        headers = {\"Authorization\": f\"Bearer '{faker.pystr()}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n        # Bearer realm is expected to be case insensitive\n        token = self.get(\"auth_token\")\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n\n        headers = {\"Authorization\": f\"bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n\n        headers = {\"Authorization\": f\"BEARER {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n\n        token = self.get(\"auth_token\")\n        headers = {\"Authorization\": f\"Bear {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n        USER = BaseAuthentication.default_user\n        PWD = BaseAuthentication.default_password\n        # Testing Basic Authentication (not allowed)\n        credentials = f\"{USER}:{PWD}\"\n        encoded_credentials = base64.b64encode(str.encode(credentials)).decode(\"utf-8\")\n\n        headers = {\"Authorization\": f\"Basic {encoded_credentials}\"}\n\n        r = client.post(f\"{AUTH_URI}/login\", headers=headers)\n        # Response is:\n        # {\n        #     'password': ['Missing data for required field.'],\n        #     'username': ['Missing data for required field.']\n        # }\n        assert r.status_code == 400\n\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n    def test_03_change_profile(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping change profile tests\")\n            return\n\n        headers, _ = self.do_login(client, None, None)\n\n        # update profile, no auth\n        r = client.put(f\"{AUTH_URI}/profile\")\n        assert r.status_code == 401\n        # update profile, no auth\n        r = client.patch(f\"{AUTH_URI}/profile\")\n        assert r.status_code == 401\n\n        # update profile, no data\n        r = client.patch(f\"{AUTH_URI}/profile\", json={}, headers=headers)\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.modify.value\n        assert events[0].user == BaseAuthentication.default_user\n        assert events[0].target_type == \"User\"\n        assert events[0].url == \"/auth/profile\"\n        # It is true in the core, but projects may introduce additional values\n        # and expand the input dictionary even if initially empty\n        # e.g. meteohub adds here the requests_expiration_days parameter\n        # assert len(events[0].payload) == 0\n\n        newname = faker.name()\n        newuuid = faker.pystr()\n\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"name\") is not None\n        assert c.get(\"name\") != newname\n        assert c.get(\"uuid\") is not None\n        assert c.get(\"uuid\") != newuuid\n\n        # update profile\n        data = {\"name\": newname, \"uuid\": newuuid}\n        r = client.patch(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        # uuid cannot be modified and will raise an unknown field\n        assert r.status_code == 400\n        data = {\"name\": newname}\n        r = client.patch(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.modify.value\n        assert events[0].user == BaseAuthentication.default_user\n        assert events[0].target_type == \"User\"\n        assert events[0].url == \"/auth/profile\"\n        # It is true in the core, but projects may introduce additional values\n        # and expand the input dictionary even if initially empty\n        # e.g. meteohub adds here the requests_expiration_days parameter\n        # assert len(events[0].payload) == 1\n        assert \"name\" in events[0].payload\n\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"name\") == newname\n        assert c.get(\"uuid\") != newuuid\n\n        # change password, no data\n        r = client.put(f\"{AUTH_URI}/profile\", json={}, headers=headers)\n        assert r.status_code == 400\n        # Sending a new_password and/or password_confirm without a password\n        newpassword = faker.password()\n        data = {\"new_password\": newpassword}\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n        data = {\"password_confirm\": newpassword}\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n        data = {\"new_password\": newpassword, \"password_confirm\": newpassword}\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data = {}\n        data[\"password\"] = faker.password(length=5)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"new_password\"] = faker.password(length=5)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"password_confirm\"] = faker.password(length=5)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"password\"] = BaseAuthentication.default_password\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        # Passwords are too short\n        data[\"password_confirm\"] = data[\"new_password\"]\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        # Trying to set new password == password... it is not permitted!\n        data[\"password_confirm\"] = data[\"password\"]\n        data[\"new_password\"] = data[\"password\"]\n\n        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n            data[\"totp_code\"] = BaseTests.generate_totp(BaseAuthentication.default_user)\n\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 409\n\n        # Change the password\n        data[\"new_password\"] = faker.password(strong=True)\n        data[\"password_confirm\"] = data[\"new_password\"]\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        # After a change password a spam of delete Token is expected\n        # Reverse the list and skip all delete tokens to find the change password event\n        events = self.get_last_events(100)\n        events.reverse()\n        for event in events:\n            if event.event == Events.delete.value:\n                assert event.target_type == \"Token\"\n                continue\n\n            assert event.event == Events.change_password.value\n            assert event.user == BaseAuthentication.default_user\n            break\n\n        # verify the new password\n        headers, _ = self.do_login(\n            client, BaseAuthentication.default_user, data[\"new_password\"]\n        )\n\n        # restore the previous password\n        data[\"password\"] = data[\"new_password\"]\n        data[\"new_password\"] = BaseAuthentication.default_password\n        data[\"password_confirm\"] = BaseAuthentication.default_password\n        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n            data[\"totp_code\"] = BaseTests.generate_totp(BaseAuthentication.default_user)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        # After a change password a spam of delete Token is expected\n        # Reverse the list and skip all delete tokens to find the change password event\n        events = self.get_last_events(100)\n        events.reverse()\n        for event in events:\n            if event.event == Events.delete.value:\n                assert event.target_type == \"Token\"\n                continue\n\n            assert event.event == Events.change_password.value\n            assert event.user == BaseAuthentication.default_user\n            break\n\n        # verify the new password\n        headers, _ = self.do_login(\n            client, BaseAuthentication.default_user, BaseAuthentication.default_password\n        )\n\n        self.save(\"auth_header\", headers)\n\n    def test_04_logout(self, client: FlaskClient) -> None:\n        \"\"\"Check that you can logout with a valid token\"\"\"\n\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping logout tests\")\n            return\n\n        # Check success\n        log.info(\"*** VERIFY valid token\")\n        r = client.get(f\"{AUTH_URI}/logout\", headers=self.get(\"auth_header\"))\n        assert r.status_code == 204\n\n        events = self.get_last_events(2)\n\n        assert events[0].event == Events.delete.value\n        assert events[0].user == \"-\"\n        assert events[0].target_type == \"Token\"\n        assert events[0].url == \"/auth/logout\"\n\n        assert events[1].event == Events.logout.value\n        assert events[1].user == BaseAuthentication.default_user\n        assert events[1].url == \"/auth/logout\"\n\n        # Check failure\n        log.info(\"*** VERIFY invalid token\")\n        r = client.get(f\"{AUTH_URI}/logout\")\n        assert r.status_code == 401\n\n    def test_05_login_failures(self, client: FlaskClient) -> None:\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\") and Env.get_bool(\"AUTH_ENABLE\"):\n            # Create a new user on the fly to test the cached endpoint\n            _, data = self.create_user(client)\n            headers, _ = self.do_login(\n                client, data[\"email\"], data[\"password\"], test_failures=True\n            )\n            r = client.get(f\"{AUTH_URI}/logout\", headers=headers)\n            assert r.status_code == 204\n\n    def test_06_token_ip_validity(self, client: FlaskClient, faker: Faker) -> None:\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\") and Env.get_bool(\"AUTH_ENABLE\"):\n            if Env.get_int(\"AUTH_TOKEN_IP_GRACE_PERIOD\") < 10:\n                headers, _ = self.do_login(client, None, None)\n\n                r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n                assert r.status_code == 200\n\n                r = client.get(\n                    f\"{AUTH_URI}/status\",\n                    headers=headers,\n                    environ_base={\"REMOTE_ADDR\": faker.ipv4()},\n                )\n                assert r.status_code == 200\n\n                time.sleep(Env.get_int(\"AUTH_TOKEN_IP_GRACE_PERIOD\"))\n\n                r = client.get(\n                    f\"{AUTH_URI}/status\",\n                    headers=headers,\n                    environ_base={\"REMOTE_ADDR\": faker.ipv4()},\n                )\n                assert r.status_code == 401\n\n                # After the failure the token is still valid if used from the correct IP\n                r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n                assert r.status_code == 200\n\n                # Another option to provide IP is through the header passed by nginx\n                # This only works if PROXIED_CONNECTION is on\n                # (disabled by default, for security purpose)\n                if Env.get_bool(\"PROXIED_CONNECTION\"):\n                    headers[\"X-Forwarded-For\"] = faker.ipv4()  # type: ignore\n                    r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n                    assert r.status_code == 401\n\n    if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n\n        def test_07_totp_failures(self, client: FlaskClient, faker: Faker) -> None:\n            uuid, data = self.create_user(client)\n\n            username = data[\"email\"]\n            password = data[\"password\"]\n            new_password = faker.password(strong=True)\n\n            invalid_totp = (\n                str(faker.pyint(min_value=0, max_value=9)),\n                str(faker.pyint(min_value=10, max_value=99)),\n                str(faker.pyint(min_value=100, max_value=999)),\n                str(faker.pyint(min_value=1000, max_value=9999)),\n                str(faker.pyint(min_value=10000, max_value=99999)),\n                str(faker.pyint(min_value=1000000, max_value=9999999)),\n                faker.pystr(6),\n            )\n            ###################################\n            # Test first password change\n            ###################################\n\n            data = {\n                \"username\": username,\n                \"password\": password,\n                \"new_password\": new_password,\n                \"password_confirm\": new_password,\n            }\n\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 403\n            resp = self.get_content(r)\n            assert isinstance(resp, dict)\n\n            assert \"actions\" in resp\n            assert \"errors\" in resp\n            assert \"FIRST LOGIN\" in resp[\"actions\"]\n            assert \"TOTP\" in resp[\"actions\"]\n            assert \"Please change your temporary password\" in resp[\"errors\"]\n            assert \"You do not provided a valid verification code\" in resp[\"errors\"]\n\n            # validate that the QR code is a valid PNG image\n            # ... not implemented\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.password_expired.value\n            assert events[0].user == username\n\n            data[\"totp_code\"] = \"000000\"\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is not valid\"\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].user == username\n            assert \"totp\" in events[0].payload\n            assert events[0].payload[\"totp\"] == OBSCURE_VALUE\n            assert events[0].url == \"/auth/login\"\n\n            for totp in invalid_totp:\n                data[\"totp_code\"] = totp\n                r = client.post(f\"{AUTH_URI}/login\", json=data)\n                assert r.status_code == 400\n                resp = self.get_content(r)\n                assert isinstance(resp, dict)\n                assert \"totp_code\" in resp\n                assert \"Invalid TOTP format\" in resp[\"totp_code\"]\n\n            data[\"totp_code\"] = self.generate_totp(username)\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 200\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.login.value\n            assert events[0].user == username\n            assert events[0].url == \"/auth/login\"\n\n            password = new_password\n\n            ###################################\n            # Test login\n            ###################################\n\n            data = {\n                \"username\": username,\n                \"password\": password,\n            }\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 403\n            resp = self.get_content(r)\n            assert isinstance(resp, dict)\n            assert \"actions\" in resp\n            assert \"errors\" in resp\n            assert \"TOTP\" in resp[\"actions\"]\n            assert \"You do not provided a valid verification code\" in resp[\"errors\"]\n\n            data[\"totp_code\"] = \"000000\"\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is not valid\"\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].user == username\n            assert \"totp\" in events[0].payload\n            assert events[0].payload[\"totp\"] == OBSCURE_VALUE\n            assert events[0].url == \"/auth/login\"\n\n            for totp in invalid_totp:\n                data[\"totp_code\"] = totp\n                r = client.post(f\"{AUTH_URI}/login\", json=data)\n                assert r.status_code == 400\n                resp = self.get_content(r)\n                assert isinstance(resp, dict)\n                assert \"totp_code\" in resp\n                assert \"Invalid TOTP format\" in resp[\"totp_code\"]\n\n            data[\"totp_code\"] = self.generate_totp(username)\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 200\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.login.value\n            assert events[0].user == username\n            assert events[0].url == \"/auth/login\"\n\n            ###################################\n            # Test password change\n            ###################################\n            new_password = faker.password(strong=True)\n            headers, _ = self.do_login(client, username, password)\n\n            data = {\n                \"password\": password,\n                \"new_password\": new_password,\n                \"password_confirm\": new_password,\n            }\n\n            r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is missing\"\n\n            data[\"totp_code\"] = \"000000\"\n            r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is not valid\"\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].user == username\n            assert \"totp\" in events[0].payload\n            assert events[0].payload[\"totp\"] == OBSCURE_VALUE\n            assert events[0].url == \"/auth/profile\"\n\n            for totp in invalid_totp:\n                data[\"totp_code\"] = totp\n                r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n                assert r.status_code == 400\n                resp = self.get_content(r)\n                assert isinstance(resp, dict)\n                assert \"totp_code\" in resp\n                assert \"Invalid TOTP format\" in resp[\"totp_code\"]\n\n            data[\"totp_code\"] = self.generate_totp(username)\n            r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n            assert r.status_code == 204\n\n            # After a change password a spam of delete Token is expected\n            # Reverse the list and skip all delete tokens to find the change pwd event\n            events = self.get_last_events(100)\n            events.reverse()\n            for event in events:\n                if event.event == Events.delete.value:\n                    assert event.target_type == \"Token\"\n                    continue\n\n                assert event.event == Events.change_password.value\n                assert event.user == username\n                break\n\n            # verify the new password\n            headers, _ = self.do_login(client, username, new_password)\n\n            assert headers is not None\n\n            ###################################\n            # Goodbye temporary user\n            ###################################\n\n            self.delete_user(client, uuid)\n", "profile.py": "from typing import Any, Optional\n\nfrom restapi import decorators\nfrom restapi.endpoints.schemas import NewPassword, profile_output, profile_patch_input\nfrom restapi.exceptions import Unauthorized\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import AuthMissingTOTP, User\nfrom restapi.utilities.globals import mem\nfrom restapi.utilities.logs import log\n\n\nclass Profile(EndpointResource):\n    depends_on = [\"MAIN_LOGIN_ENABLE\", \"AUTH_ENABLE\"]\n    labels = [\"profile\"]\n\n    @decorators.auth.require()\n    @decorators.marshal_with(profile_output(), code=200)\n    @decorators.endpoint(\n        path=\"/auth/profile\",\n        summary=\"List profile attributes\",\n        responses={200: \"User profile is returned\"},\n    )\n    def get(self, user: User) -> Response:\n        data = {\n            \"uuid\": user.uuid,\n            \"email\": user.email,\n            \"name\": user.name,\n            \"surname\": user.surname,\n            \"isAdmin\": self.auth.is_admin(user),\n            \"isStaff\": self.auth.is_staff(user),\n            \"isCoordinator\": self.auth.is_coordinator(user),\n            \"privacy_accepted\": user.privacy_accepted,\n            \"last_password_change\": user.last_password_change,\n            \"first_login\": user.first_login,\n            \"last_login\": user.last_login,\n            \"is_active\": user.is_active,\n            \"expiration\": user.expiration,\n            \"belongs_to\": user.belongs_to,\n            # Convert list of Roles into a dict with name: description\n            \"roles\": {role.name: role.description for role in user.roles},\n            \"two_factor_enabled\": self.auth.SECOND_FACTOR_AUTHENTICATION,\n        }\n\n        data = mem.customizer.manipulate_profile(ref=self, user=user, data=data)\n\n        return self.response(data)\n\n    @decorators.auth.require()\n    @decorators.use_kwargs(NewPassword)\n    @decorators.endpoint(\n        path=\"/auth/profile\",\n        summary=\"Update the user password\",\n        responses={204: \"Password updated\"},\n    )\n    def put(\n        self,\n        password: str,\n        new_password: str,\n        password_confirm: str,\n        user: User,\n        totp_code: Optional[str] = None,\n    ) -> Response:\n        try:\n            self.auth.make_login(user.email, password, totp_code)\n        except AuthMissingTOTP as e:\n            raise Unauthorized(\"Verification code is missing\") from e\n\n        self.auth.change_password(user, password, new_password, password_confirm)\n\n        self.auth.save_user(user)\n\n        return self.empty_response()\n\n    @decorators.auth.require()\n    @decorators.use_kwargs(profile_patch_input())\n    @decorators.endpoint(\n        path=\"/auth/profile\",\n        summary=\"Update profile attributes\",\n        responses={204: \"Profile updated\"},\n    )\n    def patch(self, user: User, **kwargs: Any) -> Response:\n        \"\"\"Update profile for current user\"\"\"\n\n        # mypy correctly raises errors because update_properties is not defined\n        # in generic Connector instances, but in this case this is an instance\n        # of an auth db and their implementation always contains this method\n        self.auth.db.update_properties(user, kwargs)  # type: ignore\n\n        log.info(\"Profile updated\")\n\n        self.auth.save_user(user)\n\n        self.log_event(self.events.modify, user, kwargs)\n        return self.empty_response()\n", "profile_activation.py": "from jwt.exceptions import ExpiredSignatureError, ImmatureSignatureError\n\nfrom restapi import decorators\nfrom restapi.config import get_frontend_url\nfrom restapi.connectors import Connector\nfrom restapi.connectors.smtp.notifications import send_activation_link\nfrom restapi.exceptions import BadRequest, ServiceUnavailable\nfrom restapi.models import fields\nfrom restapi.rest.definition import EndpointResource, Response\n\n# from restapi.utilities.logs import log\n\n\nclass ProfileActivation(EndpointResource):\n    depends_on = [\"MAIN_LOGIN_ENABLE\", \"ALLOW_REGISTRATION\", \"AUTH_ENABLE\"]\n    labels = [\"profile\"]\n\n    @decorators.endpoint(\n        path=\"/auth/profile/activate/<token>\",\n        summary=\"Activate your account by providing the activation token\",\n        responses={\n            200: \"Account successfully activated\",\n            400: \"Invalid token\",\n            403: \"Account temporarily blocked due to the number of failed logins\",\n        },\n    )\n    def put(self, token: str) -> Response:\n        token = token.replace(\"%2B\", \".\")\n        token = token.replace(\"+\", \".\")\n\n        try:\n            # valid, token, jti, user\n            _, _, jti, user = self.auth.verify_token(\n                token, raiseErrors=True, token_type=self.auth.ACTIVATE_ACCOUNT\n            )\n\n        # If token is expired\n        except ExpiredSignatureError as e:\n            raise BadRequest(\n                \"Invalid activation token: this request is expired\",\n            ) from e\n\n        # if token is not active yet\n        except ImmatureSignatureError as e:\n            raise BadRequest(\"Invalid activation token\") from e\n\n        # if token does not exist (or other generic errors)\n        except Exception as e:\n            raise BadRequest(\"Invalid activation token\") from e\n\n        if user is None:  # pragma: no cover\n            raise BadRequest(\"Invalid activation token\")\n\n        self.auth.verify_blocked_username(user.email)\n\n        # Recovering token object from jti\n        token_obj = self.auth.get_tokens(token_jti=jti)\n        # Cannot be tested, this is an extra test to prevent any unauthorized access...\n        # but invalid tokens are already refused above, with auth.verify_token\n        if len(token_obj) == 0:  # pragma: no cover\n            raise BadRequest(\n                \"Invalid activation token: this request is no longer valid\"\n            )\n\n        # If user logged is already active, invalidate the token\n        if user.is_active:\n            self.auth.invalidate_token(token)\n            raise BadRequest(\n                \"Invalid activation token: this request is no longer valid\"\n            )\n\n        # The activation token is valid, do something\n        user.is_active = True\n        self.auth.save_user(user)\n\n        # Bye bye token (activation tokens are valid only once)\n        self.auth.invalidate_token(token)\n\n        self.log_event(self.events.activation, user=user, target=user)\n\n        return self.response(\"Account activated\")\n\n    @decorators.use_kwargs({\"username\": fields.Email(required=True)})\n    @decorators.endpoint(\n        path=\"/auth/profile/activate\",\n        summary=\"Ask a new activation link\",\n        responses={\n            200: \"A new activation link has been sent\",\n            403: \"Account temporarily blocked due to the number of failed logins\",\n        },\n    )\n    def post(self, username: str) -> Response:\n        self.auth.verify_blocked_username(username)\n\n        user = self.auth.get_user(username=username)\n\n        # if user is None this endpoint does nothing but the response\n        # remain the same to prevent any user guessing\n        if user is not None:\n            auth = Connector.get_authentication_instance()\n\n            activation_token, payload = auth.create_temporary_token(\n                user, auth.ACTIVATE_ACCOUNT\n            )\n\n            server_url = get_frontend_url()\n\n            rt = activation_token.replace(\".\", \"+\")\n            url = f\"{server_url}/public/register/{rt}\"\n\n            sent = send_activation_link(user, url)\n\n            if not sent:  # pragma: no cover\n                raise ServiceUnavailable(\"Error sending email, please retry\")\n\n            auth.save_token(\n                user, activation_token, payload, token_type=auth.ACTIVATE_ACCOUNT\n            )\n\n        msg = (\n            \"We are sending an email to your email address where \"\n            \"you will find the link to activate your account\"\n        )\n        return self.response(msg)\n", "profile_registration.py": "from typing import Any\n\nfrom restapi import decorators\nfrom restapi.config import get_frontend_url\nfrom restapi.connectors import Connector\nfrom restapi.connectors.smtp.notifications import (\n    send_activation_link,\n    send_registration_notification,\n)\nfrom restapi.endpoints.schemas import user_registration_input\nfrom restapi.env import Env\nfrom restapi.exceptions import Conflict, ServiceUnavailable\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import DEFAULT_GROUP_NAME\nfrom restapi.utilities.logs import log\n\n# This endpoint needs to send the activation token via email\nif Connector.check_availability(\"smtp\"):\n\n    class ProfileRegistration(EndpointResource):\n        depends_on = [\"MAIN_LOGIN_ENABLE\", \"ALLOW_REGISTRATION\", \"AUTH_ENABLE\"]\n        labels = [\"profile\"]\n\n        @decorators.use_kwargs(user_registration_input)\n        @decorators.endpoint(\n            path=\"/auth/profile\",\n            summary=\"Register new user\",\n            responses={\n                200: \"The uuid of the new user is returned\",\n                409: \"This user already exists\",\n            },\n        )\n        def post(\n            self,\n            name: str,\n            surname: str,\n            email: str,\n            password: str,\n            password_confirm: str,\n            **kwargs: Any,\n        ) -> Response:\n            \"\"\"Register new user\"\"\"\n\n            user = self.auth.get_user(username=email)\n            if user is not None:\n                raise Conflict(f\"This user already exists: {email}\")\n\n            if password != password_confirm:\n                raise Conflict(\"Your password doesn't match the confirmation\")\n\n            check, msg = self.auth.verify_password_strength(\n                pwd=password,\n                old_pwd=None,\n                email=email,\n                name=name,\n                surname=surname,\n            )\n\n            if not check:\n                raise Conflict(msg)\n\n            kwargs[\"name\"] = name\n            kwargs[\"surname\"] = surname\n            kwargs[\"email\"] = email\n            kwargs[\"password\"] = password\n            kwargs[\"is_active\"] = False\n            group = self.auth.get_group(name=DEFAULT_GROUP_NAME)\n            user = self.auth.create_user(kwargs, [self.auth.default_role], group)\n            self.auth.save_user(user)\n\n            self.log_event(self.events.create, user, kwargs)\n\n            try:\n                auth = Connector.get_authentication_instance()\n\n                activation_token, payload = auth.create_temporary_token(\n                    user, auth.ACTIVATE_ACCOUNT\n                )\n\n                server_url = get_frontend_url()\n\n                rt = activation_token.replace(\".\", \"+\")\n                log.debug(\"Activation token: {}\", rt)\n                url = f\"{server_url}/public/register/{rt}\"\n\n                sent = send_activation_link(user, url)\n\n                if not sent:  # pragma: no cover\n                    raise ServiceUnavailable(\"Error sending email, please retry\")\n                auth.save_token(\n                    user, activation_token, payload, token_type=auth.ACTIVATE_ACCOUNT\n                )\n\n                # Sending an email to the administrator\n                if Env.get_bool(\"REGISTRATION_NOTIFICATIONS\"):\n                    send_registration_notification(user)\n\n            except Exception as e:  # pragma: no cover\n                self.auth.delete_user(user)\n                raise ServiceUnavailable(\n                    f\"Errors during account registration: {e}\"\n                ) from e\n\n            return self.response(\n                \"We are sending an email to your email address where \"\n                \"you will find the link to activate your account\"\n            )\n", "reset_password.py": "from typing import Optional\n\nimport jwt\n\nfrom restapi import decorators\nfrom restapi.config import get_frontend_url\nfrom restapi.connectors import Connector\nfrom restapi.connectors.smtp.notifications import send_password_reset_link\nfrom restapi.env import Env\nfrom restapi.exceptions import BadRequest, Forbidden, ServiceUnavailable\nfrom restapi.models import fields, validate\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.utilities.logs import log\n\nauth = Connector.get_authentication_instance()\n\n\n# This endpoint require the server to send the reset token via email\nif Connector.check_availability(\"smtp\"):\n\n    class RecoverPassword(EndpointResource):\n        depends_on = [\"MAIN_LOGIN_ENABLE\", \"ALLOW_PASSWORD_RESET\", \"AUTH_ENABLE\"]\n        labels = [\"authentication\"]\n\n        @decorators.use_kwargs({\"reset_email\": fields.Email(required=True)})\n        @decorators.endpoint(\n            path=\"/auth/reset\",\n            summary=\"Request password reset via email\",\n            description=\"Request password reset via email\",\n            responses={\n                200: \"Reset email is valid\",\n                400: \"Invalid reset email\",\n                403: \"Account not found or already active\",\n            },\n        )\n        def post(self, reset_email: str) -> Response:\n            reset_email = reset_email.lower()\n\n            self.auth.verify_blocked_username(reset_email)\n\n            user = self.auth.get_user(username=reset_email)\n\n            if user is None:\n                raise Forbidden(\n                    f\"Sorry, {reset_email} is not recognized as a valid username\",\n                )\n\n            self.auth.verify_user_status(user)\n\n            reset_token, payload = self.auth.create_temporary_token(\n                user, self.auth.PWD_RESET\n            )\n\n            server_url = get_frontend_url()\n\n            rt = reset_token.replace(\".\", \"+\")\n\n            uri = Env.get(\"RESET_PASSWORD_URI\", \"/public/reset\")\n            complete_uri = f\"{server_url}{uri}/{rt}\"\n\n            sent = send_password_reset_link(user, complete_uri, reset_email)\n\n            if not sent:  # pragma: no cover\n                raise ServiceUnavailable(\"Error sending email, please retry\")\n\n            ##################\n            # Completing the reset task\n            self.auth.save_token(\n                user, reset_token, payload, token_type=self.auth.PWD_RESET\n            )\n\n            msg = \"We'll send instructions to the email provided if it's associated \"\n            msg += \"with an account. Please check your spam/junk folder.\"\n\n            self.log_event(self.events.reset_password_request, user=user)\n            return self.response(msg)\n\n        @decorators.use_kwargs(\n            {\n                \"new_password\": fields.Str(\n                    required=False,\n                    validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n                    metadata={\"password\": True},\n                ),\n                \"password_confirm\": fields.Str(\n                    required=False,\n                    validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n                    metadata={\"password\": True},\n                ),\n            }\n        )\n        @decorators.endpoint(\n            path=\"/auth/reset/<token>\",\n            summary=\"Change password as conseguence of a reset request\",\n            description=\"Change password as conseguence of a reset request\",\n            responses={\n                200: \"Reset token is valid, password changed\",\n                400: \"Invalid reset token\",\n            },\n        )\n        def put(\n            self,\n            token: str,\n            new_password: Optional[str] = None,\n            password_confirm: Optional[str] = None,\n        ) -> Response:\n            token = token.replace(\"%2B\", \".\")\n            token = token.replace(\"+\", \".\")\n\n            try:\n                # valid, token, jti, user\n                _, _, jti, user = self.auth.verify_token(\n                    token, raiseErrors=True, token_type=self.auth.PWD_RESET\n                )\n\n            # If token is expired\n            except jwt.exceptions.ExpiredSignatureError as e:\n                raise BadRequest(\"Invalid reset token: this request is expired\") from e\n\n            # if token is not active yet\n            except jwt.exceptions.ImmatureSignatureError as e:\n                log.info(e)\n                raise BadRequest(\"Invalid reset token\") from e\n            # if token does not exist (or other generic errors)\n            except Exception as e:\n                log.info(e)\n                raise BadRequest(\"Invalid reset token\") from e\n\n            if user is None:  # pragma: no cover\n                raise BadRequest(\"Invalid activation token\")\n\n            # Recovering token object from jti\n            tokens_obj = self.auth.get_tokens(token_jti=jti)\n            # Can't happen because the token is refused from verify_token function\n            if len(tokens_obj) == 0:  # pragma: no cover\n                raise BadRequest(\"Invalid reset token: this request is no longer valid\")\n\n            token_obj = tokens_obj.pop(0)\n            emitted = token_obj[\"emitted\"]\n\n            last_change = None\n            # If user logged in after the token emission invalidate the token\n            if user.last_login is not None:\n                last_change = user.last_login\n            # If user changed the pwd after the token emission invalidate the token\n            # Can't happen because the change password also invalidated the token\n            elif user.last_password_change is not None:  # pragma: no cover\n                last_change = user.last_password_change\n\n            if last_change is not None:\n                # Can't happen because the change password also invalidated the token\n                if last_change > emitted:  # pragma: no cover\n                    self.auth.invalidate_token(token)\n                    raise BadRequest(\n                        \"Invalid reset token: this request is no longer valid\",\n                    )\n\n            # The reset token is valid, do something\n\n            # No password to be changed, just a token verification\n            if new_password is None and password_confirm is None:\n                return self.empty_response()\n\n            # Something is missing\n            if new_password is None or password_confirm is None:\n                raise BadRequest(\"Invalid password\")\n\n            if new_password != password_confirm:\n                raise BadRequest(\"New password does not match with confirmation\")\n\n            self.auth.change_password(\n                user, user.password, new_password, password_confirm\n            )\n            # I really don't know why this save is required... since it is already\n            # in change_password ... But if I remove it the new pwd is not saved...\n            self.auth.save_user(user)\n\n            # Bye bye token (reset tokens are valid only once)\n            self.auth.invalidate_token(token)\n\n            return self.response(\"Password changed\")\n", "schemas.py": "from datetime import datetime\nfrom typing import TypedDict, Union\n\nfrom restapi.connectors import Connector\nfrom restapi.customizer import FlaskRequest\nfrom restapi.models import ISO8601UTC, Schema, fields, validate\nfrom restapi.rest.bearer import HTTPTokenAuth\nfrom restapi.services.authentication import Role as RoleEnum\nfrom restapi.utilities.globals import mem\n\nauth = Connector.get_authentication_instance()\n\n# as defined in Marshmallow.schema.from_dict\nMarshmallowSchema = dict[str, Union[fields.Field, type]]\n\n#########################################\n# #############   Schemas   #############\n#########################################\n\n\nclass User(Schema):\n    email = fields.Email()\n    name = fields.Str()\n    surname = fields.Str()\n\n\nclass UserWithUUID(Schema):\n    uuid = fields.UUID()\n    email = fields.Email()\n    name = fields.String()\n    surname = fields.String()\n\n\nclass Role(Schema):\n    name = fields.Str()\n    description = fields.Str()\n\n\nclass Group(Schema):\n    uuid = fields.UUID()\n    fullname = fields.Str()\n    shortname = fields.Str()\n\n\n# Output Schema\nclass GroupWithMembers(Schema):\n    uuid = fields.UUID()\n    fullname = fields.Str()\n    shortname = fields.Str()\n\n    members = fields.Nested(UserWithUUID(many=True))\n    coordinators = fields.Nested(UserWithUUID(many=True))\n\n\nclass TokenSchema(Schema):\n    id = fields.Str()\n    IP = fields.Str()\n    location = fields.Str()\n    token = fields.Str()\n    emitted = fields.DateTime(format=ISO8601UTC)\n    expiration = fields.DateTime(format=ISO8601UTC)\n    last_access = fields.DateTime(format=ISO8601UTC)\n\n\nclass TokenAdminSchema(TokenSchema):\n    # token_type = fields.Str()\n    user = fields.Nested(User)\n\n\nclass TotalSchema(Schema):\n    total = fields.Int()\n\n\nclass Credentials(Schema):\n    username = fields.Email(required=True, validate=validate.Length(max=100))\n    password = fields.Str(\n        required=True,\n        metadata={\"password\": True},\n        # Otherwise default testing password, like test, will fail\n        # validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH)\n    )\n    new_password = fields.Str(\n        required=False,\n        validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n        metadata={\"password\": True},\n    )\n    password_confirm = fields.Str(\n        required=False,\n        validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n        metadata={\"password\": True},\n    )\n    totp_code = fields.TOTP(required=False)\n\n\nclass NewPassword(Schema):\n    password = fields.Str(\n        required=True,\n        metadata={\"password\": True},\n        # Not needed to check the length of the current password... if set...\n        # validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n    )\n    new_password = fields.Str(\n        required=True,\n        validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n        metadata={\"password\": True},\n    )\n    password_confirm = fields.Str(\n        required=True,\n        validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n        metadata={\"password\": True},\n    )\n    totp_code = fields.TOTP(required=False)\n\n\nclass MailInput(Schema):\n    subject = fields.Str(\n        required=True, metadata={\"description\": \"Subject of your email\"}\n    )\n    body = fields.Str(\n        required=True,\n        validate=validate.Length(max=9999),\n        metadata={\"description\": \"Body of your email. You can use html code here.\"},\n    )\n    to = fields.Email(required=True, metadata={\"label\": \"Destination email address\"})\n    cc = fields.DelimitedList(\n        fields.Email(),\n        metadata={\n            \"label\": \"CC - Carbon Copy\",\n            \"description\": \"CC email addresses (comma-delimited list)\",\n        },\n    )\n    bcc = fields.DelimitedList(\n        fields.Email(),\n        metadata={\n            \"label\": \"BCC - Blind Carbon Copy\",\n            \"description\": \"BCC email addresses (comma-delimited list)\",\n        },\n    )\n    dry_run = fields.Boolean(\n        required=True,\n        metadata={\n            \"label\": \"Dry run execution\",\n            \"description\": \"Only simulate the email, do not send it\",\n        },\n    )\n\n\nclass MailOutput(Schema):\n    html_body = fields.Str()\n    plain_body = fields.Str()\n    subject = fields.Str()\n    to = fields.Email()\n    cc = fields.List(fields.Email())\n    bcc = fields.List(fields.Email())\n\n\nclass LoginsSchema(Schema):\n    username = fields.Email()\n    date = fields.DateTime(format=ISO8601UTC)\n    IP = fields.Str()\n    location = fields.Str()\n    failed = fields.Boolean()\n    flushed = fields.Boolean()\n\n\n#########################################\n# ############   Callbacks   ############\n#########################################\n\n# Note that these are callables returning a model, not models!\n# They will be executed a runtime\n\n\ndef admin_user_output(many: bool = True) -> Schema:\n    attributes: MarshmallowSchema = {}\n\n    attributes[\"uuid\"] = fields.UUID()\n    attributes[\"email\"] = fields.Email()\n    attributes[\"name\"] = fields.Str()\n    attributes[\"surname\"] = fields.Str()\n    attributes[\"first_login\"] = fields.DateTime(allow_none=True, format=ISO8601UTC)\n    attributes[\"last_login\"] = fields.DateTime(allow_none=True, format=ISO8601UTC)\n    attributes[\"last_password_change\"] = fields.DateTime(\n        allow_none=True, format=ISO8601UTC\n    )\n    attributes[\"is_active\"] = fields.Boolean()\n    attributes[\"privacy_accepted\"] = fields.Boolean()\n    attributes[\"roles\"] = fields.List(fields.Nested(Role))\n    attributes[\"expiration\"] = fields.DateTime(allow_none=True, format=ISO8601UTC)\n\n    if Connector.authentication_service == \"neo4j\":\n        attributes[\"belongs_to\"] = fields.Neo4jRelationshipToSingle(\n            Group, data_key=\"group\"\n        )\n    else:\n        attributes[\"belongs_to\"] = fields.Nested(Group, data_key=\"group\")\n\n    if custom_fields := mem.customizer.get_custom_output_fields(None):\n        attributes.update(custom_fields)\n\n    schema = Schema.from_dict(attributes, name=\"AdminUserData\")\n    return schema(many=many)  # type: ignore\n\n\ndef group_users_output() -> Schema:\n    attributes: MarshmallowSchema = {}\n\n    attributes[\"email\"] = fields.Email()\n    attributes[\"name\"] = fields.Str()\n    attributes[\"surname\"] = fields.Str()\n    attributes[\"roles\"] = fields.List(fields.Nested(Role))\n\n    if custom_fields := mem.customizer.get_custom_output_fields(None):\n        attributes.update(custom_fields)\n\n    schema = Schema.from_dict(attributes, name=\"UserData\")\n    return schema(many=True)  # type: ignore\n\n\n# Can't use request.method because it is not passed at loading time, i.e. the Specs will\n# be created with empty request\ndef admin_user_input(request: FlaskRequest, is_post: bool) -> type[Schema]:\n    is_admin = HTTPTokenAuth.is_session_user_admin(request, auth)\n\n    attributes: MarshmallowSchema = {}\n    if is_post:\n        attributes[\"email\"] = fields.Email(\n            required=is_post, validate=validate.Length(max=100)\n        )\n\n    attributes[\"name\"] = fields.Str(\n        required=is_post,\n        validate=validate.Length(min=1),\n        metadata={\"label\": \"First Name\"},\n    )\n    attributes[\"surname\"] = fields.Str(\n        required=is_post,\n        validate=validate.Length(min=1),\n        metadata={\"label\": \"Last Name\"},\n    )\n\n    attributes[\"password\"] = fields.Str(\n        required=is_post,\n        validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n        metadata={\"password\": True},\n    )\n\n    if Connector.check_availability(\"smtp\"):\n        attributes[\"email_notification\"] = fields.Bool(\n            metadata={\"label\": \"Notify password by email\"}\n        )\n\n    attributes[\"is_active\"] = fields.Bool(\n        dump_default=True,\n        required=False,\n        metadata={\"label\": \"Activate user\"},\n    )\n\n    roles = {r.name: r.description for r in auth.get_roles()}\n    if not is_admin and RoleEnum.ADMIN.value in roles:\n        roles.pop(RoleEnum.ADMIN.value)\n\n    attributes[\"roles\"] = fields.List(\n        fields.Str(\n            validate=validate.OneOf(\n                choices=[r for r in roles.keys()],\n                labels=[r for r in roles.values()],\n            )\n        ),\n        dump_default=[auth.default_role],\n        required=False,\n        unique=True,\n        metadata={\n            \"label\": \"Roles\",\n            \"description\": \"\",\n            \"extra_descriptions\": auth.role_descriptions,\n        },\n    )\n\n    group_keys = []\n    group_labels = []\n\n    for g in auth.get_groups():\n        group_keys.append(g.uuid)\n        group_labels.append(f\"{g.shortname} - {g.fullname}\")\n\n    if len(group_keys) == 1:\n        default_group = group_keys[0]\n    else:\n        default_group = None\n\n    attributes[\"group\"] = fields.Str(\n        required=is_post,\n        dump_default=default_group,\n        validate=validate.OneOf(choices=group_keys, labels=group_labels),\n        metadata={\n            \"label\": \"Group\",\n            \"description\": \"The group to which the user belongs\",\n        },\n    )\n\n    attributes[\"expiration\"] = fields.DateTime(\n        required=False,\n        allow_none=True,\n        metadata={\n            \"label\": \"Account expiration\",\n            \"description\": \"This user will be blocked after this date\",\n        },\n    )\n\n    if custom_fields := mem.customizer.get_custom_input_fields(\n        request=request, scope=mem.customizer.ADMIN\n    ):\n        attributes.update(custom_fields)\n\n    return Schema.from_dict(attributes, name=\"UserDefinition\")\n\n\ndef admin_user_post_input(request: FlaskRequest) -> type[Schema]:\n    return admin_user_input(request, True)\n\n\ndef admin_user_put_input(request: FlaskRequest) -> type[Schema]:\n    return admin_user_input(request, False)\n\n\n# Should to transformed again in a Schema\ndef admin_group_input(request: FlaskRequest) -> type[Schema]:\n    attributes: MarshmallowSchema = {}\n\n    attributes[\"shortname\"] = fields.Str(\n        required=True, metadata={\"description\": \"Short name\"}\n    )\n    attributes[\"fullname\"] = fields.Str(\n        required=True, metadata={\"description\": \"Full name\"}\n    )\n\n    return Schema.from_dict(attributes, name=\"GroupDefinition\")\n\n\ndef profile_patch_input() -> Schema:\n    attributes: MarshmallowSchema = {}\n\n    attributes[\"name\"] = fields.Str(metadata={\"label\": \"First Name\"})\n    attributes[\"surname\"] = fields.Str(metadata={\"label\": \"Last Name\"})\n    attributes[\"privacy_accepted\"] = fields.Boolean()\n\n    if custom_fields := mem.customizer.get_custom_input_fields(\n        request=None, scope=mem.customizer.PROFILE\n    ):\n        attributes.update(custom_fields)\n\n    schema = Schema.from_dict(attributes, name=\"UserProfileEdit\")\n    return schema()  # type: ignore\n\n\ndef profile_output() -> Schema:\n    attributes: MarshmallowSchema = {}\n\n    attributes[\"uuid\"] = fields.UUID(required=True)\n    attributes[\"email\"] = fields.Email(required=True)\n    attributes[\"name\"] = fields.Str(required=True)\n    attributes[\"surname\"] = fields.Str(required=True)\n    attributes[\"isAdmin\"] = fields.Boolean(required=True)\n    attributes[\"isStaff\"] = fields.Boolean(required=True)\n    attributes[\"isCoordinator\"] = fields.Boolean(required=True)\n    attributes[\"privacy_accepted\"] = fields.Boolean(required=True)\n    attributes[\"is_active\"] = fields.Boolean(required=True)\n    attributes[\"expiration\"] = fields.DateTime(allow_none=True, format=ISO8601UTC)\n    attributes[\"roles\"] = fields.Dict(required=True)\n    attributes[\"last_password_change\"] = fields.DateTime(\n        required=True, format=ISO8601UTC\n    )\n    attributes[\"first_login\"] = fields.DateTime(required=True, format=ISO8601UTC)\n    attributes[\"last_login\"] = fields.DateTime(required=True, format=ISO8601UTC)\n\n    if Connector.authentication_service == \"neo4j\":\n        attributes[\"belongs_to\"] = fields.Neo4jRelationshipToSingle(\n            Group, data_key=\"group\"\n        )\n    else:\n        attributes[\"belongs_to\"] = fields.Nested(Group, data_key=\"group\")\n\n    attributes[\"two_factor_enabled\"] = fields.Boolean(required=True)\n\n    if custom_fields := mem.customizer.get_custom_output_fields(None):\n        attributes.update(custom_fields)\n\n    schema = Schema.from_dict(attributes, name=\"UserProfile\")\n    return schema()  # type: ignore\n\n\ndef user_registration_input(request: FlaskRequest) -> type[Schema]:\n    attributes: MarshmallowSchema = {}\n\n    attributes[\"name\"] = fields.Str(required=True)\n    attributes[\"surname\"] = fields.Str(required=True)\n    attributes[\"email\"] = fields.Email(\n        required=True,\n        metadata={\"label\": \"Username (email address)\"},\n        validate=validate.Length(max=100),\n    )\n    attributes[\"password\"] = fields.Str(\n        required=True,\n        validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n        metadata={\"password\": True},\n    )\n    attributes[\"password_confirm\"] = fields.Str(\n        required=True,\n        validate=validate.Length(min=auth.MIN_PASSWORD_LENGTH),\n        metadata={\"label\": \"Password confirmation\", \"password\": True},\n    )\n\n    if custom_fields := mem.customizer.get_custom_input_fields(\n        request=None, scope=mem.customizer.REGISTRATION\n    ):\n        attributes.update(custom_fields)\n\n    return Schema.from_dict(attributes, name=\"UserRegistration\")\n\n\n#########################################\n# ##########   Stats Schemas   ##########\n#########################################\n\n\nclass SystemSchema(Schema):\n    boot_time = fields.DateTime(format=ISO8601UTC)\n\n\nclass CPUSchema(Schema):\n    count = fields.Int()\n    load_percentage = fields.Decimal(places=2)\n    user = fields.Int()\n    system = fields.Int()\n    idle = fields.Int()\n    wait = fields.Int()\n    stolen = fields.Int()\n\n\nclass RAMSchema(Schema):\n    total = fields.Int()\n    used = fields.Int()\n    active = fields.Int()\n    inactive = fields.Int()\n    buffer = fields.Int()\n    free = fields.Int()\n    cache = fields.Int()\n\n\nclass SwapSchema(Schema):\n    from_disk = fields.Int()\n    to_disk = fields.Int()\n    total = fields.Int()\n    used = fields.Int()\n    free = fields.Int()\n\n\nclass DiskSchema(Schema):\n    total_disk_space = fields.Decimal(places=2)\n    used_disk_space = fields.Decimal(places=2)\n    free_disk_space = fields.Decimal(places=2)\n    occupacy = fields.Decimal(places=2)\n\n\nclass ProcSchema(Schema):\n    waiting_for_run = fields.Int()\n    uninterruptible_sleep = fields.Int()\n\n\nclass IOSchema(Schema):\n    blocks_received = fields.Int()\n    blocks_sent = fields.Int()\n\n\nclass NetworkSchema(Schema):\n    min = fields.Decimal(places=2)\n    max = fields.Decimal(places=2)\n    avg = fields.Decimal(places=2)\n\n\nclass StatsSchema(Schema):\n    system = fields.Nested(SystemSchema)\n    cpu = fields.Nested(CPUSchema)\n    ram = fields.Nested(RAMSchema)\n    swap = fields.Nested(SwapSchema)\n    disk = fields.Nested(DiskSchema)\n    procs = fields.Nested(ProcSchema)\n    io = fields.Nested(IOSchema)\n    network_latency = fields.Nested(NetworkSchema)\n\n\nclass SystemType(TypedDict):\n    boot_time: datetime\n\n\nclass CPUType(TypedDict):\n    count: int\n    load_percentage: float\n    user: int\n    system: int\n    idle: int\n    wait: int\n    stolen: int\n\n\nclass RAMType(TypedDict):\n    total: int\n    used: int\n    active: int\n    inactive: int\n    buffer: int\n    free: int\n    cache: int\n\n\nclass SwapType(TypedDict):\n    from_disk: int\n    to_disk: int\n    total: int\n    used: int\n    free: int\n\n\nclass DiskType(TypedDict):\n    total_disk_space: float\n    used_disk_space: float\n    free_disk_space: float\n    occupacy: float\n\n\nclass ProcType(TypedDict):\n    waiting_for_run: int\n    uninterruptible_sleep: int\n\n\nclass IOType(TypedDict):\n    blocks_received: int\n    blocks_sent: int\n\n\nclass NetworkType(TypedDict):\n    min: float\n    max: float\n    avg: float\n\n\nclass StatsType(TypedDict):\n    system: SystemType\n    cpu: CPUType\n    ram: RAMType\n    swap: SwapType\n    disk: DiskType\n    procs: ProcType\n    io: IOType\n    network_latency: NetworkType\n", "send_mail.py": "from typing import Any\n\nimport pytest\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\n\n\n@pytest.mark.skipif(\n    not Connector.check_availability(\"smtp\") or not Env.get_bool(\"AUTH_ENABLE\"),\n    reason=\"This test needs smtp and auth to be available\",\n)\nclass TestApp(BaseTests):\n    def test_sendmail(self, client: FlaskClient, faker: Faker) -> None:\n        headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.put(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.patch(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.delete(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        data: dict[str, Any] = {\"dry_run\": False}\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"subject\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"body\"] = faker.text()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"to\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"to\"] = faker.ascii_email()\n        data[\"body\"] = \"TEST EMAIL BODY\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        mail = self.read_mock_email()\n        body = mail.get(\"body\", \"\")\n        assert \"TEST EMAIL BODY\" in body\n\n        data[\"dry_run\"] = True\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 200\n\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"html_body\" in response\n        assert \"plain_body\" in response\n        assert \"subject\" in response\n        assert \"to\" in response\n        assert \"cc\" in response\n        assert \"bcc\" in response\n\n        data[\"dry_run\"] = False\n\n        data[\"body\"] = \"TEST EMAIL <b>HTML</b> BODY\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n        mail = self.read_mock_email()\n        body = mail.get(\"body\", \"\")\n        assert \"TEST EMAIL <b>HTML</b> BODY\" in body\n\n        data[\"dry_run\"] = True\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 200\n\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"html_body\" in response\n        assert \"plain_body\" in response\n        assert \"subject\" in response\n        assert \"to\" in response\n        assert \"cc\" in response\n        assert \"bcc\" in response\n\n        data[\"dry_run\"] = False\n\n        data[\"body\"] = faker.text()\n        data[\"cc\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"cc\"] = faker.ascii_email()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        data[\"cc\"] = f\"{faker.ascii_email()},{faker.pystr()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"cc\"] = f\"{faker.ascii_email()},{faker.ascii_email()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        data[\"bcc\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"bcc\"] = f\"{faker.ascii_email()},{faker.pystr()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"bcc\"] = f\"{faker.ascii_email()},{faker.ascii_email()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        mail = self.read_mock_email()\n\n        body = mail.get(\"body\", \"\")\n        email_headers = mail.get(\"headers\", \"\")\n        assert body is not None\n        assert email_headers is not None\n        # Subject: is a key in the MIMEText\n        assert f\"Subject: {data['subject']}\" in email_headers\n        ccs = mail.get(\"cc\", [])\n        assert ccs[0] == data[\"to\"]\n        assert ccs[1] == data[\"cc\"].split(\",\")[0]\n        assert ccs[2] == data[\"cc\"].split(\",\")[1]\n        assert ccs[3] == data[\"bcc\"].split(\",\")[0]\n        assert ccs[4] == data[\"bcc\"].split(\",\")[1]\n", "status.py": "from restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_GET_status(self, client: FlaskClient) -> None:\n        \"\"\"Test that the flask server is running and reachable\"\"\"\n\n        # Check success\n        alive_message = \"Server is alive\"\n\n        log.info(\"*** VERIFY if API is online\")\n        r = client.get(f\"{API_URI}/status\")\n        assert r.status_code == 200\n        output = self.get_content(r)\n        assert output == alive_message\n\n        # Check failure\n        log.info(\"*** VERIFY if invalid endpoint gives Not Found\")\n        r = client.get(API_URI)\n        assert r.status_code == 404\n\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            # Check /auth/status with no token or invalid token\n            r = client.get(f\"{AUTH_URI}/status\")\n            assert r.status_code == 401\n\n            r = client.get(\n                f\"{AUTH_URI}/status\", headers={\"Authorization\": \"Bearer ABC\"}\n            )\n            assert r.status_code == 401\n        else:\n            r = client.get(f\"{AUTH_URI}/status\")\n            assert r.status_code == 404\n", "swagger_specs.py": "from typing import Any, Optional\n\nfrom glom import glom\n\nfrom restapi import decorators\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import User\nfrom restapi.utilities.globals import mem\nfrom restapi.utilities.logs import log\n\n\ndef add_model(definitions: dict[str, bool], def_name: str, is_private: bool) -> None:\n    def_name = def_name.replace(\"#/definitions/\", \"\")\n\n    definitions.setdefault(def_name, True)\n    # Will be True if all occurrences are private\n    definitions[def_name] = definitions[def_name] and is_private\n\n\nclass NewSwaggerSpecifications(EndpointResource):\n    \"\"\"\n    Specifications output throught Swagger (open API) standards\n    \"\"\"\n\n    labels = [\"specifications\"]\n\n    @decorators.auth.optional(allow_access_token_parameter=True)\n    @decorators.endpoint(\n        path=\"/specs\",\n        summary=\"Endpoints specifications based on OpenAPI 2.0 format\",\n        responses={200: \"Endpoints JSON based on OpenAPI Specifications\"},\n    )\n    def get(self, user: Optional[User]) -> Response:\n        specs = mem.docs.spec.to_dict()\n        if user:\n            # Set security requirements for endpoint\n            for key, data in specs.items():\n                if key == \"paths\":\n                    for uri, endpoint in data.items():\n                        u = uri.replace(\"{\", \"<\").replace(\"}\", \">\")\n                        for method, definition in endpoint.items():\n                            auth_required = glom(\n                                mem.authenticated_endpoints,\n                                f\"{u}.{method}\",\n                                default=False,\n                            )\n\n                            if auth_required:\n                                definition[\"security\"] = [{\"Bearer\": []}]\n\n            return self.response(specs)\n\n        log.debug(\"Unauthenticated request, filtering out private endpoints\")\n        # Remove sensible data\n        filtered_specs: dict[str, dict[str, dict[str, Any]]] = {}\n        # schemaName => True|False (private|public)\n        privatedefs: dict[str, bool] = {}\n        # schemaName => [list of definitions including this]\n        parentdefs: dict[str, list[Any]] = {}\n        for key, data in specs.items():\n            # Find endpoint mapping flagged as private\n            if key == \"paths\":\n                for uri, endpoint in data.items():\n                    u = uri.replace(\"{\", \"<\").replace(\"}\", \">\")\n                    for method, definition in endpoint.items():\n                        is_private = glom(\n                            mem.private_endpoints,\n                            f\"{u}.{method}\",\n                            default=False,\n                        )\n\n                        defs = definition.get(\"parameters\", [])[:]\n                        for p in defs:\n                            if \"schema\" not in p:\n                                continue\n                            if \"$ref\" in p[\"schema\"]:\n                                ref = p[\"schema\"][\"$ref\"]\n                                add_model(privatedefs, ref, is_private)\n                            elif (\n                                \"items\" in p[\"schema\"]\n                                and \"$ref\" in p[\"schema\"][\"items\"]\n                            ):  # pragma: no cover\n                                ref = p[\"schema\"][\"items\"][\"$ref\"]\n                                add_model(privatedefs, ref, is_private)\n\n                        for _, response in definition.get(\"responses\", {}).items():\n                            if \"schema\" in response:\n                                if \"$ref\" in response[\"schema\"]:\n                                    ref = response[\"schema\"][\"$ref\"]\n                                    add_model(privatedefs, ref, is_private)\n                                elif (\n                                    \"items\" in response[\"schema\"]\n                                    and \"$ref\" in response[\"schema\"][\"items\"]\n                                ):\n                                    ref = response[\"schema\"][\"items\"][\"$ref\"]\n                                    add_model(privatedefs, ref, is_private)\n\n                        if is_private:\n                            log.debug(\"Skipping {} {}\", method, uri)\n                            continue\n\n                        auth_required = glom(\n                            mem.authenticated_endpoints,\n                            f\"{u}.{method}\",\n                            default=False,\n                        )\n\n                        if auth_required:\n                            definition[\"security\"] = [{\"Bearer\": []}]\n\n                        filtered_specs.setdefault(key, {})\n                        filtered_specs[key].setdefault(uri, {})\n                        filtered_specs[key][uri].setdefault(method, definition)\n\n                        # definitions\n            elif key == \"definitions\":\n                # Saving definition inclusion, will be used later to determine\n                # if a definition is private or not\n                # If a definition is referenced by an endpoint, the definition\n                # visibility matches the endpoint visibility\n                # If a definition is referenced by other definitions, its visibility\n                # will be calculated as AND(parent definitions)\n                # Verification postponed\n                for schema, definition in data.items():\n                    # parentdefs\n                    for d in definition.get(\"properties\", {}).values():\n                        # Generated by Nested without allow_none\n                        if \"$ref\" in d:\n                            ref = d[\"$ref\"]\n                            def_name = ref.replace(\"#/definitions/\", \"\")\n\n                            parentdefs.setdefault(def_name, [])\n                            parentdefs[def_name].append(schema)\n\n                        elif \"items\" in d and \"$ref\" in d[\"items\"]:\n                            ref = d[\"items\"][\"$ref\"]\n                            def_name = ref.replace(\"#/definitions/\", \"\")\n\n                            parentdefs.setdefault(def_name, [])\n                            parentdefs[def_name].append(schema)\n                        # Generated by Nested with allow_none=True\n                        if \"allOf\" in d:\n                            for nested in d[\"allOf\"]:\n                                ref = nested[\"$ref\"]\n                                def_name = ref.replace(\"#/definitions/\", \"\")\n\n                                parentdefs.setdefault(def_name, [])\n                                parentdefs[def_name].append(schema)\n            else:\n                filtered_specs.setdefault(key, data)\n\n        if \"definitions\" in specs:\n            filtered_specs.setdefault(\"definitions\", {})\n            for schema, definition in specs[\"definitions\"].items():\n                if self.is_definition_private(schema, privatedefs, parentdefs):\n                    log.debug(\"Skipping private definition {}\", schema)\n                    continue\n                filtered_specs[\"definitions\"].setdefault(schema, definition)\n\n        return self.response(filtered_specs)\n\n    def is_definition_private(\n        self,\n        schema_name: str,\n        privatedefs: dict[str, bool],\n        parentdefs: dict[str, Any],\n        recursion: int = 0,\n    ) -> bool:\n        # can be True|False|None\n        from_private_endpoint = privatedefs.get(schema_name, None)\n\n        # Can be None|empty list|list\n        parents = parentdefs.get(schema_name, None)\n\n        # This definition is not used by any endpoint or other definitions\n        if from_private_endpoint is None and parents is None:\n            # log.warning(\"Unknown definition: {}\", schema_name)\n            return True\n\n        # This definition is not used by other definitions => the visibility\n        # is only given by endpoints visibility if any\n        if not parents and from_private_endpoint is not None:\n            return from_private_endpoint\n\n        # parents is not expected to be a non-empty list,\n        # otherwise something is going wrong\n        # This if should always fail\n        if not parents:  # pragma: no cover\n            log.warning(\n                \"Invalid {} definition, unable to determine the visibility {} {}\",\n                schema_name,\n                from_private_endpoint,\n                parents,\n            )\n            # Let's consider it as private and filter it out\n            return True\n\n        # Are we in a loop due to a cyclic dependency? Let's stop it\n        if recursion > 10:  # pragma: no cover\n            # Let's consider it as private and filter it out\n            return True\n\n        is_private = True\n        for parent in parents:\n            priv = self.is_definition_private(\n                parent,\n                privatedefs,\n                parentdefs,\n                recursion + 1,  # prevent infinite recursion\n            )\n            # The definition is private if only included in private definitions\n            # If used in at least one public definition, let's consider it as public\n            is_private = is_private and priv\n\n        return is_private\n", "test_authentication.py": "from typing import Any, Optional\n\nfrom restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.exceptions import Unauthorized\nfrom restapi.models import fields\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import Role, User\n\nif TESTING:\n\n    class TestAuthenticationNotRequired(EndpointResource):\n        @decorators.endpoint(\n            path=\"/tests/noauth\",\n            summary=\"Only resp a fixed response, no authenticataion is required\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(self) -> Response:\n            return self.response(\"OK\")\n\n    class TestAuthentication(EndpointResource):\n        @decorators.auth.require()\n        @decorators.endpoint(\n            path=\"/tests/authentication\",\n            summary=\"Only echos received token and corresponding user\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(self, user: User) -> Response:\n            return self.response({\"email\": user.email})\n\n    class TestOptionalAuthentication(EndpointResource):\n        @decorators.auth.optional()\n        @decorators.endpoint(\n            path=\"/tests/optionalauthentication\",\n            summary=\"Only echos received token and corresponding user, if any\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Tests executed with auth\",\n                204: \"Tests executed without auth\",\n            },\n        )\n        def get(self, user: Optional[User]) -> Response:\n            if user:\n                return self.response({\"email\": user.email})\n            return self.empty_response()\n\n    class TestQueryParameterAuthentication(EndpointResource):\n        @decorators.auth.require(allow_access_token_parameter=True)\n        @decorators.endpoint(\n            path=\"/tests/queryauthentication\",\n            summary=\"Only echos received token and corresponding user\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(self, user: User) -> Response:\n            return self.response({\"email\": user.email})\n\n    class TestOptionalQueryParameterAuthentication(EndpointResource):\n        @decorators.auth.optional(allow_access_token_parameter=True)\n        @decorators.endpoint(\n            path=\"/tests/optionalqueryauthentication\",\n            summary=\"Only echos received token and corresponding user, if any\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Tests executed with auth\",\n                204: \"Tests executed without auth\",\n            },\n        )\n        def get(self, user: Optional[User]) -> Response:\n            if user:\n                return self.response({\"email\": user.email})\n            return self.empty_response()\n\n    class TestAuthenticationWithMultipleRoles(EndpointResource):\n        @decorators.auth.require_any(Role.ADMIN, Role.USER)\n        @decorators.endpoint(\n            path=\"/tests/manyrolesauthentication\",\n            summary=\"Only echos received token and corresponding user\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(self, user: User) -> Response:\n            return self.response({\"email\": user.email})\n\n    # Note: this endpoint requires a role that does not exist!\n    class TestAuthenticationWithMissingRole(EndpointResource):\n        @decorators.auth.require_any(\"UnknownRole\")\n        @decorators.endpoint(\n            path=\"/tests/unknownroleauthentication\",\n            summary=\"Only echos received token and corresponding user, if any\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        # no cover because this endpoint will be never called\n        # because it requires an Unknown Role to be accessed\n        def get(self, user: User) -> Response:  # pragma: no cover\n            return self.response({\"email\": user.email})\n\n    def verify_uuid_value(endpoint: EndpointResource, uuid: str) -> dict[str, Any]:\n        user = endpoint.auth.get_user(user_id=uuid)\n        if not user or not endpoint.auth.is_admin(user):\n            raise Unauthorized(\"You are not authorized\")\n\n        # Returned values if any will be injected into the endpoint as fn parameters\n        return {\"target_user\": user}\n        # Otherwise can simply return None to inject nothing\n        # return None\n\n    # Note: this endpoint has a preload callback to verify the uuid and inject the user\n    class TestPreloadCallback(EndpointResource):\n        @decorators.auth.require()\n        @decorators.preload(callback=verify_uuid_value)\n        @decorators.use_kwargs({\"test\": fields.Bool(required=True)}, location=\"query\")\n        @decorators.endpoint(\n            path=\"/tests/preloadcallback/<uuid>\",\n            summary=\"Only authorized if uuid corresponds to an admin user\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        # Note: target_user is injected by the preload decorator\n        def get(self, uuid: str, test: bool, user: User, target_user: User) -> Response:\n            return self.response({\"email\": target_user.email})\n", "test_autocomplete.py": "from restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.models import Schema, fields\nfrom restapi.rest.definition import EndpointResource, Response\n\nif TESTING:\n    names = [\"oliver\", \"jack\", \"harry\", \"charlie\", \"thomas\"]\n    surnames = [\"smith\", \"jones\", \"taylor\", \"brown\", \"williams\"]\n    nicknames = [\"kid\", \"good\", \"bad\", \"ugly\", \"ripper\"]\n\n    class MyElement(Schema):\n        my_id = fields.Str(required=True)\n        my_label = fields.Str(required=True)\n\n    # This will accept a single element provided by the autocomplete endpoint\n    # The frontend is expected to translate this field into an autocomplete field\n    class SingleInput(Schema):\n        element = fields.Str(\n            required=True,\n            metadata={\n                \"autocomplete_endpoint\": \"/api/tests/autocomplete\",\n                \"autocomplete_id_bind\": \"my_id\",\n                \"autocomplete_label_bind\": \"my_label\",\n                \"autocomplete_show_id\": False,\n            },\n        )\n\n    # This will accept a list of elements provided by the autocomplete endpoint.\n    # The frontend is expected to translate this field into a multiple autocomplete\n    class ListInput(Schema):\n        elements = fields.List(\n            fields.Str(),\n            required=True,\n            metadata={\n                \"autocomplete_endpoint\": \"/api/tests/autocomplete\",\n                \"autocomplete_id_bind\": \"my_id\",\n                \"autocomplete_label_bind\": \"my_label\",\n                \"autocomplete_show_id\": True,\n            },\n        )\n\n    class TestAutocomplete(EndpointResource):\n        @staticmethod\n        def get_element(name: str, surname: str, nickname: str) -> tuple[str, str]:\n            return (\n                f\"{name[0].upper()}{surname[0].upper()}{nickname[0].upper()}\",\n                f\"{name.title()} {surname.title()} the {nickname.title()}\",\n            )\n\n        # This is the autocomplete endpoint\n        # It receive a string and return a list of elements matching the input\n        @decorators.marshal_with(MyElement(many=True), code=200)\n        @decorators.endpoint(\n            path=\"/tests/autocomplete/<query>\",\n            summary=\"Return list of elements matching the input\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(self, query: str) -> Response:\n            elements: list[dict[str, str]] = []\n\n            for k1 in names:\n                for k2 in surnames:\n                    for k3 in nicknames:\n                        k, v = self.get_element(k1, k2, k3)\n\n                        if query.lower() in v.lower():\n                            elements.append({\"my_id\": k, \"my_label\": v})\n\n            return self.response(elements)\n\n        @decorators.use_kwargs(ListInput)\n        @decorators.endpoint(\n            path=\"/tests/autocomplete\",\n            summary=\"Receives a list of MyElements\",\n            description=\"Only enabled in testing mode\",\n            responses={204: \"Tests executed\", 400: \"Bad Input\"},\n        )\n        def post(self, elements: list[str]) -> Response:\n            return self.empty_response()\n\n        @decorators.use_kwargs(SingleInput)\n        @decorators.endpoint(\n            path=\"/tests/autocomplete\",\n            summary=\"Receives a single MyElement\",\n            description=\"Only enabled in testing mode\",\n            responses={204: \"Tests executed\", 400: \"Bad Input\"},\n        )\n        def put(self, element: str) -> Response:\n            return self.empty_response()\n", "test_cache.py": "from typing import Optional\n\nfrom restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.connectors import Connector\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import User\n\nif TESTING and Connector.check_availability(\"redis\"):\n\n    class TestShortCache(EndpointResource):\n        \"\"\"\n        Used to test cache autocleaning at expiration\n        \"\"\"\n\n        labels = [\"tests\"]\n        counter = 0  # Increased at each request... except cached responses of course\n\n        @decorators.endpoint(\n            path=\"/tests/cache/short\",\n            summary=\"Execute tests on cached responses\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        @decorators.cache(timeout=1)\n        def get(self) -> Response:\n            TestShortCache.counter += 1\n            return self.response(TestShortCache.counter)\n\n    class TestLongCache(EndpointResource):\n        \"\"\"\n        Used to test cache cleaning with manual methods\n        \"\"\"\n\n        labels = [\"tests\"]\n        counter = 0  # Increased at each request... except cached responses of course\n\n        @decorators.endpoint(\n            path=\"/tests/cache/long\",\n            summary=\"Execute tests on cached responses\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        @decorators.cache(timeout=200)\n        def get(self) -> Response:\n            TestLongCache.counter += 1\n            return self.response(TestLongCache.counter)\n\n        @decorators.endpoint(\n            path=\"/tests/cache/long\",\n            summary=\"Clear endpoint cache\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                204: \"Endpoint cache cleared\",\n            },\n        )\n        def delete(self) -> Response:\n            self.clear_endpoint_cache()\n            return self.empty_response()\n\n    class TestAuthCache(EndpointResource):\n        \"\"\"\n        Used to test cache of authenticated endpoints\n        (cache keys are token dependent)\n        \"\"\"\n\n        labels = [\"tests\"]\n\n        counter = 0  # Increased at each request... except cached responses of course\n\n        @decorators.auth.require()\n        @decorators.endpoint(\n            path=\"/tests/cache/auth\",\n            summary=\"Execute tests of cached responses from authenticated endpoints\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        @decorators.cache(timeout=200)\n        def get(self, user: User) -> Response:\n            TestAuthCache.counter += 1\n            return self.response((user.uuid, TestAuthCache.counter))\n\n    class TestOptionalAuthCache(EndpointResource):\n        \"\"\"\n        Used to test cache of optionally authenticated endpoints\n        (cache keys are token dependent, if tokens are provided and valid)\n        \"\"\"\n\n        labels = [\"tests\"]\n\n        counter = 0  # Increased at each request... except cached responses of course\n\n        @decorators.auth.optional()\n        @decorators.endpoint(\n            path=\"/tests/cache/optionalauth\",\n            summary=\"Execute tests of cached responses from optionally auth. endpoints\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        @decorators.cache(timeout=200)\n        def get(self, user: Optional[User]) -> Response:\n            TestOptionalAuthCache.counter += 1\n            uuid = user.uuid if user else \"N/A\"\n            return self.response((uuid, TestOptionalAuthCache.counter))\n\n    class TestParamAuthCache(EndpointResource):\n        \"\"\"\n        Used to test cache of authenticated endpoints that accept access token param\n        (cache keys are token dependent)\n        \"\"\"\n\n        labels = [\"tests\"]\n\n        counter = 0  # Increased at each request... except cached responses of course\n\n        @decorators.auth.require(allow_access_token_parameter=True)\n        @decorators.endpoint(\n            path=\"/tests/cache/paramauth\",\n            summary=\"Execute tests of cached responses auth. endpoints with parameter\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        @decorators.cache(timeout=200)\n        def get(self, user: User) -> Response:\n            TestParamAuthCache.counter += 1\n            return self.response((user.uuid, TestParamAuthCache.counter))\n\n    class TestOptionalParamAuthCache(EndpointResource):\n        \"\"\"\n        Used to test cache of optionally authenticated endpoints\n        that accept access token param\n        (cache keys are token dependent, if tokens are provided and valid)\n        \"\"\"\n\n        labels = [\"tests\"]\n\n        counter = 0  # Increased at each request... except cached responses of course\n\n        @decorators.auth.optional(allow_access_token_parameter=True)\n        @decorators.endpoint(\n            path=\"/tests/cache/optionalparamauth\",\n            summary=\"Execute tests of caches of optionally auth. endpoints with param\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        @decorators.cache(timeout=200)\n        def get(self, user: Optional[User]) -> Response:\n            TestOptionalParamAuthCache.counter += 1\n            uuid = user.uuid if user else \"N/A\"\n            return self.response((uuid, TestOptionalParamAuthCache.counter))\n", "test_databases.py": "import re\n\nfrom restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.connectors import Connector\nfrom restapi.exceptions import BadRequest, DatabaseDuplicatedEntry, ServerError\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import DEFAULT_GROUP_NAME\n\n# from restapi.utilities.logs import log\n\nif TESTING:\n    # This endpoint will try to create database object with unique keys\n    # A duplicated entry exception will be raised and catched by the\n    # database_transaction that will restore previous modifications\n    class TestDatabase(EndpointResource):\n        labels = [\"tests\"]\n\n        @decorators.database_transaction\n        @decorators.endpoint(\n            path=\"/tests/database/<data>\",\n            summary=\"Execute tests on database functionalities\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Tests executed\",\n                400: \"Bad input\",\n                409: \"Group already exists\",\n            },\n        )\n        def post(self, data: str) -> Response:\n            # Special value! This will try to create a group without shortname\n            # A BadRequest will be raised due to the missing property\n            if data == \"400\":\n                group = self.auth.create_group({\"fullname\": data})\n                # The following two lines will be never executed because the\n                # create group above is intended to fail due to the missing property\n                self.auth.save_group(group)  # pragma: no cover\n                return self.response(\"0\")  # pragma: no cover\n\n            # Only DatabaseDuplicatedEntry will be raised by this endpoint\n            # Any other exceptions will be suppressed. This will ensure that\n            # DatabaseDuplicatedEntry is raised and no others.\n            # As a side effect this endpoint will modifiy the fullname of the default\n            # Group if the exception is not raised. Otherwise this modification will\n            # be undo by the database_transaction decorator\n            try:\n                default_group = self.auth.get_group(name=DEFAULT_GROUP_NAME)\n\n                if default_group is None:  # pragma: no cover\n                    raise ServerError(\"Default group is missing\")\n\n                default_group.fullname = f\"{default_group.fullname}_exteded\"\n                # Don't commit with alchemy or the transaction can't be rollbacked\n                if Connector.authentication_service != \"sqlalchemy\":\n                    self.auth.save_group(default_group)\n\n                # This can fail if data is a duplicate of a already created group\n                # In this case a DatabaseDuplicatedEntry excepton will be raised and the\n                # database_transaction decorator will undo the change on the default grp\n                group = self.auth.create_group({\"shortname\": data, \"fullname\": data})\n                # Don't commit with alchemy or the transaction can't be rollbacked\n                if Connector.authentication_service != \"sqlalchemy\":\n                    self.auth.save_group(group)\n\n                return self.response(\"1\")\n            except DatabaseDuplicatedEntry:\n                raise\n            except Exception:  # pragma: no cover\n                return self.response(\"0\")\n", "test_depends_on.py": "from restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.rest.definition import EndpointResource, Response\n\nif TESTING:\n    # This endpoint is activated only if neo4j is enabled\n    class TestDependsOn(EndpointResource):\n        labels = [\"tests\"]\n        depends_on = [\"NEO4J_ENABLE\"]\n\n        @decorators.endpoint(\n            path=\"/tests/depends_on/neo4j\",\n            summary=\"Execute tests on depends on option\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        def get(self) -> Response:\n            return self.response(\"1\")\n\n    # This endpoint is activated only if neo4j is NOT enabled\n    class TestDependsOnNOT(EndpointResource):\n        labels = [\"tests\"]\n        depends_on = [\"not NEO4J_ENABLE\"]\n\n        @decorators.endpoint(\n            path=\"/tests/depends_on_not/neo4j\",\n            summary=\"Execute tests on depends on option\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n            },\n        )\n        def get(self) -> Response:\n            return self.response(\"1\")\n", "test_download.py": "from restapi import decorators\nfrom restapi.config import DATA_PATH, TESTING\nfrom restapi.models import fields\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.download import Downloader\n\nif TESTING:\n\n    class TestDownload(EndpointResource):\n        labels = [\"tests\"]\n\n        @decorators.use_kwargs({\"stream\": fields.Bool()}, location=\"query\")\n        @decorators.endpoint(\n            # forgot the leading slash to test the automatic fix\n            path=\"tests/download/<folder>/<fname>\",\n            summary=\"Execute tests with the downloader\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Tests executed\",\n                206: \"Sent partial content\",\n                403: \"Invalid file path\",\n                404: \"The requested file does not exist\",\n                416: \"Range Not Satisfiable\",\n            },\n        )\n        def get(self, folder: str, fname: str, stream: bool = False) -> Response:\n            # The same as defined in test_upload\n            subfolder = DATA_PATH.joinpath(folder)\n\n            if stream:\n                return Downloader.send_file_streamed(fname, subfolder=subfolder)\n\n            return Downloader.send_file_content(fname, subfolder=subfolder)\n", "test_gzip.py": "from restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.exceptions import RestApiException\nfrom restapi.rest.definition import EndpointResource, Response\n\nif TESTING:\n\n    class TestGzipEncoding(EndpointResource):\n        labels = [\"tests\"]\n\n        @decorators.endpoint(\n            path=\"/tests/gzip/<size>\",\n            summary=\"Execute tests gzip encoding\",\n            description=\"Only enabled in testing mode\",\n            responses={\n                200: \"Content sent\",\n                416: \"Invalid size\",\n            },\n        )\n        def get(self, size: str) -> Response:\n            size_int = int(size)\n\n            if size_int <= 0:\n                raise RestApiException(\"Invalid size\", status_code=416)\n\n            # Just to prevent super giant responses\n            return self.response(\"a\" * min(size_int, 1_000_000))\n", "test_inputs.py": "from datetime import datetime\nfrom typing import Any, Optional\n\nimport pytz\n\nfrom restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.connectors import Connector\nfrom restapi.models import ISO8601UTC, Schema, fields, validate\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import User\n\nif TESTING:\n\n    class Nested(Schema):\n        nestedstr = fields.Str(required=True)\n\n    class CustomInt(fields.Int):\n        pass\n\n    class CustomGenericField(fields.Field):\n        pass\n\n    class InputSchema(Schema):\n        # lowercase key without label defined. label will be key.title() in schema\n        mystr = fields.Str(required=True, validate=validate.Length(min=4))\n        # non-lowercase key without label defined. label will be == to key in schema\n        MYDATE = fields.Date(required=True)\n        MYDATETIME = fields.AwareDateTime(\n            required=True,\n            format=ISO8601UTC,\n            default_timezone=pytz.utc,\n            validate=validate.Range(\n                max=datetime.now(pytz.utc).replace(hour=23, minute=59, second=59),\n                min=datetime(1900, 1, 1, tzinfo=pytz.utc),\n                max_inclusive=True,\n                error=\"Invalid date\",\n            ),\n        )\n        myint_exclusive = fields.Int(\n            required=True,\n            # Explicit label definition... but missing description\n            validate=validate.Range(\n                min=1, max=10, min_inclusive=False, max_inclusive=False\n            ),\n            metadata={\n                \"label\": \"Int exclusive field\",\n            },\n        )\n        myint_inclusive = fields.Int(\n            required=True,\n            # Both label and description explicit definition\n            validate=validate.Range(min=1, max=10),\n            metadata={\n                \"label\": \"Int inclusive field\",\n                \"description\": \"This field accepts values in a defined range\",\n            },\n        )\n\n        myselect = fields.Str(\n            required=True,\n            validate=validate.OneOf(choices=[\"a\", \"b\"], labels=[\"A\", \"B\"]),\n        )\n\n        myselect2 = fields.Str(\n            required=True,\n            # Wrong definition, number labels < number of choices\n            # Labels will be ignored and replaced by choices\n            validate=validate.OneOf(choices=[\"a\", \"b\"], labels=[\"A\"]),\n        )\n\n        mymaxstr = fields.Str(required=True, validate=validate.Length(max=7))\n\n        myequalstr = fields.Str(required=True, validate=validate.Length(equal=6))\n\n        # Note: requests (from pytest) has to json-dump the arrays and objects,\n        # but the normal Marshmallow fields does not json-load the inputs\n\n        # fields.Nested is a replacement of the default Nested field with the ability\n        # to receive json dumped data from requests or pytest\n        mynested = fields.Nested(Nested, required=True)\n\n        mynullablenested = fields.Nested(Nested, required=True, allow_none=True)\n\n        # fields.List is a replacement of the default List field with the ability\n        # to receive json dumped data from requests or pytest\n\n        # In json model the type of this field will be resolved as string[]\n        mylist = fields.List(fields.Str(), required=True)\n        # In json model the type of this field will be resolved as int[]\n        mylist2 = fields.List(CustomInt, required=True)\n        # In json model the type of this field will be resolved as mylist3[]\n        # The type is key[] ... should be something more explicative like FieldName[]\n        mylist3 = fields.List(CustomGenericField, required=True)\n\n    class TestInputs(EndpointResource):\n        @decorators.auth.optional(allow_access_token_parameter=True)\n        @decorators.use_kwargs(InputSchema)\n        @decorators.endpoint(\n            path=\"/tests/inputs\",\n            summary=\"Accept inputs based on a rich model\",\n            description=\"Only enabled in testing mode\",\n            responses={204: \"Tests executed\"},\n        )\n        def post(self, user: Optional[User], **kwargs: Any) -> Response:\n            return self.empty_response()\n\n\nif TESTING and Connector.check_availability(\"neo4j\"):\n    CHOICES = ((\"A\", \"AAA\"), (\"B\", \"BBB\"), (\"C\", \"CCC\"))\n\n    class InputNeo4jSchema(Schema):\n        # include a Neo4jChoice to test the deserialize\n        choice = fields.Neo4jChoice(CHOICES, required=True)\n\n    class UUID(Schema):\n        uuid = fields.String()\n\n    class TOKEN(Schema):\n        token_type = fields.String()\n\n    class OutputNeo4jSchema(Schema):\n        # include a Neo4jChoice to test the serialize\n        choice = fields.Neo4jChoice(CHOICES)\n        relationship_many = fields.Neo4jRelationshipToMany(TOKEN)\n        relationship_single = fields.Neo4jRelationshipToSingle(UUID)\n        relationship_count = fields.Neo4jRelationshipToCount()\n\n    class TestNeo4jInputs(EndpointResource):\n        @decorators.auth.require()\n        @decorators.use_kwargs(InputNeo4jSchema)\n        @decorators.marshal_with(OutputNeo4jSchema)\n        @decorators.endpoint(\n            path=\"/tests/neo4jinputs\",\n            summary=\"Accept inputs based on a neo4j-related schema\",\n            responses={204: \"Tests executed\"},\n        )\n        def post(self, choice: str, user: User) -> Response:\n            data = {\n                \"choice\": choice,\n                \"relationship_many\": user.tokens,\n                \"relationship_single\": user.belongs_to,\n                \"relationship_count\": user.tokens,\n            }\n            return self.response(data)\n", "test_neo4j.py": "import warnings\n\nfrom restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.connectors import Connector, neo4j\nfrom restapi.exceptions import BadRequest\nfrom restapi.models import Neo4jSchema, Schema, fields\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.utilities.logs import log\n\nif TESTING and Connector.check_availability(\"neo4j\"):\n    from neomodel import (\n        DateProperty,\n        FloatProperty,\n        IntegerProperty,\n        StringProperty,\n        StructuredNode,\n        UniqueIdProperty,\n    )\n\n    from restapi.connectors.neo4j.models import Group, User\n\n    CHOICES_tuple = ((\"A\", \"A\"), (\"B\", \"B\"), (\"C\", \"C\"))\n    CHOICES_dict = {\"A\": \"A\", \"B\": \"B\", \"C\": \"C\"}\n\n    # Base type StructuredNode becomes \"Any\" due to an unfollowed import\n    class Custom(StructuredNode):  # type: ignore\n        custom = StringProperty(required=True, choices=CHOICES_tuple)\n        myint = IntegerProperty(required=True)\n        myfloat = FloatProperty(required=True)\n        # do not set it as required because:\n        # ValueError: required argument ignored by UniqueIdProperty\n        myuuid = UniqueIdProperty()\n        mydate = DateProperty()\n\n    class Output(Schema):\n\n        # Raised from neomodel with python 3.12\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version\",  # noqa\n        )\n\n        val = fields.Integer()\n        created = fields.DateTime()\n        modified1 = fields.DateTime()\n        modified2 = fields.DateTime()\n        user = Neo4jSchema(\n            User,\n            fields=(\n                \"uuid\",\n                \"email\",\n                \"name\",\n                \"surname\",\n                \"is_active\",\n                \"last_password_change\",\n            ),\n        )\n        group1 = Neo4jSchema(Group, fields=\"*\")\n        group2 = Neo4jSchema(Group, fields=(\"*\",))\n        group3 = Neo4jSchema(Group, fields=[\"*\"])\n        group4 = Neo4jSchema(Group, fields=[])\n        group5 = Neo4jSchema(Group, fields=[\"fullname\", \"shortname\"])\n        group6 = Neo4jSchema(Group, fields=\"\")\n        group7 = Neo4jSchema(Group, fields=None)\n        custom = Neo4jSchema(Custom, fields=\"*\")\n\n        choices1 = fields.Neo4jChoice(CHOICES_tuple)\n        choices2 = fields.Neo4jChoice(CHOICES_dict)\n\n    class TestNeo4j(EndpointResource):\n        depends_on = [\"NEO4J_ENABLE_CONNECTOR\"]\n        labels = [\"tests\"]\n\n        @decorators.marshal_with(Output, code=200)\n        @decorators.endpoint(\n            path=\"/tests/neo4j/<test>\",\n            summary=\"Execute tests against the neo4j connector\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(self, test: str) -> Response:\n            self.neo4j = neo4j.get_instance()\n            try:\n                if test == \"1\":\n                    log.info(\"First Test\")\n                    self.neo4j.cypher(\"MATCH (n) RETURN n LIMIT 1\")\n                elif test == \"2\":\n                    log.info(\"Second Test\")\n                    self.neo4j.cypher(\"MATCH (n) RETURN n with a syntax error\")\n                # This test will verify that a timestamped node when saved\n                # Automatically update the modified attribute\n                elif test == \"3\":\n                    data = {}\n                    n = self.neo4j.NodeTest(p_str=\"\")\n                    n.save()\n                    data[\"created\"] = n.created\n                    data[\"modified1\"] = n.modified\n                    n.save()\n                    data[\"modified2\"] = n.modified\n                    return self.response(data)\n            except Exception as e:\n                raise BadRequest(str(e)) from e\n            return self.response({\"val\": 1})\n", "test_outputs.py": "from datetime import datetime\n\nfrom restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.rest.definition import EndpointResource, Response\n\nif TESTING:\n\n    class TestOutputs(EndpointResource):\n        # @decorators.marshal_with(OutputSchema)\n        @decorators.endpoint(\n            path=\"/tests/outputs/<out_type>\",\n            summary=\"Produce outputs based on the out_type url parameters\",\n            responses={200: \"Tests executed\"},\n        )\n        def post(self, out_type: str) -> Response:\n            if out_type == \"list\":\n                return self.response([\"a\", \"b\", \"c\", \"c\"])\n\n            if out_type == \"tuple\":\n                return self.response((\"a\", \"b\", \"c\", \"c\"))\n\n            if out_type == \"set\":\n                return self.response({\"a\", \"b\", \"c\", \"c\"})\n\n            if out_type == \"dict\":\n                return self.response({\"a\": 1, \"b\": 2, \"c\": 3})\n\n            if out_type == \"datetime\":\n                return self.response(datetime.now())\n\n            return self.response(\"string\")\n", "test_pagination.py": "from typing import Optional\n\nfrom restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.rest.definition import EndpointResource, Response\n\nif TESTING:\n\n    class TestPagination(EndpointResource):\n        # 150 integers from 1 to 150\n        values = list(range(1, 151))\n\n        @decorators.get_pagination\n        @decorators.endpoint(\n            path=\"/tests/pagination\",\n            summary=\"Execute tests on a paginated endpoint\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(\n            self,\n            get_total: bool,\n            page: int,\n            size: int,\n            sort_by: Optional[str],\n            sort_order: Optional[str],\n            input_filter: Optional[str],\n        ) -> Response:\n            if get_total:\n                return self.response(len(TestPagination.values))\n\n            offset = (page - 1) * size\n            return self.response(TestPagination.values[offset : offset + size])\n\n        @decorators.get_pagination\n        @decorators.endpoint(\n            path=\"/tests/pagination\",\n            summary=\"Execute tests on a paginated endpoint\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def post(\n            self,\n            get_total: bool,\n            page: int,\n            size: int,\n            sort_by: Optional[str],\n            sort_order: Optional[str],\n            input_filter: Optional[str],\n        ) -> Response:\n            if get_total:\n                return self.response(len(TestPagination.values))\n\n            offset = (page - 1) * size\n            return self.response(TestPagination.values[offset : offset + size])\n", "test_parameters_injection.py": "from restapi import decorators\nfrom restapi.config import TESTING\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.authentication import User\n\nif TESTING:\n\n    class TestParametersInjections(EndpointResource):\n        @decorators.auth.require()\n        @decorators.endpoint(\n            path=\"/tests/inject/<param>\",\n            summary=\"Verify injected parameters\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def get(\n            self, param: str, user: User, unknown: str = \"default_value\"\n        ) -> Response:\n            return self.response([user.email, param, unknown])\n", "test_upload.py": "from restapi import decorators\nfrom restapi.config import DATA_PATH, TESTING\nfrom restapi.models import PartialSchema, fields\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.services.uploader import Uploader\nfrom restapi.utilities.logs import log\n\nif TESTING:\n\n    class Force(PartialSchema):\n        force = fields.Bool()\n\n    class TestUpload(EndpointResource, Uploader):\n        labels = [\"tests\"]\n\n        @decorators.use_kwargs(Force)\n        @decorators.endpoint(\n            # forget the leading slash to test the automatic fix\n            path=\"tests/upload\",\n            summary=\"Execute tests with the uploader\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def put(self, force: bool = False) -> Response:\n            # This is just to test the allowed exts without adding a new parameter..\n            if not force:\n                self.set_allowed_exts([\"txt\"])\n            response = self.upload(\n                subfolder=DATA_PATH.joinpath(\"fixsubfolder\"), force=force\n            )\n            return response\n\n    class TestChunkedUpload(EndpointResource, Uploader):\n        labels = [\"tests\"]\n\n        @decorators.init_chunk_upload\n        @decorators.use_kwargs(Force)\n        @decorators.endpoint(\n            # forgot the leading slash to test the automatic fix\n            path=\"tests/chunkedupload\",\n            summary=\"Initialize tests on chunked upload\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Schema retrieved\", 201: \"Upload initialized\"},\n        )\n        def post(\n            self,\n            name: str,\n            mimeType: str,\n            size: int,\n            lastModified: int,\n            force: bool = False,\n        ) -> Response:\n            # This is just to test the allowed exts without adding a new parameter..\n            if not force:\n                self.set_allowed_exts([\"txt\"])\n\n            path = DATA_PATH.joinpath(\"fixed\")\n            return self.init_chunk_upload(path, name, force=force)\n\n        @decorators.use_kwargs(Force)\n        @decorators.endpoint(\n            # forgot the leading slash to test the automatic fix\n            path=\"tests/chunkedupload/<filename>\",\n            summary=\"Execute tests with the chunked uploader\",\n            description=\"Only enabled in testing mode\",\n            responses={200: \"Tests executed\"},\n        )\n        def put(self, filename: str, force: bool = False) -> Response:\n            path = DATA_PATH.joinpath(\"fixed\")\n            completed, response = self.chunk_upload(path, filename)\n\n            if completed:\n                log.info(\"Upload completed\")\n\n            return response\n", "tokens.py": "from faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import Events, log\n\n\nclass TestApp(BaseTests):\n    def test_tokens(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping tokens tests\")\n            return\n\n        last_token = None\n        last_tokens_header = None\n        token_id = None\n\n        for _ in range(3):\n            header, token = self.do_login(client, None, None)\n            last_tokens_header = header\n            last_token = token\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{AUTH_URI}/tokens\", headers=last_tokens_header)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n\n        # Probably due to password expiration:\n        # change password invalidated tokens created before\n        # => create tokens again\n        if len(content) < 3:  # pragma: no cover\n            for _ in range(3):\n                header, token = self.do_login(client, None, None)\n                last_tokens_header = header\n                last_token = token\n\n            # TEST GET ALL TOKENS\n            r = client.get(f\"{AUTH_URI}/tokens\", headers=last_tokens_header)\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, list)\n            assert len(content) >= 3\n\n        # save a token to be used for further tests\n        for c in content:\n            if c[\"token\"] == last_token:\n                continue\n            token_id = c[\"id\"]\n\n        # SINGLE TOKEN IS NOT ALLOWED\n        r = client.get(f\"{AUTH_URI}/tokens/{token_id}\", headers=last_tokens_header)\n        assert r.status_code == 405\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{API_URI}/admin/tokens\")\n        assert r.status_code == 401\n\n        # TEST GET ALL TOKENS\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] > 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True, \"input_filter\": \"1\"},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] > 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True, \"input_filter\": faker.pystr()},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] == 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True, \"page\": 1, \"size\": 20},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] > 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 0, \"size\": 20},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 400\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 0},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 400\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 101},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 400\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 99999, \"size\": 20},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 2},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) <= 2\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 20, \"input_filter\": \"1\"},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) >= 1\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 20, \"input_filter\": faker.pystr()},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\n                \"page\": 1,\n                \"size\": 20,\n                \"input_filter\": \"1\",\n                \"sort_by\": \"uuid\",\n            },\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        default_sort = self.get_content(r)\n        assert isinstance(default_sort, list)\n        assert len(default_sort) >= 2\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\n                \"page\": 1,\n                \"size\": 20,\n                \"input_filter\": \"1\",\n                \"sort_by\": \"uuid\",\n                \"sort_order\": \"asc\",\n            },\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        asc_sort = self.get_content(r)\n        assert isinstance(asc_sort, list)\n        assert len(asc_sort) >= 2\n        assert default_sort[0][\"token\"] == asc_sort[0][\"token\"]\n        assert default_sort[-1][\"token\"] == asc_sort[-1][\"token\"]\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\n                \"page\": 1,\n                \"size\": 20,\n                \"input_filter\": \"1\",\n                \"sort_by\": \"uuid\",\n                \"sort_order\": \"desc\",\n            },\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        desc_sort = self.get_content(r)\n        assert isinstance(desc_sort, list)\n        # Results of desc_sort can't be compared with previous contents\n        # It may only be done if we were able to retrieve all tokens, in this case the\n        # first desc will be the last asc... But we cannot ensure to be able to always\n        # retrieve all tokens.\n        assert len(desc_sort) >= 2\n        # At least they should be different\n        # assert asc_sort[0] != desc_sort[0]\n        # assert asc_sort[-1] != desc_sort[-1]\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{API_URI}/admin/tokens\", headers=last_tokens_header)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) >= 3\n\n        # DELETE INVALID TOKEN\n        r = client.delete(f\"{API_URI}/admin/tokens/xyz\", headers=last_tokens_header)\n        assert r.status_code == 404\n\n        # TEST DELETE OF A SINGLE TOKEN\n        r = client.delete(f\"{AUTH_URI}/tokens/{token_id}\", headers=last_tokens_header)\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.delete.value\n        assert events[0].target_type == \"Token\"\n        # Tokens does not have a uuid...\n        # assert events[0].target_id == token_id\n        assert events[0].user == \"-\"\n        assert events[0].url == f\"/auth/tokens/{token_id}\"\n\n        # TEST AN ALREADY DELETED TOKEN\n        r = client.delete(f\"{AUTH_URI}/tokens/{token_id}\", headers=last_tokens_header)\n        assert r.status_code == 403\n\n        # TEST INVALID DELETE OF A SINGLE TOKEN\n        r = client.delete(f\"{AUTH_URI}/tokens/0\", headers=last_tokens_header)\n        assert r.status_code == 403\n\n        # TEST TOKEN IS STILL VALID\n        r = client.get(f\"{AUTH_URI}/tokens\", headers=last_tokens_header)\n        assert r.status_code == 200\n\n        # user_header will be used as target for deletion\n        # Always enabled in core tests\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\"):  # pragma: no cover\n            uuid = None\n            user_header, token = self.do_login(client, None, None)\n        else:\n            uuid, data = self.create_user(client)\n            user_header, token = self.do_login(client, data[\"email\"], data[\"password\"])\n\n        r = client.get(f\"{AUTH_URI}/status\", headers=user_header)\n        assert r.status_code == 200\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{AUTH_URI}/tokens\", headers=user_header)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n\n        token_id = None\n        for c in content:\n            if c[\"token\"] == token:\n                token_id = c[\"id\"]\n                break\n\n        assert token_id is not None\n\n        last_tokens_header, _ = self.do_login(client, None, None)\n        r = client.delete(\n            f\"{API_URI}/admin/tokens/{token_id}\", headers=last_tokens_header\n        )\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.delete.value\n        assert events[0].target_type == \"Token\"\n        # Tokens does not have a uuid...\n        # assert events[0].target_id == token_id\n        assert events[0].user == \"-\"\n        assert events[0].url == f\"/api/admin/tokens/{token_id}\"\n\n        r = client.delete(\n            f\"{API_URI}/admin/tokens/{token_id}\", headers=last_tokens_header\n        )\n        assert r.status_code == 404\n\n        r = client.get(f\"{AUTH_URI}/status\", headers=user_header)\n        assert r.status_code == 401\n\n        # Goodbye temporary user (if previously created)\n        if uuid:\n            self.delete_user(client, uuid)\n", "env.py": "\"\"\"\nUtilities to work with environment variables\n\"\"\"\n\nimport os\nfrom functools import lru_cache\nfrom typing import Union\n\n\nclass Env:\n    @staticmethod\n    @lru_cache\n    def get(var: str, default: str) -> str:\n        return os.getenv(var, default)\n\n    @staticmethod\n    @lru_cache\n    def get_bool(var: str, default: bool = False) -> bool:\n        return Env.to_bool(Env.get(var, \"\"), default)\n\n    @staticmethod\n    @lru_cache\n    def get_int(var: str, default: int = 0) -> int:\n        return Env.to_int(Env.get(var, \"\"), default)\n\n    @staticmethod\n    @lru_cache\n    def to_bool(var: Union[None, str, bool], default: bool = False) -> bool:\n        if var is None or var == \"\":\n            return default\n\n        if isinstance(var, bool):\n            return var\n\n        # if not directly a bool, try an interpretation\n        # INTEGERS\n        try:\n            tmp = int(var)\n            return bool(tmp)\n        except (TypeError, ValueError):\n            pass\n\n        # STRINGS\n        if isinstance(var, str):\n            # false / False / FALSE\n            if var.lower() == \"false\":\n                return False\n            # any non empty string has to be considered True\n            if len(var) > 0:\n                return True\n\n        return default\n\n    @staticmethod\n    @lru_cache\n    def to_int(var: Union[None, str, int], default: int = 0) -> int:\n        if var is None or var == \"\":\n            return default\n\n        if isinstance(var, int):\n            return var\n\n        try:\n            return int(var)\n        except ValueError:\n            pass\n\n        return default\n\n    @staticmethod\n    def load_variables_group(prefix: str) -> dict[str, str]:\n        prefix += \"_\"\n\n        variables: dict[str, str] = {}\n\n        for var, value in os.environ.items():\n            var = var.lower()\n\n            if not var.startswith(prefix):\n                continue\n\n            # Fix key and value before saving\n            key = var.removeprefix(prefix)\n            # One thing that we must avoid is any quote around our value\n            value = value.strip('\"').strip(\"'\")\n            # save\n            variables[key] = value\n\n        return variables\n", "exceptions.py": "from faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import DEFAULT_GROUP_NAME\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_database_exceptions(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping dabase exceptions tests\")\n            return\n\n        # This is a special value. The endpoint will try to create a group without\n        # shortname. A BadRequest is expected because the database should refuse the\n        # entry due to the missing property\n        r = client.post(f\"{API_URI}/tests/database/400\")\n        assert r.status_code == 400\n        # This is the message of a DatabaseMissingRequiredProperty\n        assert self.get_content(r) == \"Missing property shortname required by Group\"\n\n        auth = Connector.get_authentication_instance()\n        default_group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert default_group is not None\n\n        # the /tests/database endpoint will change the default group fullname\n        # as a side effect to the test the database_transaction decorator\n        default_fullname = default_group.fullname\n\n        random_name = faker.pystr()\n\n        # This will create a new group with short/full name == random_name\n\n        r = client.post(f\"{API_URI}/tests/database/{random_name}\")\n        assert r.status_code == 200\n\n        default_group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert default_group is not None\n\n        # As a side effect the fullname of defaut_group is changed...\n        assert default_group.fullname != default_fullname\n\n        # ... and this is the new name\n        new_fullname = default_group.fullname\n\n        # This will try to create again a group with short/full name == random_name\n        # but this will fail due to unique keys\n        r = client.post(f\"{API_URI}/tests/database/{random_name}\")\n        assert r.status_code == 409\n        # This is the message of a DatabaseDuplicatedEntry\n        assert (\n            self.get_content(r)\n            == f\"A Group already exists with shortname: {random_name}\"\n        )\n        # The default group will not change again because the\n        # database_transaction decorator will undo the change\n        default_group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert default_group is not None\n\n        assert default_group.fullname == new_fullname\n", "mocks.py": "\"\"\"\nMock classes used to replace customization classes when building the documentation\n\"\"\"\n\nfrom restapi.connectors import Connector\nfrom restapi.customizer import BaseCustomizer, FlaskRequest, Props, User\nfrom restapi.rest.definition import EndpointResource\n\n\nclass Initializer:\n    \"\"\"\n    This class is instantiated just after restapi init\n    Implement the constructor to add operations performed one-time at initialization\n    \"\"\"\n\n    def __init__(self) -> None:\n        pass\n\n    # This method is called after normal initialization if TESTING mode is enabled\n    def initialize_testing_environment(self) -> None:\n        pass\n\n\nclass Customizer(BaseCustomizer):\n    @staticmethod\n    def custom_user_properties_pre(\n        properties: Props,\n    ) -> tuple[Props, Props]:\n        \"\"\"\n        executed just before user creation\n        use this method to removed or manipulate input properties\n        before sending to the database\n        \"\"\"\n        extra_properties: Props = {}\n        # if \"myfield\" in properties:\n        #     extra_properties[\"myfield\"] = properties[\"myfield\"]\n\n        return properties, extra_properties\n\n    @staticmethod\n    def custom_user_properties_post(\n        user: User, properties: Props, extra_properties: Props, db: Connector\n    ) -> None:\n        \"\"\"\n        executed just after user creation\n        use this method to implement extra operation needed to create a user\n        e.g. store additional relationships\n        \"\"\"\n        pass\n\n    @staticmethod\n    def manipulate_profile(ref: EndpointResource, user: User, data: Props) -> Props:\n        \"\"\"\n        execute before sending data from the profile endpoint\n        use this method to add additonal information to the user profile\n        \"\"\"\n        # data[\"CustomField\"] = user.custom_field\n\n        return data\n\n    @staticmethod\n    def get_custom_input_fields(request: FlaskRequest, scope: int) -> Props:\n        # required = request and request.method == \"POST\"\n        \"\"\"\n        if scope == BaseCustomizer.ADMIN:\n            return {\n                'custom_field': fields.Int(\n                    required=required,\n                    # validate=validate.Range(min=0, max=???),\n                    validate=validate.Range(min=0),\n                    label=\"CustomField\",\n                    description=\"This is a custom field\",\n                )\n            }\n        # these are editable fields in profile\n        if scope == BaseCustomizer.PROFILE:\n            return {}\n\n        # these are additional fields in registration form\n        if scope == BaseCustomizer.REGISTRATION:\n            return {}\n        \"\"\"\n\n        return {}\n\n    @staticmethod\n    def get_custom_output_fields(request: FlaskRequest) -> Props:\n        \"\"\"\n        this method is used to extend the output model of profile and admin users\n        \"\"\"\n\n        return {}\n", "models": {}, "fields.py": "import pytest\n\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.globals import mem\n\n\nclass TestApp(BaseTests):\n    @pytest.mark.skipif(\n        not Env.get_bool(\"AUTH_ENABLE\")\n        or not Env.get_bool(\"MAIN_LOGIN_ENABLE\")\n        or not Env.get_bool(\"ALLOW_REGISTRATION\"),\n        reason=\"This test needs authentication and registration to be available\",\n    )\n    def test_users_custom_fields(self, client: FlaskClient) -> None:\n        output_fields = mem.customizer.get_custom_output_fields(None)\n\n        profile_inputs = mem.customizer.get_custom_input_fields(\n            request=None, scope=mem.customizer.PROFILE\n        )\n        registration_inputs = mem.customizer.get_custom_input_fields(\n            request=None, scope=mem.customizer.REGISTRATION\n        )\n        admin_inputs = mem.customizer.get_custom_input_fields(\n            request=None, scope=mem.customizer.ADMIN\n        )\n        uuid, data = self.create_user(client)\n        headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n\n        # Verify custom output fields (if defined) included in the profile response\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n\n        for field in output_fields:\n            assert field in response\n\n        # Verify custom input fields (if defined) included in the profile input schema\n        r = client.patch(f\"{AUTH_URI}/profile\", json={\"get_schema\": 1}, headers=headers)\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        for field in profile_inputs.keys():\n            for expected in response:\n                if expected[\"key\"] == field:\n                    break\n            else:  # pragma: no cover\n                pytest.fail(f\"Input field {field} not found in profile input schema\")\n\n        # Verify custom registration fields (if defined) included in the reg. schema\n        r = client.post(f\"{AUTH_URI}/profile\", json={\"get_schema\": 1})\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        for field in registration_inputs.keys():\n            for expected in response:\n                if expected[\"key\"] == field:\n                    break\n            else:  # pragma: no cover\n                pytest.fail(\n                    f\"Input field {field} not found in registration input schema\"\n                )\n\n        headers, _ = self.do_login(client, None, None)\n        # Verify custom admin input fields (if defined) included in admin users schema\n        r = client.post(\n            f\"{API_URI}/admin/users\", json={\"get_schema\": 1}, headers=headers\n        )\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        for field in admin_inputs.keys():\n            for expected in response:\n                if expected[\"key\"] == field:\n                    break\n            else:  # pragma: no cover\n                pytest.fail(\n                    f\"Input field {field} not found in admin users input schema\"\n                )\n\n        # Verify custom admin output fields (if defined) included in admin users output\n        r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        for field in output_fields:\n            # This will fail\n            assert field in response\n", "schema.py": "import inspect\nfrom typing import Any, Optional, Union, cast\n\nfrom marshmallow import EXCLUDE\nfrom marshmallow import Schema as MarshmallowSchema\nfrom marshmallow import ValidationError, pre_load\nfrom neomodel import StructuredNode, StructuredRel, properties\n\nfrom restapi.models import fields\nfrom restapi.utilities.logs import log\n\nGET_SCHEMA_KEY = \"get_schema\"\n\n\nclass Schema(MarshmallowSchema):\n    def __init__(self, strip_required: bool = False, *args: Any, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        if strip_required:\n            for k in self.declared_fields:\n                self.declared_fields[k].required = False\n\n    @classmethod\n    def from_dict(\n        cls,\n        fields: dict[str, Union[fields.Field, type]],\n        *,\n        name: str = \"GeneratedSchema\",\n    ) -> type:\n        return super().from_dict(fields, name=name)\n\n    # instruct marshmallow to serialize data to a collections.OrderedDict\n    class Meta:\n        ordered = True\n\n    # NOTE: self is not used, but @pre_load cannot be static\n    @pre_load\n    def raise_get_schema(\n        self,\n        data: dict[str, Any],\n        **kwargs: Any,\n    ) -> dict[str, Any]:\n        if GET_SCHEMA_KEY in data:\n            raise ValidationError(\"Schema requested\")\n\n        if \"access_token\" not in data:\n            return data\n\n        # data is Immutable if it comes from args, is mutable otherwise\n        try:\n            data.pop(\"access_token\")\n            return data\n            # Why isinstance is not working here!?\n            # isinstance(data, ImmutableMultiDict)\n        except TypeError:  # pragma: no cover\n            mutable_data = data.to_dict()  # type: ignore\n            mutable_data.pop(\"access_token\")\n            return cast(dict[str, Any], mutable_data)\n\n\nclass PartialSchema(Schema):\n    class Meta:\n        ordered = True\n        unknown = EXCLUDE\n\n\nclass Neo4jSchema(Schema):\n    def __init__(\n        self, model: type[Any], fields: Optional[Any], *args: Any, **kwargs: Any\n    ) -> None:\n        super().__init__(**kwargs)\n\n        if not fields:\n            fields = ()\n        elif fields == \"*\":\n            fields = None\n        elif fields[0] == \"*\":\n            fields = None\n        elif isinstance(fields, tuple):\n            pass\n        elif isinstance(fields, list):\n            pass\n        else:  # pragma: no cover\n            log.error(\"Invalid fields: {}\", fields)\n            fields = ()\n\n        self.fields = fields  # type: ignore\n        # Leave the constructor to avoid variable shadowing between\n        # this fields and the from marshmallow import fields above\n        self.build_schema(model)\n\n    def build_schema(self, model: type[Any]) -> None:\n        # Get the full list of parent classes from model to object\n        classes = inspect.getmro(model)\n\n        starting_point = False\n        # Iterate in reversed order to start from object\n        for c in reversed(classes):\n            # Skip all parentes up to StructuredNode and StructuredRel (included)\n            if not starting_point:\n                # Found the starting point, next class will be descended up to model\n                if c == StructuredNode or c == StructuredRel:\n                    starting_point = True\n                # skip all parent up to StructuredNode and StructuredRel INCLUDED\n                continue\n\n            # Iterate all class attributes to find neomodel properties\n            for attribute in c.__dict__:\n                prop = getattr(c, attribute)\n\n                if not isinstance(prop, properties.Property):\n                    continue\n\n                # self.fields can be None when the special value * is given in input\n                if self.fields and attribute not in self.fields:\n                    continue\n\n                # log.info(\"Including property {}.{}\", model.__name__, attribute)\n                if isinstance(prop, properties.StringProperty):\n                    if prop.choices is None:\n                        self.declared_fields[attribute] = fields.Str()\n                    else:\n                        self.declared_fields[attribute] = fields.Neo4jChoice(\n                            prop.choices\n                        )\n\n                elif isinstance(prop, properties.BooleanProperty):\n                    self.declared_fields[attribute] = fields.Boolean()\n                elif isinstance(prop, properties.IntegerProperty):\n                    self.declared_fields[attribute] = fields.Integer()\n                elif isinstance(prop, properties.FloatProperty):\n                    self.declared_fields[attribute] = fields.Float()\n                elif isinstance(prop, properties.EmailProperty):\n                    self.declared_fields[attribute] = fields.Email()\n                elif isinstance(prop, properties.DateTimeProperty):\n                    self.declared_fields[attribute] = fields.AwareDateTime()\n                elif isinstance(prop, properties.DateProperty):\n                    self.declared_fields[attribute] = fields.Date()\n                elif isinstance(prop, properties.UniqueIdProperty):\n                    self.declared_fields[attribute] = fields.Str()\n                else:  # pragma: no cover\n                    log.error(\n                        \"Unsupport neomodel property: {}, fallback to StringProperty\",\n                        prop.__class__.__name__,\n                    )\n                    self.declared_fields[attribute] = fields.Str()\n", "py.typed": "# Marker file for PEP 561. The restapi package uses inline types.\n\n", "rest": {}, "annotations.py": "from typing import Any, Optional\n\nfrom flask_apispec.utils import Annotation\n\n# REVIEW: \u041d\u0435\u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f\ndef inject_apispec_docs(fn: Any, conf: Any, labels: Optional[list[str]]) -> None:\n    # retrieve attributes already set with @docs decorator\n    fn.__apispec__ = fn.__dict__.get(\"__apispec__\", {})\n    docs = {}\n    # it is normally available after loading the endpoint\n    # but it is still un-initialized when using the @endpoint decorator\n    if \"docs\" not in fn.__apispec__:\n        fn.__apispec__[\"docs\"] = []\n    else:\n        for doc in fn.__apispec__[\"docs\"]:\n            docs.update(doc.options[0])\n\n    missing = {}\n    if \"summary\" not in docs:\n        summary = conf.get(\"summary\")\n        if summary is not None:\n            missing[\"summary\"] = summary\n\n    if \"description\" not in docs:\n        description = conf.get(\"description\")\n        if description is not None:\n            missing[\"description\"] = description\n\n    if \"tags\" not in docs:\n        if labels:\n            missing[\"tags\"] = labels\n\n    if responses := conf.get(\"responses\"):\n        if \"responses\" not in docs:\n            missing[\"responses\"] = responses\n        else:\n            for code, resp in responses.items():\n                if code not in docs[\"responses\"]:\n                    missing.setdefault(\"responses\", {})\n                    missing[\"responses\"][code] = resp\n\n    # mimic the behaviour of @docs decorator\n    # https://github.com/jmcarp/flask-apispec/...\n    #                         .../flask_apispec/annotations.py\n    annotation = Annotation(\n        options=[missing],\n        # Inherit Swagger documentation from parent classes\n        # None is the default value\n        inherit=None,\n    )\n    fn.__apispec__[\"docs\"].insert(0, annotation)\n", "bearer.py": "\"\"\"\nThe tokens used are RFC6750 Bearer tokens.\n\nThe Resource should validate the tokens using the token validation endpoint;\nits basic use is by adding\n'Authorization: Bearer ' + tokenString to the HTTP header;\ncf. RFC6749 section 7.1.\n\nNote that anyone can validate a token as it is a bearer token:\nthere is no client id nor is client authentication required.\n\"\"\"\n\nfrom collections.abc import Iterable\nfrom functools import wraps\nfrom typing import Any, Callable, Optional, Union, cast\n\nfrom flask import request\nfrom werkzeug.datastructures import Authorization\n\nfrom restapi.customizer import FlaskRequest\nfrom restapi.env import Env\nfrom restapi.services.authentication import (\n    ALL_ROLES,\n    ANY_ROLE,\n    BaseAuthentication,\n    Role,\n)\nfrom restapi.types import EndpointFunction\nfrom restapi.utilities import print_and_exit\nfrom restapi.utilities.logs import log\nfrom restapi.utilities.meta import Meta\n\nHTTPAUTH_SCHEME = \"bearer\"\nHTTPAUTH_AUTH_FIELD = \"Authorization\"\n# Base header for errors\nHTTPAUTH_ERR_HEADER = {\n    \"WWW-Authenticate\": f'{HTTPAUTH_SCHEME} realm=\"Authentication Required\"'\n}\nALLOW_ACCESS_TOKEN_PARAMETER = Env.get_bool(\"ALLOW_ACCESS_TOKEN_PARAMETER\")\nTOKEN_VALIDATED_KEY = \"TOKEN_VALIDATED\"\n\n\nclass HTTPTokenAuth:\n    @staticmethod\n    def get_authorization_token(\n        allow_access_token_parameter: bool = False,\n    ) -> tuple[Optional[str], Optional[str]]:\n        if request.authorization is not None:\n            auth_type = request.authorization.type\n            token = request.authorization.token\n            return auth_type, token\n        elif HTTPAUTH_AUTH_FIELD in request.headers:\n            parsed_auth_header = Authorization.from_header(\n                request.headers.get(HTTPAUTH_AUTH_FIELD)\n            )\n            if parsed_auth_header is None:\n                return None, None\n            auth_type = parsed_auth_header.type\n            token = parsed_auth_header.token\n        elif ALLOW_ACCESS_TOKEN_PARAMETER or allow_access_token_parameter:\n            if not (token := request.args.get(\"access_token\", \"\")):\n                return None, None\n            return HTTPAUTH_SCHEME, token\n        return None, None\n\n    @staticmethod\n    def is_session_user_admin(request: FlaskRequest, auth: BaseAuthentication) -> bool:\n        if not request:\n            return False\n\n        _, token = HTTPTokenAuth.get_authorization_token(\n            allow_access_token_parameter=False\n        )\n        _, _, _, user = auth.verify_token(token)\n\n        return auth.is_admin(user)\n\n    # REVIEW: \u0414\u043b\u0438\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f, \u0440\u0430\u0441\u0442\u044f\u043d\u0443\u0442\u044b\u0435 \u0438 \u0432\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\n    @staticmethod\n    def optional(\n        allow_access_token_parameter: bool = False,\n    ) -> Callable[[EndpointFunction], EndpointFunction]:\n        def decorator(func: EndpointFunction) -> EndpointFunction:\n            # it is used in Loader to verify if an endpoint is requiring\n            # authentication and inject 401 errors\n            func.__dict__[\"auth.optional\"] = True\n\n            @wraps(func)\n            def wrapper(*args: Any, **kwargs: Any) -> Any:\n                # Recover the auth object\n                auth_type, token = HTTPTokenAuth.get_authorization_token(\n                    allow_access_token_parameter=allow_access_token_parameter\n                )\n\n                # Internal API 'self' reference\n                caller = Meta.get_self_reference_from_args(*args)\n\n                if caller is None:  # pragma: no cover\n                    # An exit here is really really dangerous, but even if\n                    # get_self_reference_from_args can return None, this case is quite\n                    # impossible... however with None the server can't continue!\n                    print_and_exit(\n                        \"Server misconfiguration, self reference can't be None!\"\n                    )\n\n                if (\n                    auth_type is not None\n                    and auth_type == HTTPAUTH_SCHEME\n                    and request.method != \"OPTIONS\"\n                ):\n                    # valid, token, jti, user\n                    valid, token, _, user = caller.auth.verify_token(token)\n\n                    # Check authentication. Optional authentication is valid if:\n                    # 1) token is missing\n                    # 2) token is valid\n                    # Invalid tokens are rejected\n                    if not valid:\n                        # Clear TCP receive buffer of any pending data\n                        _ = request.data\n                        # Mimic the response from a normal endpoint\n                        # To use the same standards\n                        # log.info(\"Invalid token received '{}'\", token)\n                        log.debug(\"Invalid token received\")\n                        return caller.response(\n                            \"Invalid token received\",\n                            headers=HTTPAUTH_ERR_HEADER,\n                            code=401,\n                            allow_html=True,\n                        )\n\n                    caller.authorized_user = user.uuid\n                    kwargs[\"user\"] = user\n                    request.environ[TOKEN_VALIDATED_KEY] = True\n                else:\n                    kwargs[\"user\"] = None\n\n                return func(*args, **kwargs)\n\n            return cast(EndpointFunction, wrapper)\n\n        return decorator\n\n    @classmethod\n    def require_all(\n        cls,\n        *roles: Union[str, Role],\n        allow_access_token_parameter: bool = False,\n    ) -> Callable[[EndpointFunction], EndpointFunction]:\n        return cls.require(\n            roles=roles,\n            required_roles=ALL_ROLES,\n            allow_access_token_parameter=allow_access_token_parameter,\n        )\n\n    @classmethod\n    def require_any(\n        cls,\n        *roles: Union[str, Role],\n        allow_access_token_parameter: bool = False,\n    ) -> Callable[[EndpointFunction], EndpointFunction]:\n        return cls.require(\n            roles=roles,\n            required_roles=ANY_ROLE,\n            allow_access_token_parameter=allow_access_token_parameter,\n        )\n\n    # REVIEW: \u0414\u043b\u0438\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f\n    @classmethod\n    def require(\n        cls,\n        roles: Optional[Iterable[Union[str, Role]]] = None,\n        required_roles: str = ALL_ROLES,\n        allow_access_token_parameter: bool = False,\n    ) -> Callable[[EndpointFunction], EndpointFunction]:\n        def decorator(func: EndpointFunction) -> EndpointFunction:\n            # it is used in Loader to verify if an endpoint is requiring\n            # authentication and inject 401 errors\n            func.__dict__[\"auth.required\"] = True\n\n            @wraps(func)\n            def wrapper(*args: Any, **kwargs: Any) -> Any:\n                # Recover the auth object\n                auth_type, token = HTTPTokenAuth.get_authorization_token(\n                    allow_access_token_parameter=allow_access_token_parameter\n                )\n\n                # Internal API 'self' reference\n                caller = Meta.get_self_reference_from_args(*args)\n\n                if caller is None:  # pragma: no cover\n                    # An exit here is really really dangerous, but even if\n                    # get_self_reference_from_args can return None, this case is quite\n                    # impossible... however with None the server can't continue!\n                    print_and_exit(\n                        \"Server misconfiguration, self reference can't be None!\"\n                    )\n\n                if auth_type is None or auth_type != HTTPAUTH_SCHEME:\n                    # Wrong authentication string\n                    msg = (\n                        \"Missing credentials in headers\"\n                        f\", e.g. {HTTPAUTH_AUTH_FIELD}: '{HTTPAUTH_SCHEME} TOKEN'\"\n                    )\n                    log.debug(\"Unauthorized request: missing credentials\")\n                    return caller.response(\n                        msg, code=401, headers=HTTPAUTH_ERR_HEADER, allow_html=True\n                    )\n\n                # Handling OPTIONS forwarded to our application:\n                # ignore headers and let go, avoid unwanted interactions with CORS\n                if request.method != \"OPTIONS\":\n                    # valid, token, jti, user\n                    valid, token, _, user = caller.auth.verify_token(token)\n                    # Check authentication\n                    if not valid:\n                        # Clear TCP receive buffer of any pending data\n                        _ = request.data\n                        # Mimic the response from a normal endpoint\n                        # To use the same standards\n                        # log.info(\"Invalid token received '{}'\", token)\n                        log.debug(\"Invalid token received\")\n                        return caller.response(\n                            \"Invalid token received\",\n                            headers=HTTPAUTH_ERR_HEADER,\n                            code=401,\n                            allow_html=True,\n                        )\n                    request.environ[TOKEN_VALIDATED_KEY] = True\n\n                # Check roles\n                if not caller.auth.verify_roles(\n                    user, roles, required_roles=required_roles\n                ):\n                    log.info(\"Unauthorized request: missing privileges.\")\n                    return caller.response(\n                        \"You are not authorized: missing privileges\",\n                        code=401,\n                        allow_html=True,\n                    )\n\n                caller.authorized_user = user.uuid\n                kwargs[\"user\"] = user\n                return func(*args, **kwargs)\n\n            return cast(EndpointFunction, wrapper)\n\n        return decorator\n", "definition.py": "import warnings\nfrom typing import Any, Optional\n\nfrom flask import Response as FlaskResponse\nfrom flask import request\nfrom flask.views import MethodView\nfrom flask_apispec import MethodResource\n\nfrom restapi.connectors import Connector\nfrom restapi.rest.response import ResponseMaker, jsonifier\nfrom restapi.services.authentication import BaseAuthentication, User\nfrom restapi.services.cache import Cache\nfrom restapi.types import Response, ResponseContent\nfrom restapi.utilities.logs import Events, log, save_event_log\n\nCURRENTPAGE_KEY = \"currentpage\"\nDEFAULT_CURRENTPAGE = 1\nPERPAGE_KEY = \"perpage\"\nDEFAULT_PERPAGE = 10\n\n\n# Base type MethodResource becomes \"Any\" due to an unfollowed import\n# Base type Resource becomes \"Any\" due to an unfollowed import\nclass EndpointResource(MethodResource, MethodView):  # type: ignore\n    depends_on: list[str] = []\n    labels = [\"undefined\"]\n    private = False\n    events = Events\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.__auth: Optional[BaseAuthentication] = None\n        # extracted from the token, if provided and verified\n        self.authorized_user: Optional[str] = None\n\n    # Used to set keys with Flask-Caching memoize\n    def __repr__(self) -> str:\n        return self.__class__.__module__\n\n    @property\n    def auth(self) -> BaseAuthentication:\n        if not self.__auth:\n            self.__auth = Connector.get_authentication_instance()\n\n        return self.__auth\n\n    # Deprecated since 2.1\n    def get_user(self) -> Optional[User]:  # pragma: no cover\n        warnings.warn(\n            \"Deprecated use of self.get_user(), user is now injected in the endpoint\"\n        )\n        return self.auth.get_user(user_id=self.authorized_user)\n\n    @staticmethod\n    def response(\n        content: ResponseContent = None,\n        code: Optional[int] = None,\n        headers: Optional[dict[str, str]] = None,\n        head_method: bool = False,\n        allow_html: bool = False,\n        force_json: bool = False,\n    ) -> Response:\n        if headers is None:\n            headers = {}\n\n        if code is None:\n            code = 200\n\n        if content is None and code != 204 and not head_method:\n            log.warning(\"RESPONSE: Warning, no data and no errors\")\n            code = 204\n\n        # Do not bypass FlaskApiSpec response management otherwise marshalling\n        # will be not applied. Consider the following scenario:\n        # @marshal(OnlyOneFieldSchema)\n        # def get():\n        #    return self.response(all_information)\n        # If you bypass the marshalling you will expose the all_information by\n        # retrieving it from a browser (or by forcing the Accept header)\n        # If you accept the risk or you do not use marshalling unlock html responses\n        # by the adding `allow_html=True` flag\n        if allow_html:\n            if \"text/html\" in ResponseMaker.get_accepted_formats():\n                content, headers = ResponseMaker.get_html(content, code, headers)\n                return FlaskResponse(\n                    content, mimetype=\"text/html\", status=code, headers=headers\n                )\n\n        if \"Content-Type\" not in headers or force_json:\n            headers[\"Content-Type\"] = \"application/json\"\n        if force_json:\n            content = jsonifier(content)\n\n        return (content, code, headers)\n\n    def empty_response(self) -> Response:\n        \"\"\"Empty response as defined by the protocol\"\"\"\n        return self.response(\"\", code=204)\n\n    # This function has to be coupled with a marshal_with(TotalSchema, code=206)\n    def pagination_total(self, total: int) -> Response:\n        return self.response({\"total\": total}, code=206)\n\n    def clear_endpoint_cache(self) -> None:\n        Cache.invalidate(self.get)\n\n    # Mostly copied in authentication.py\n    def log_event(\n        self,\n        event: Events,\n        target: Optional[Any] = None,\n        payload: Optional[dict[str, Any]] = None,\n        user: Optional[Any] = None,\n    ) -> None:\n        if not user:\n            user = self.auth.get_user(user_id=self.authorized_user)\n\n        save_event_log(\n            event=event,\n            target=target,\n            payload=payload,\n            user=user,\n            ip=BaseAuthentication.get_remote_ip(),\n            url=request.path,\n        )\n", "loader.py": "from pathlib import Path\nfrom typing import Optional\n\nfrom flask import request\nfrom plumbum.cmd import file\nfrom werkzeug.http import parse_content_range_header\nfrom werkzeug.utils import secure_filename\n\nfrom restapi.config import DATA_PATH, get_backend_url\nfrom restapi.exceptions import BadRequest, Conflict, Forbidden, ServiceUnavailable\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.utilities.logs import log\n\n# Equivalent to -r--r-----\nDEFAULT_PERMISSIONS = 0o440\n\n\nclass Uploader:\n    allowed_exts: list[str] = []\n\n    def set_allowed_exts(self, exts: list[str]) -> None:\n        self.allowed_exts = exts\n\n    def allowed_file(self, filename: str) -> bool:\n        if not self.allowed_exts:\n            return True\n        return (\n            \".\" in filename and filename.rsplit(\".\", 1)[1].lower() in self.allowed_exts\n        )\n\n    @staticmethod\n    def validate_upload_folder(path: Path) -> None:\n        if \"\\x00\" in str(path):\n            raise BadRequest(\"Invalid null byte in subfolder parameter\")\n\n        if path != path.resolve():\n            log.error(\"Invalid path: path is relative or contains double-dots\")\n            raise Forbidden(\"Invalid file path\")\n\n        if path != DATA_PATH and DATA_PATH not in path.parents:\n            log.error(\n                \"Invalid root path: {} is expected to be a child of {}\",\n                path,\n                DATA_PATH,\n            )\n            raise Forbidden(\"Invalid file path\")\n\n    @staticmethod\n    def get_file_metadata(abs_file: Path) -> dict[str, str]:\n        try:\n            # Check the type\n            # Example of output:\n            # text/plain; charset=us-ascii\n            out = file[\"-ib\", str(abs_file)]().split(\";\")\n            return {\"type\": out[0].strip(), \"charset\": out[1].split(\"=\")[1].strip()}\n        except Exception:\n            log.warning(\"Unknown type for '{}'\", abs_file)\n            return {}\n\n    # this method is used by mistral\n    def upload(self, subfolder: Path, force: bool = False) -> Response:\n        if \"file\" not in request.files:\n            raise BadRequest(\"No files specified\")  # pragma: no cover\n\n        myfile = request.files[\"file\"]\n\n        if not myfile.filename:  # pragma: no cover\n            raise BadRequest(\"Invalid filename\")\n\n        if not self.allowed_file(myfile.filename):\n            raise BadRequest(\"File extension not allowed\")\n\n        Uploader.validate_upload_folder(subfolder)\n\n        if not subfolder.exists():\n            subfolder.mkdir(parents=True, exist_ok=True)\n\n        fname = secure_filename(myfile.filename)\n        abs_file = subfolder.joinpath(fname)\n\n        log.info(\"File request for [{}]({})\", myfile, abs_file)\n\n        if abs_file.exists():\n            if not force:\n                raise Conflict(\n                    f\"File '{fname}' already exists, use force parameter to overwrite\"\n                )\n            abs_file.unlink()\n\n        # Save the file\n        try:\n            myfile.save(abs_file)\n            log.debug(\"Absolute file path should be '{}'\", abs_file)\n        except Exception as e:  # pragma: no cover\n            log.error(e)\n            raise ServiceUnavailable(\n                \"Permission denied: failed to write the file\"\n            ) from e\n\n        # Check exists - but it is basicaly a test that cannot fail...\n        # The has just been uploaded!\n        if not abs_file.exists():  # pragma: no cover\n            raise ServiceUnavailable(\"Unable to retrieve the uploaded file\")\n\n        ########################\n        # ## Final response\n\n        abs_file.chmod(DEFAULT_PERMISSIONS)\n\n        # Default redirect is to 302 state, which makes client\n        # think that response was unauthorized....\n        # see http://dotnet.dzone.com/articles/getting-know-cross-origin\n\n        return EndpointResource.response(\n            {\"filename\": fname, \"meta\": self.get_file_metadata(abs_file)},\n            code=200,\n        )\n\n    # Compatible with\n    # https://developers.google.com/drive/api/v3/manage-uploads#resumable\n    # and with https://www.npmjs.com/package/ngx-uploadx and with\n    def init_chunk_upload(\n        self, upload_dir: Path, filename: str, force: bool = True\n    ) -> Response:\n        if not self.allowed_file(filename):\n            raise BadRequest(\"File extension not allowed\")\n\n        Uploader.validate_upload_folder(upload_dir)\n\n        if not upload_dir.exists():\n            upload_dir.mkdir(parents=True, exist_ok=True)\n\n        filename = secure_filename(filename)\n\n        file_path = upload_dir.joinpath(filename)\n\n        if file_path.exists():\n            log.warning(\"File already exists\")\n            if force:\n                file_path.unlink()\n                log.debug(\"Forced removal\")\n            else:\n                raise Conflict(f\"File '{filename}' already exists\")\n\n        file_path.touch()\n\n        host = get_backend_url()\n        url = f\"{host}{request.path}/{filename}\"\n\n        log.info(\"Upload initialized on url: {}\", url)\n\n        return EndpointResource.response(\n            \"\",\n            headers={\"Access-Control-Expose-Headers\": \"Location\", \"Location\": url},\n            code=201,\n        )\n\n    @staticmethod\n    def parse_content_range(\n        range_header: Optional[str],\n    ) -> tuple[Optional[int], Optional[int], Optional[int]]:\n        if range_header is None:\n            return None, None, None\n\n        content_range = parse_content_range_header(range_header)\n\n        if content_range is None:\n            log.error(\"Unable to parse Content-Range: {}\", range_header)\n            tokens = range_header.split(\"/\")\n\n            if len(tokens) != 2:\n                log.error(\"Invalid Content-Range: {}\", range_header)\n                return None, None, None\n\n            if not tokens[1].isnumeric():\n                log.error(\"Invalid Content-Range: {}\", range_header)\n                return None, None, None\n\n            # A pattern like */len is expected\n            # => is returned start == 0 and stop == len\n            tot_len = int(tokens[1])\n            return tot_len, 0, tot_len\n\n        total_length = content_range.length\n        # es: 'bytes */35738983'\n        if content_range.start is None:\n            start = 0\n        else:\n            start = content_range.start\n\n        if content_range.stop is None:\n            stop = total_length\n        else:\n            stop = content_range.stop\n\n        return total_length, start, stop\n\n    # Please note that chunk_upload as to be used from a PUT endpoint\n    # PUT request is way different compared to POST request. With PUT request\n    # the file contents can be accessed using either request.data or request.stream.\n    # The first one stores incoming data as string, while request.stream acts\n    # more like a file object, making it more suitable for binary data\n    # Ref. http://stackoverflow.com/a/9533843/2114395\n    def chunk_upload(\n        self, upload_dir: Path, filename: str, chunk_size: Optional[int] = None\n    ) -> tuple[bool, Response]:\n        Uploader.validate_upload_folder(upload_dir)\n\n        filename = secure_filename(filename)\n\n        range_header = request.headers.get(\"Content-Range\", \"\")\n        total_length, start, stop = self.parse_content_range(range_header)\n\n        if total_length is None or start is None or stop is None:\n            raise BadRequest(\"Invalid request\")\n\n        completed = stop >= total_length\n\n        # Default chunk size, put this somewhere\n        if chunk_size is None:\n            chunk_size = 1048576\n\n        file_path = upload_dir.joinpath(filename)\n\n        # Uhm... this upload is not initialized?\n        if not file_path.exists():\n            raise ServiceUnavailable(\n                \"Permission denied: the destination file does not exist\"\n            )\n\n        try:\n            with open(file_path, \"ab\") as f:\n                while True:\n                    chunk = request.stream.read(chunk_size)\n                    if not chunk:\n                        break\n                    f.seek(start)\n                    f.write(chunk)\n        except PermissionError as e:\n            raise ServiceUnavailable(\n                \"Permission denied: failed to write the file\"\n            ) from e\n\n        if completed:\n            file_path.chmod(DEFAULT_PERMISSIONS)\n            return (\n                completed,\n                EndpointResource.response(\n                    {\"filename\": filename, \"meta\": self.get_file_metadata(file_path)},\n                    code=200,\n                ),\n            )\n\n        return (\n            completed,\n            EndpointResource.response(\n                \"partial\",\n                headers={\n                    \"Access-Control-Expose-Headers\": \"Range\",\n                    \"Range\": f\"0-{stop - 1}\",\n                },\n                code=206,\n            ),\n        )\n", "response.py": "import gzip\nimport sys\nimport time\nfrom datetime import date, datetime\nfrom decimal import Decimal\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import Any, Optional, Union, cast\nfrom urllib import parse as urllib_parse\n\nimport orjson\nfrom flask import Response as FlaskResponse\nfrom flask import jsonify, render_template, request\nfrom flask.json.provider import JSONProvider\nfrom marshmallow import fields as marshmallow_fields\nfrom marshmallow.utils import _Missing\nfrom werkzeug.exceptions import HTTPException\n\nfrom restapi import __version__ as version\nfrom restapi.config import (\n    GZIP_ENABLE,\n    GZIP_LEVEL,\n    GZIP_THRESHOLD,\n    get_project_configuration,\n)\nfrom restapi.models import GET_SCHEMA_KEY, Schema, fields, validate\nfrom restapi.services.authentication import BaseAuthentication\nfrom restapi.types import Response, ResponseContent\nfrom restapi.utilities.logs import handle_log_output, log, obfuscate_dict\n\n\ndef jsonifier(content: Any) -> str:\n    def default(obj: Any) -> Any:\n        if isinstance(obj, set):\n            return list(obj)\n        if isinstance(obj, (datetime, date)):  # pragma: no cover\n            return obj.isoformat()\n        if isinstance(obj, Decimal):\n            return float(obj)\n        if isinstance(obj, Path):\n            return str(obj)\n        raise TypeError  # pragma: no cover\n\n    return orjson.dumps(\n        content, default=default, option=orjson.OPT_NON_STR_KEYS\n    ).decode(\"UTF8\")\n\n\nclass ExtendedJSONEncoder(JSONProvider):\n    def dumps(self, obj: Any, **kwargs: Any) -> str:\n        return jsonifier(obj)\n\n    def loads(self, s: Union[str, bytes], **kwargs: Any) -> Any:\n        return orjson.loads(s)\n\n\ndef handle_http_errors(error: HTTPException) -> Response:\n    return FlaskResponse(\n        jsonifier({\"message\": error.description}),\n        status=error.code,\n        mimetype=\"application/json\",\n        headers={\"Content-Type\": \"application/json\"},\n    )\n\n\n# REVIEW: \u043c\u043d\u043e\u0433\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0435 \u0438 \u0440\u0430\u0441\u0442\u044f\u043d\u0443\u0442\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\ndef handle_marshmallow_errors(error: HTTPException) -> Response:\n    try:\n        if request.args:\n            if request.args.get(GET_SCHEMA_KEY, False):  # pragma: no cover\n                schema = cast(Schema, error.data.get(\"schema\"))  # type: ignore\n                return ResponseMaker.respond_with_schema(schema)\n\n        elif j := request.get_json():\n            if j.get(GET_SCHEMA_KEY, False):  # pragma: no cover\n                schema = cast(Schema, error.data.get(\"schema\"))  # type: ignore\n                return ResponseMaker.respond_with_schema(schema)\n\n        elif request.form:\n            if request.form.get(GET_SCHEMA_KEY, False):\n                schema = cast(Schema, error.data.get(\"schema\"))  # type: ignore\n                return ResponseMaker.respond_with_schema(schema)\n\n    except Exception as e:  # pragma: no cover\n        log.error(e)\n\n    errors = {}\n\n    error_messages = cast(\n        dict[str, dict[str, str]], error.data.get(\"messages\")  # type: ignore\n    )\n    for key, messages in error_messages.items():\n        for k, msg in messages.items():\n            if not msg:  # pragma: no cover\n                continue\n            log.error(\"[{}] {}: {}\", key, k, msg)\n            errors[k] = msg\n\n    return (errors, 400, {})\n\n\ndef obfuscate_query_parameters(raw_url: str) -> str:\n    url = urllib_parse.urlparse(raw_url)\n    try:\n        params = urllib_parse.unquote(\n            urllib_parse.urlencode(handle_log_output(url.query))\n        )\n        url = url._replace(query=params)\n        # remove http(s)://\n        url = url._replace(scheme=\"\")\n        # remove hostname:port\n        url = url._replace(netloc=\"\")\n    except TypeError:  # pragma: no cover\n        log.error(\"Unable to url encode the following parameters:\")\n        print(url.query)\n        return urllib_parse.urlunparse(url)\n\n    return urllib_parse.urlunparse(url)\n\n\ndef get_data_from_request() -> str:\n    # If it is an upload, DO NOT consume request.data or request.json,\n    # otherwise the content gets lost\n    try:\n        if request.mimetype in [\"application/octet-stream\", \"multipart/form-data\"]:\n            return \" STREAM_UPLOAD\"\n\n        if request.data:\n            if data := handle_log_output(request.data):\n                return f\" {data}\"\n\n        if request.form:\n            if data := obfuscate_dict(request.form):\n                return f\" {data}\"\n\n    except Exception as e:  # pragma: no cover\n        log.debug(e)\n\n    return \"\"\n\n\ndef handle_response(response: FlaskResponse) -> FlaskResponse:\n    response.headers[\"_RV\"] = str(version)\n\n    PROJECT_VERSION = get_project_configuration(\"project.version\", default=\"0\")\n    if PROJECT_VERSION is not None:\n        response.headers[\"Version\"] = str(PROJECT_VERSION)\n\n    data_string = get_data_from_request()\n\n    url = obfuscate_query_parameters(request.url)\n\n    if (\n        GZIP_ENABLE\n        and not response.is_streamed\n        and \"gzip\" in request.headers.get(\"Accept-Encoding\", \"\").lower()\n    ):\n        response.direct_passthrough = False\n        content, headers = ResponseMaker.gzip_response(\n            response.data,\n            response.status_code,\n            response.headers.get(\"Content-Encoding\"),\n            response.headers.get(\"Content-Type\"),\n        )\n        if content:\n            response.data = content\n            response.headers.update(headers)\n\n    resp = str(response).replace(\"<Response \", \"\").replace(\">\", \"\")\n    ip = BaseAuthentication.get_remote_ip(raise_warnings=False)\n\n    is_healthcheck = (\n        ip == \"127.0.0.1\" and request.method == \"GET\" and url == \"/api/status\"\n    )\n    if is_healthcheck:\n        log.debug(\n            \"{} {} {}{} -> {} [HEALTHCHECK]\",\n            ip,\n            request.method,\n            url,\n            data_string,\n            resp,\n        )\n    else:\n        log.info(\n            \"{} {} {}{} -> {}\",\n            ip,\n            request.method,\n            url,\n            data_string,\n            resp,\n        )\n\n    return response\n\n\nclass ResponseMaker:\n    # Have a look here: (from flask import request)\n    # request.user_agent.browser\n    @staticmethod\n    def get_accepted_formats() -> list[str]:\n        \"\"\"\n        Possible outputs:\n        '*/*'\n        'application/json'\n        'text/html'\n        'application/xml'\n        'text/csv'\n        \"\"\"\n        for val in request.headers:\n            if val[0] == \"Accept\":\n                return [x.strip() for x in val[1].split(\",\")]\n        return [\"*/*\"]\n\n    @staticmethod\n    def is_binary(content_type: Optional[str]) -> bool:\n        if not content_type:\n            return False\n\n        if content_type == \"application/json\":\n            return False\n\n        if content_type.startswith(\"text/\"):\n            return False\n\n        if content_type.startswith(\"image/\"):\n            return True\n\n        if content_type.startswith(\"audio/\"):\n            return True\n\n        if content_type.startswith(\"video/\"):\n            return True\n\n        if content_type.startswith(\"application/\"):\n            return True\n\n        log.warning(\"Unknown Content-Type: {}\", content_type)\n        return False\n\n    @staticmethod\n    def get_html(\n        content: ResponseContent, code: int, headers: dict[str, str]\n    ) -> tuple[str, dict[str, str]]:\n        if isinstance(content, list):  # pragma: no cover\n            content = content.pop()\n\n        headers[\"Content-Type\"] = \"text/html; charset=UTF-8\"\n\n        html_data = {\"body_content\": content, \"is_error\": code >= 400}\n        html_page = render_template(\"index.html\", **html_data)\n\n        return html_page, headers\n\n    @staticmethod\n    def gzip_response(\n        content: bytes,\n        code: int,\n        content_encoding: Optional[str],\n        content_type: Optional[str],\n    ) -> tuple[Optional[bytes], dict[str, str]]:\n        if code < 200 or code >= 300 or content_encoding is not None:\n            return None, {}\n\n        # Do not compress binary contents (like images) due to small benefits expected\n        if ResponseMaker.is_binary(content_type):  # pragma: no cover\n            # log.warning(\"Skipping gzip compression on {}\", content_type)\n            return None, {}\n\n        # Do not compress small contents\n        if (nbytes := sys.getsizeof(content)) < GZIP_THRESHOLD:\n            return None, {}\n\n        start_time = time.time()\n\n        gzip_buffer = BytesIO()\n        # compresslevel: an integer from 0 to 9 controlling the level of compression;\n        # 1 is fastest and produces the least compression\n        # 9 is slowest and produces the most compression (default)\n        # 0 is no compression\n        gzip_file = gzip.GzipFile(\n            mode=\"w\", fileobj=gzip_buffer, compresslevel=GZIP_LEVEL\n        )\n\n        gzip_file.write(content)\n        gzip_file.close()\n\n        gzipped_content = gzip_buffer.getvalue()\n\n        headers = {\n            \"Content-Encoding\": \"gzip\",\n            \"Vary\": \"Accept-Encoding\",\n            \"Content-Length\": str(len(gzipped_content)),\n        }\n\n        end_time = time.time()\n        t = int(1000 * (end_time - start_time))\n        new_size = sys.getsizeof(gzipped_content)\n        ratio = 1 - new_size / nbytes\n\n        log.info(\n            \"[GZIP] {} bytes compressed in {} ms -> {} bytes ({:.2f} %)\",\n            nbytes,\n            \"< 1\" if t < 1 else t,\n            new_size,\n            100 * ratio,\n        )\n        # This a debug code use to detect content types that should not be compressed\n        if ratio < 0.1:  # pragma: no cover\n            log.warning(\n                \"Small benefit due to gzip compression on Content-Type: {} ({:.2f} %)\",\n                content_type,\n                100 * ratio,\n            )\n        return gzipped_content, headers\n\n    @staticmethod\n    def convert_model_to_schema(schema: Schema) -> list[dict[str, Any]]:\n        schema_fields = []\n        for field, field_def in schema.declared_fields.items():\n            f: dict[str, Any] = {}\n\n            f[\"key\"] = field_def.data_key or field\n\n            if \"label\" in field_def.metadata:\n                f[\"label\"] = field_def.metadata[\"label\"]\n            elif f[\"key\"] == f[\"key\"].lower():\n                f[\"label\"] = f[\"key\"].title()\n            else:\n                f[\"label\"] = f[\"key\"]\n\n            if \"description\" in field_def.metadata:\n                f[\"description\"] = field_def.metadata[\"description\"]\n            else:\n                f[\"description\"] = f[\"label\"]\n\n            if \"extra_descriptions\" in field_def.metadata:\n                f[\"extra_descriptions\"] = field_def.metadata[\"extra_descriptions\"]\n\n            f[\"required\"] = field_def.required\n\n            f[\"type\"] = ResponseMaker.get_schema_type(field, field_def)\n\n            if autocomplete_endpoint := field_def.metadata.get(\"autocomplete_endpoint\"):\n                f[\"autocomplete_endpoint\"] = autocomplete_endpoint\n                f[\"autocomplete_show_id\"] = field_def.metadata.get(\n                    \"autocomplete_show_id\", False\n                )\n\n            if autocomplete_id_bind := field_def.metadata.get(\"autocomplete_id_bind\"):\n                f[\"autocomplete_id_bind\"] = autocomplete_id_bind\n\n            if autocomplete_label_bind := field_def.metadata.get(\n                \"autocomplete_label_bind\"\n            ):\n                f[\"autocomplete_label_bind\"] = autocomplete_label_bind\n\n            if not isinstance(field_def.dump_default, _Missing):\n                f[\"default\"] = field_def.dump_default\n            elif not isinstance(field_def.load_default, _Missing):  # pragma: no cover\n                f[\"default\"] = field_def.load_default\n\n            validators: list[validate.Validator] = []\n            if field_def.validate:\n                validators.append(field_def.validate)  # type: ignore\n\n            # activated in case of fields.List(fields.SomeThing) with an inner validator\n            if isinstance(field_def, fields.List) and field_def.inner.validate:\n                validators.append(field_def.inner.validate)\n\n            for validator in validators:\n                if isinstance(validator, validate.Length):\n                    if validator.min is not None:\n                        f[\"min\"] = validator.min\n                    if validator.max is not None:\n                        f[\"max\"] = validator.max\n                    if validator.equal is not None:\n                        f[\"min\"] = validator.equal\n                        f[\"max\"] = validator.equal\n\n                elif isinstance(validator, validate.Range):\n                    if validator.min is not None:\n                        f[\"min\"] = validator.min\n                        if not validator.min_inclusive:\n                            f[\"min\"] += 1\n\n                    if validator.max is not None:\n                        f[\"max\"] = validator.max\n                        if not validator.max_inclusive:\n                            f[\"max\"] -= 1\n\n                elif isinstance(validator, validate.OneOf):\n                    choices = validator.choices\n                    labels = validator.labels\n                    if len(tuple(labels)) != len(tuple(choices)):\n                        labels = choices\n                    f[\"options\"] = dict(zip(choices, labels))\n\n                else:  # pragma: no cover\n                    log.warning(\n                        \"Unsupported validation schema: {}.{}\",\n                        type(validator).__module__,\n                        type(validator).__name__,\n                    )\n\n            if f[\"type\"] == \"nested\":\n                f[\"schema\"] = ResponseMaker.convert_model_to_schema(\n                    field_def.schema  # type: ignore\n                )\n\n            schema_fields.append(f)\n        return schema_fields\n\n    @staticmethod\n    def respond_with_schema(schema: Schema) -> Response:\n        try:\n            fields = ResponseMaker.convert_model_to_schema(schema)\n            return (jsonify(fields), 200, {})\n        except Exception as e:  # pragma: no cover\n            log.error(e)\n            content = {\"Server internal error\": \"Failed to retrieve input schema\"}\n            return (jsonify(content), 500, {})\n\n    @staticmethod\n    def get_schema_type(\n        field: str, schema: marshmallow_fields.Field, default: Optional[Any] = None\n    ) -> str:\n        if schema.metadata.get(\"password\", False):\n            return \"password\"\n        # types from https://github.com/danohu/py2ng\n        # https://github.com/danohu/py2ng/blob/master/py2ng/__init__.py\n        if isinstance(schema, fields.Bool) or isinstance(schema, fields.Boolean):\n            return \"boolean\"\n        if isinstance(schema, fields.Date):\n            return \"date\"\n        # Include both AwareDateTime and NaiveDateTime that extend DateTime\n        if isinstance(schema, fields.DateTime):\n            return \"datetime\"\n        if isinstance(schema, fields.Decimal):\n            return \"number\"\n        if isinstance(schema, fields.Dict):\n            return \"dictionary\"\n        if isinstance(schema, fields.Email):\n            return \"email\"\n        # if isinstance(schema, fields.Field):\n        #     return 'any'\n        if isinstance(schema, fields.Float):\n            return \"number\"\n        if isinstance(schema, fields.Int) or isinstance(schema, fields.Integer):\n            return \"int\"\n        if isinstance(schema, fields.List):\n            key = schema.data_key or field\n            inner_type = ResponseMaker.get_schema_type(field, schema.inner, default=key)\n            return f\"{inner_type}[]\"\n        if isinstance(schema, fields.Nested):\n            return \"nested\"\n        if isinstance(schema, fields.Number):\n            return \"number\"\n        if isinstance(schema, fields.Str) or isinstance(schema, fields.String):\n            return \"string\"\n\n        # Reached with lists of custom types\n        if default:\n            return str(default)\n\n        log.error(\"Unknown schema type: {}\", type(schema))\n\n        return \"string\"\n", "server.py": "\"\"\"\nThe Main server factory. All internal flask components are created here\n\"\"\"\n\nimport logging\nimport signal\nimport sys\nimport time\nimport warnings\nfrom enum import Enum\nfrom threading import Lock\nfrom types import FrameType\nfrom typing import Optional\n\nimport werkzeug.exceptions\nfrom apispec import APISpec\nfrom apispec.ext.marshmallow import MarshmallowPlugin\nfrom flask import Flask\nfrom flask_apispec import FlaskApiSpec\nfrom flask_cors import CORS\nfrom neo4j.meta import ExperimentalWarning as Neo4jExperimentalWarning\nfrom sentry_sdk import init as sentry_sdk_init\nfrom sentry_sdk.integrations.flask import FlaskIntegration\n\nfrom restapi import __version__ as restapi_version\nfrom restapi import config\nfrom restapi.config import (\n    ABS_RESTAPI_PATH,\n    DOCS,\n    FORCE_PRODUCTION_TESTS,\n    HOST_TYPE,\n    MAIN_SERVER_NAME,\n    PRODUCTION,\n    SENTRY_URL,\n    TESTING,\n    get_backend_url,\n    get_frontend_url,\n    get_project_configuration,\n)\nfrom restapi.connectors import Connector\nfrom restapi.customizer import BaseCustomizer\nfrom restapi.env import Env\nfrom restapi.rest.loader import EndpointsLoader\nfrom restapi.rest.response import (\n    ExtendedJSONEncoder,\n    handle_http_errors,\n    handle_marshmallow_errors,\n    handle_response,\n)\nfrom restapi.services.cache import Cache\nfrom restapi.utilities import print_and_exit\nfrom restapi.utilities.globals import mem\nfrom restapi.utilities.logs import Events, log, save_event_log\nfrom restapi.utilities.meta import Meta\n\nlock = Lock()\n\n\nclass ServerModes(int, Enum):\n    NORMAL = 0\n    INIT = 1\n    DESTROY = 2\n    WORKER = 3\n\n\n# def inspect_request():\n#     log.critical(request.headers)\n\n\ndef teardown_handler(\n    signal: int, frame: Optional[FrameType]\n) -> None:  # pragma: no cover\n    with lock:\n        Connector.disconnect_all()\n\n    # This is needed to let connectors to complete the disconnection and prevent\n    # errors like this on rabbitMQ:\n    # closing AMQP connection <0.2684.0> ([...], vhost: '/', user: [...]):\n    # client unexpectedly closed TCP connection\n    time.sleep(1)\n    print(\"Disconnection completed\")\n    sys.exit(0)\n\n\ndef create_app(\n    name: str,\n    mode: ServerModes,\n    options: dict[str, bool],\n) -> Flask:\n    \"\"\"Create the server istance for Flask application\"\"\"\n\n    mem.boot_completed = False\n    if PRODUCTION and TESTING and not FORCE_PRODUCTION_TESTS:  # pragma: no cover\n        print_and_exit(\"Unable to execute tests in production\")\n\n    # TERM is not catched by Flask\n    # https://github.com/docker/compose/issues/4199#issuecomment-426109482\n    # signal.signal(signal.SIGTERM, teardown_handler)\n    # SIGINT is registered as STOPSIGNAL in Dockerfile\n    signal.signal(signal.SIGINT, teardown_handler)\n\n    # Flask app instance\n    # template_folder = template dir for output in HTML\n    flask_app = Flask(name, template_folder=str(ABS_RESTAPI_PATH.joinpath(\"templates\")))\n\n    # CORS\n    if not PRODUCTION:\n        if TESTING:\n            cors_origin = \"*\"\n        else:  # pragma: no cover\n            cors_origin = get_frontend_url()\n            # Beware, this only works because get_frontend_url never append a port\n            cors_origin += \":*\"\n\n        CORS(\n            flask_app,\n            allow_headers=[\n                \"Content-Type\",\n                \"Authorization\",\n                \"X-Requested-With\",\n                \"x-upload-content-length\",\n                \"x-upload-content-type\",\n                \"content-range\",\n            ],\n            supports_credentials=[\"true\"],\n            methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n            resources={r\"*\": {\"origins\": cors_origin}},\n        )\n\n        log.debug(\"CORS Enabled\")\n\n    # Flask configuration from config file\n    flask_app.config.from_object(config)\n    flask_app.json = ExtendedJSONEncoder(flask_app)\n\n    log.debug(\"Flask app configured\")\n\n    if PRODUCTION:\n        log.info(\"Production server mode is ON\")\n\n    endpoints_loader = EndpointsLoader()\n\n    if HOST_TYPE == DOCS:  # pragma: no cover\n        log.critical(\"Creating mocked configuration\")\n        mem.configuration = {}\n\n        log.critical(\"Loading Mocked Initializer and Customizer classes\")\n        from restapi.mocks import Customizer, Initializer\n\n        mem.initializer = Initializer\n        mem.customizer = Customizer()\n\n    else:\n        mem.configuration = endpoints_loader.load_configuration()\n        mem.initializer = Meta.get_class(\"initialization\", \"Initializer\")\n        if not mem.initializer:  # pragma: no cover\n            print_and_exit(\"Invalid Initializer class\")\n\n        customizer = Meta.get_class(\"customization\", \"Customizer\")\n        if not customizer:  # pragma: no cover\n            print_and_exit(\"Invalid Customizer class\")\n        mem.customizer = customizer()\n\n    if not isinstance(mem.customizer, BaseCustomizer):  # pragma: no cover\n        print_and_exit(\"Invalid Customizer class, it should inherit BaseCustomizer\")\n\n    Connector.init_app(app=flask_app, worker_mode=(mode == ServerModes.WORKER))\n\n    if mode == ServerModes.INIT:\n        Connector.project_init(options=options)\n\n    if mode == ServerModes.DESTROY:\n        Connector.project_clean()\n\n    # Restful plugin with endpoint mapping (skipped in INIT|DESTROY|WORKER modes)\n    if mode == ServerModes.NORMAL:\n        logging.getLogger(\"werkzeug\").setLevel(logging.ERROR)\n\n        # warnings levels:\n        # default  # Warn once per call location\n        # error    # Convert to exceptions\n        # always   # Warn every time\n        # module   # Warn once per calling module\n        # once     # Warn once per Python process\n        # ignore   # Never warn\n\n        # Types of warnings:\n        # Warning: This is the base class of all warning category classes\n        # UserWarning: The default category for warn().\n        # DeprecationWarning: Base category for warnings about deprecated features when\n        #                     those warnings are intended for other Python developers\n        # SyntaxWarning: Base category for warnings about dubious syntactic features.\n        # RuntimeWarning: Base category for warnings about dubious runtime features.\n        # FutureWarning: Base category for warnings about deprecated features when those\n        #                warnings are intended for end users\n        # PendingDeprecationWarning: Base category for warnings about features that will\n        #                            be deprecated in the future (ignored by default).\n        # ImportWarning: Base category for warnings triggered during the process of\n        #                importing a module\n        # UnicodeWarning: Base category for warnings related to Unicode.\n        # BytesWarning: Base category for warnings related to bytes and bytearray.\n        # ResourceWarning: Base category for warnings related to resource usage\n\n        if TESTING:\n            warnings.simplefilter(\"always\", Warning)\n            warnings.simplefilter(\"error\", UserWarning)\n            warnings.simplefilter(\"error\", DeprecationWarning)\n            warnings.simplefilter(\"error\", SyntaxWarning)\n            warnings.simplefilter(\"error\", RuntimeWarning)\n            warnings.simplefilter(\"error\", FutureWarning)\n            # warnings about features that will be deprecated in the future\n            warnings.simplefilter(\"default\", PendingDeprecationWarning)\n            warnings.simplefilter(\"error\", ImportWarning)\n            warnings.simplefilter(\"error\", UnicodeWarning)\n            warnings.simplefilter(\"error\", BytesWarning)\n            # Can't set this an error due to false positives with downloads\n            # a lot of issues like: https://github.com/pallets/flask/issues/2468\n            warnings.simplefilter(\"always\", ResourceWarning)\n            warnings.simplefilter(\"default\", Neo4jExperimentalWarning)\n\n        elif PRODUCTION:  # pragma: no cover\n            warnings.simplefilter(\"ignore\", Warning)\n            warnings.simplefilter(\"always\", UserWarning)\n            warnings.simplefilter(\"default\", DeprecationWarning)\n            warnings.simplefilter(\"ignore\", SyntaxWarning)\n            warnings.simplefilter(\"ignore\", RuntimeWarning)\n            warnings.simplefilter(\"ignore\", FutureWarning)\n            warnings.simplefilter(\"ignore\", PendingDeprecationWarning)\n            warnings.simplefilter(\"ignore\", ImportWarning)\n            warnings.simplefilter(\"ignore\", UnicodeWarning)\n            warnings.simplefilter(\"ignore\", BytesWarning)\n            warnings.simplefilter(\"ignore\", ResourceWarning)\n            # even if ignore it is raised once\n            # because of the imports executed before setting this to ignore\n            warnings.simplefilter(\"ignore\", Neo4jExperimentalWarning)\n        else:  # pragma: no cover\n            warnings.simplefilter(\"default\", Warning)\n            warnings.simplefilter(\"always\", UserWarning)\n            warnings.simplefilter(\"always\", DeprecationWarning)\n            warnings.simplefilter(\"default\", SyntaxWarning)\n            warnings.simplefilter(\"default\", RuntimeWarning)\n            warnings.simplefilter(\"always\", FutureWarning)\n            warnings.simplefilter(\"default\", PendingDeprecationWarning)\n            warnings.simplefilter(\"default\", ImportWarning)\n            warnings.simplefilter(\"default\", UnicodeWarning)\n            warnings.simplefilter(\"default\", BytesWarning)\n            warnings.simplefilter(\"always\", ResourceWarning)\n            # even if ignore it is raised once\n            # because of the imports executed before setting this to ignore\n            warnings.simplefilter(\"ignore\", Neo4jExperimentalWarning)\n\n        # ignore warning messages from apispec\n        warnings.filterwarnings(\n            \"ignore\", message=\"Multiple schemas resolved to the name \"\n        )\n\n        # ignore warning messages on flask socket after teardown\n        warnings.filterwarnings(\"ignore\", message=\"unclosed <socket.socket\")\n\n        # Raised from sentry_sdk 1.5.11 with python 3.10 events\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"SelectableGroups dict interface is deprecated. Use select.\",\n        )\n\n        # Raised from neo4j 5\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"Relying on Driver's destructor to close the session is deprecated.\",\n        )\n\n        # Raised from flask-apispec 0.11.4 on python 3.12\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"Use timezone-aware objects to represent datetimes in UTC\",\n        )\n\n        # Raised from neomodel with python 3.12\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version\",  # noqa\n        )\n\n        if Connector.check_availability(\"redis\"):\n            mem.cache = Cache.get_instance(flask_app)\n\n        endpoints_loader.load_endpoints()\n        mem.authenticated_endpoints = endpoints_loader.authenticated_endpoints\n        mem.private_endpoints = endpoints_loader.private_endpoints\n\n        for endpoint in endpoints_loader.endpoints:\n            ename = endpoint.cls.__name__.lower()\n            endpoint_view = endpoint.cls.as_view(ename)\n            for url in endpoint.uris:\n                flask_app.add_url_rule(url, view_func=endpoint_view)\n\n        # APISpec configuration\n        api_url = get_backend_url()\n        scheme, host = api_url.rstrip(\"/\").split(\"://\")\n\n        spec = APISpec(\n            title=get_project_configuration(\n                \"project.title\", default=\"Your application name\"\n            ),\n            version=get_project_configuration(\"project.version\", default=\"0.0.1\"),\n            openapi_version=\"2.0\",\n            # OpenApi 3 not working with FlaskApiSpec\n            # -> Duplicate parameter with name body and location body\n            # https://github.com/jmcarp/flask-apispec/issues/170\n            # Find other warning like this by searching:\n            # **FASTAPI**\n            # openapi_version=\"3.0.2\",\n            plugins=[MarshmallowPlugin()],\n            host=host,\n            schemes=[scheme],\n            tags=endpoints_loader.tags,\n        )\n        # OpenAPI 3 changed the definition of the security level.\n        # Some changes needed here?\n\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            api_key_scheme = {\"type\": \"apiKey\", \"in\": \"header\", \"name\": \"Authorization\"}\n            spec.components.security_scheme(\"Bearer\", api_key_scheme)\n\n        flask_app.config.update(\n            {\n                \"APISPEC_SPEC\": spec,\n                # 'APISPEC_SWAGGER_URL': '/api/swagger',\n                \"APISPEC_SWAGGER_URL\": None,\n                # 'APISPEC_SWAGGER_UI_URL': '/api/swagger-ui',\n                # Disable Swagger-UI\n                \"APISPEC_SWAGGER_UI_URL\": None,\n            }\n        )\n\n        mem.docs = FlaskApiSpec(flask_app)\n\n        # Clean app routes\n        ignore_verbs = {\"HEAD\", \"OPTIONS\"}\n\n        for rule in flask_app.url_map.iter_rules():\n            view_function = flask_app.view_functions[rule.endpoint]\n            if not hasattr(view_function, \"view_class\"):\n                continue\n\n            newmethods = ignore_verbs.copy()\n            rulename = str(rule)\n\n            if rule.methods:\n                for verb in rule.methods - ignore_verbs:\n                    method = verb.lower()\n                    if method in endpoints_loader.uri2methods[rulename]:\n                        # remove from flask mapping\n                        # to allow 405 response\n                        newmethods.add(verb)\n\n            rule.methods = newmethods\n\n        # Register swagger. Note: after method mapping cleaning\n        with flask_app.app_context():\n            for endpoint in endpoints_loader.endpoints:\n                try:\n                    mem.docs.register(endpoint.cls)\n                except TypeError as e:  # pragma: no cover\n                    print(e)\n                    log.error(\"Cannot register {}: {}\", endpoint.cls.__name__, e)\n\n    # marshmallow errors handler\n    flask_app.register_error_handler(422, handle_marshmallow_errors)\n    flask_app.register_error_handler(400, handle_http_errors)\n    flask_app.register_error_handler(404, handle_http_errors)\n    flask_app.register_error_handler(405, handle_http_errors)\n    flask_app.register_error_handler(500, handle_http_errors)\n\n    # flask_app.before_request(inspect_request)\n    # Logging responses\n    flask_app.after_request(handle_response)\n\n    if SENTRY_URL is not None:  # pragma: no cover\n        if PRODUCTION:\n            sentry_sdk_init(\n                dsn=SENTRY_URL,\n                # already catched by handle_marshmallow_errors\n                ignore_errors=[werkzeug.exceptions.UnprocessableEntity],\n                integrations=[FlaskIntegration()],\n            )\n            log.info(\"Enabled Sentry {}\", SENTRY_URL)\n        else:\n            # Could be enabled in print mode\n            # sentry_sdk_init(transport=print)\n            log.info(\"Skipping Sentry, only enabled in PRODUCTION mode\")\n\n    version = get_project_configuration(\"project.version\", default=\"0.0.1\")\n    log.info(\"Boot completed (version {}, rapydo {})\", version, restapi_version)\n    if PRODUCTION and not TESTING and name == MAIN_SERVER_NAME:  # pragma: no cover\n        save_event_log(\n            event=Events.server_startup,\n            payload={\n                \"server\": name,\n                \"version\": get_project_configuration(\n                    \"project.version\", default=\"0.0.1\"\n                ),\n                \"rapydo\": restapi_version,\n            },\n            user=None,\n            target=None,\n        )\n\n    mem.boot_completed = True\n    return flask_app\n", "services": {}, "authentication.py": "import time\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nimport pyotp\nimport pytest\nimport pytz\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.exceptions import BadRequest, Conflict, Unauthorized\nfrom restapi.services.authentication import (\n    DEFAULT_GROUP_NAME,\n    BaseAuthentication,\n    InvalidToken,\n    Role,\n    RoleObj,\n)\nfrom restapi.tests import BaseTests, FlaskClient\n\n\ndef verify_token_is_valid(\n    auth: BaseAuthentication, token: str, ttype: Optional[str] = None\n) -> None:\n    unpacked_token = auth.verify_token(token, token_type=ttype)\n    assert unpacked_token[0]\n    assert unpacked_token[1] is not None\n    assert unpacked_token[2] is not None\n    assert unpacked_token[3] is not None\n\n\ndef verify_token_is_not_valid(\n    auth: BaseAuthentication, token: str, ttype: Optional[str] = None\n) -> None:\n    unpacked_token = auth.verify_token(token, token_type=ttype)\n    assert not unpacked_token[0]\n    assert unpacked_token[1] is None\n    assert unpacked_token[2] is None\n    assert unpacked_token[3] is None\n\n    with pytest.raises(Exception):\n        auth.verify_token(token, token_type=ttype, raiseErrors=True)\n\n\n@pytest.mark.skipif(\n    not Connector.check_availability(\"authentication\"),\n    reason=\"This test needs authentication to be available\",\n)\nclass TestApp(BaseTests):\n    def test_password_management(self, faker: Faker) -> None:\n        # Ensure name and surname longer than 3\n        name = self.get_first_name(faker)\n        surname = self.get_last_name(faker)\n        # Ensure an email not containing name and surname\n        email = self.get_random_email(faker, name, surname)\n\n        auth = Connector.get_authentication_instance()\n\n        min_pwd_len = Env.get_int(\"AUTH_MIN_PASSWORD_LENGTH\", 9999)\n\n        pwd = faker.password(min_pwd_len - 1)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"The new password cannot match the previous password\"\n\n        pwd = faker.password(min_pwd_len - 1)\n        old_pwd = faker.password(min_pwd_len)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        error = f\"Password is too short, use at least {min_pwd_len} characters\"\n        assert ret_text == error\n\n        pwd = faker.password(min_pwd_len, low=False, up=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing lower case letters\"\n\n        pwd = faker.password(min_pwd_len, low=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing upper case letters\"\n\n        pwd = faker.password(min_pwd_len, low=True, up=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing numbers\"\n\n        pwd = faker.password(min_pwd_len, low=True, up=True, digits=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing special characters\"\n\n        pwd = faker.password(min_pwd_len, low=True, up=True, digits=True, symbols=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert ret_val\n        assert ret_text == \"\"\n\n        password_with_name = [\n            name,\n            surname,\n            f\"{faker.pystr()}{name}{faker.pystr()}\"\n            f\"{faker.pystr()}{surname}{faker.pystr()}\"\n            f\"{name}{faker.pyint(1, 99)}\",\n        ]\n        for p in password_with_name:\n            for pp in [p, p.lower(), p.upper(), p.title()]:\n                # This is because with \"strange characters\" it is not ensured that:\n                # str == str.upper().lower()\n                # In that case let's skip the variant that alter the characters\n                if p.lower() != pp.lower():  # pragma: no cover\n                    continue\n                # This is to prevent failures for other reasons like length of chars\n                pp += \"+ABCabc123!\"\n                val, text = auth.verify_password_strength(\n                    pwd=pp, old_pwd=old_pwd, email=email, name=name, surname=surname\n                )\n                assert not val\n                assert text == \"Password is too weak, can't contain your name\"\n\n        email_local = email.split(\"@\")[0]\n        password_with_email = [\n            email,\n            email.replace(\".\", \"\").replace(\"_\", \"\"),\n            email_local,\n            email_local.replace(\".\", \"\").replace(\"_\", \"\"),\n            f\"{faker.pystr()}{email_local}{faker.pystr()}\",\n        ]\n\n        for p in password_with_email:\n            for pp in [p, p.lower(), p.upper(), p.title()]:\n                # This is because with \"strange characters\" it is not ensured that:\n                # str == str.upper().lower()\n                # In that case let's skip the variant that alter the characters\n                if p.lower() != pp.lower():  # pragma: no cover\n                    continue\n                # This is to prevent failures for other reasons like length of chars\n                pp += \"+ABCabc123!\"\n                val, txt = auth.verify_password_strength(\n                    pwd=pp, old_pwd=old_pwd, email=email, name=name, surname=surname\n                )\n                assert not val\n                assert txt == \"Password is too weak, can't contain your email address\"\n\n        # Short names are not inspected for containing checks\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=\"Bob1234567!\", old_pwd=old_pwd, email=email, name=\"Bob\", surname=surname\n        )\n        assert ret_val\n        assert ret_text == \"\"\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        pwd = faker.password(min_pwd_len - 1)\n\n        with pytest.raises(BadRequest, match=r\"Missing new password\"):\n            # None password\n            auth.change_password(user, pwd, None, None)\n\n        with pytest.raises(BadRequest, match=r\"Missing password confirmation\"):\n            # None password confirmation\n            auth.change_password(user, pwd, pwd, None)\n\n        with pytest.raises(\n            Conflict, match=r\"Your password doesn't match the confirmation\"\n        ):\n            # wrong confirmation\n            auth.change_password(user, pwd, pwd, faker.password(strong=True))\n\n        with pytest.raises(\n            Conflict,\n            match=r\"The new password cannot match the previous password\",\n        ):\n            # Failed password strength checks\n            auth.change_password(user, pwd, pwd, pwd)\n\n        with pytest.raises(\n            Conflict,\n            match=rf\"Password is too short, use at least {min_pwd_len} characters\",\n        ):\n            # the first password parameter is only checked for new password strenght\n            # i.e. is verified password != newpassword\n            # pwd validity will be checked once completed checks on new password\n            # => a random current password is ok here\n            # Failed password strength checks\n            auth.change_password(user, faker.password(), pwd, pwd)\n\n        pwd1 = faker.password(strong=True)\n        pwd2 = faker.password(strong=True)\n\n        hash_1 = auth.get_password_hash(pwd1)\n        assert len(hash_1) > 0\n        assert hash_1 != auth.get_password_hash(pwd2)\n\n        with pytest.raises(Unauthorized, match=r\"Invalid password\"):\n            # Hashing empty password\n            auth.get_password_hash(\"\")\n\n        with pytest.raises(Unauthorized, match=r\"Invalid password\"):\n            # Hashing a None password!\n            auth.get_password_hash(None)\n\n        assert auth.verify_password(pwd1, hash_1)\n\n        assert not auth.is_bcrypt_hashed(\"test\")\n        test_hash = auth.get_password_hash(pwd1)\n        assert auth.is_bcrypt_hashed(test_hash)\n\n    @staticmethod\n    @pytest.mark.skipif(\n        not Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"),\n        reason=\"This test needs 2FA to be available\",\n    )\n    def test_totp_management() -> None:\n        auth = Connector.get_authentication_instance()\n\n        with pytest.raises(Unauthorized, match=r\"Verification code is missing\"):\n            # NULL totp\n            auth.verify_totp(None, None)\n\n        user = auth.get_user(username=auth.default_user)\n        secret = auth.get_totp_secret(user)\n        totp = pyotp.TOTP(secret)\n\n        # Verifiy current totp\n        assert auth.verify_totp(user, totp.now())\n\n        now = datetime.now()\n        t30s = timedelta(seconds=30)\n\n        # Verify previous and next totp(s)\n        assert auth.verify_totp(user, totp.at(now + t30s))\n        assert auth.verify_totp(user, totp.at(now - t30s))\n\n        # Verify second-previous and second-ntext totp(s)\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Future totp\n            auth.verify_totp(user, totp.at(now + t30s + t30s))\n\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Past totp\n            auth.verify_totp(user, totp.at(now - t30s - t30s))\n\n        # Extend validity window\n        auth.TOTP_VALIDITY_WINDOW = 2\n\n        # Verify again second-previous and second-ntext totp(s)\n        assert auth.verify_totp(user, totp.at(now + t30s + t30s))\n        assert auth.verify_totp(user, totp.at(now - t30s - t30s))\n\n        # Verify second-second-previous and second-second-ntext totp(s)\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Future totp\n            auth.verify_totp(user, totp.at(now + t30s + t30s + t30s))\n\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Past totp\n            auth.verify_totp(user, totp.at(now - t30s - t30s - t30s))\n\n    @staticmethod\n    def test_login_management(faker: Faker) -> None:\n        auth = Connector.get_authentication_instance()\n\n        if BaseAuthentication.default_user:\n            logins = auth.get_logins(BaseAuthentication.default_user)\n\n            assert isinstance(logins, list)\n            assert len(logins) > 0\n\n            auth.flush_failed_logins(BaseAuthentication.default_user)\n            logins = auth.get_logins(\n                BaseAuthentication.default_user, only_unflushed=True\n            )\n            assert len(logins) == 0\n\n            logins = auth.get_logins(\n                BaseAuthentication.default_user, only_unflushed=False\n            )\n            assert len(logins) > 0\n\n        logins = auth.get_logins(faker.ascii_email())\n        assert isinstance(logins, list)\n        assert len(logins) == 0\n\n        logins = auth.get_logins(faker.pystr())\n        assert isinstance(logins, list)\n        assert len(logins) == 0\n\n    def test_tokens_management(self, client: FlaskClient, faker: Faker) -> None:\n        auth = Connector.get_authentication_instance()\n\n        # Just to verify that the function works\n        verify_token_is_not_valid(auth, faker.pystr())\n        verify_token_is_not_valid(auth, faker.pystr(), auth.PWD_RESET)\n        verify_token_is_not_valid(auth, faker.pystr(), auth.ACTIVATE_ACCOUNT)\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        t1, payload1 = auth.create_temporary_token(user, auth.PWD_RESET)\n        assert isinstance(t1, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t1, auth.PWD_RESET)\n        auth.save_token(user, t1, payload1, token_type=auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1)\n        verify_token_is_not_valid(auth, t1, auth.FULL_TOKEN)\n        verify_token_is_valid(auth, t1, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1, auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, faker.ascii_email(), t1)\n\n        # Create another type of temporary token => t1 is still valid\n        t2, payload2 = auth.create_temporary_token(user, auth.ACTIVATE_ACCOUNT)\n        assert isinstance(t2, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t2, auth.ACTIVATE_ACCOUNT)\n        auth.save_token(user, t2, payload2, token_type=auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, t2)\n        verify_token_is_not_valid(auth, t2, auth.FULL_TOKEN)\n        verify_token_is_not_valid(auth, t2, auth.PWD_RESET)\n        verify_token_is_valid(auth, t2, auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, faker.ascii_email(), t2)\n\n        EXPIRATION = 3\n        # Create another token PWD_RESET, this will invalidate t1\n        t3, payload3 = auth.create_temporary_token(\n            user, auth.PWD_RESET, duration=EXPIRATION\n        )\n        assert isinstance(t3, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t3, auth.PWD_RESET)\n        auth.save_token(user, t3, payload3, token_type=auth.PWD_RESET)\n        verify_token_is_valid(auth, t3, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1)\n        verify_token_is_not_valid(auth, t1, auth.FULL_TOKEN)\n        verify_token_is_not_valid(auth, t1, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1, auth.ACTIVATE_ACCOUNT)\n\n        # Create another token ACTIVATE_ACCOUNT, this will invalidate t2\n        t4, payload4 = auth.create_temporary_token(\n            user, auth.ACTIVATE_ACCOUNT, duration=EXPIRATION\n        )\n        assert isinstance(t4, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t4, auth.ACTIVATE_ACCOUNT)\n        auth.save_token(user, t4, payload4, token_type=auth.ACTIVATE_ACCOUNT)\n        verify_token_is_valid(auth, t4, auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, t2)\n        verify_token_is_not_valid(auth, t2, auth.FULL_TOKEN)\n        verify_token_is_not_valid(auth, t2, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t2, auth.ACTIVATE_ACCOUNT)\n\n        # token expiration is only 3 seconds... let's test it\n        time.sleep(EXPIRATION + 1)\n        verify_token_is_not_valid(auth, t3, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t4, auth.ACTIVATE_ACCOUNT)\n\n        unpacked_token = auth.verify_token(None, raiseErrors=False)\n        assert not unpacked_token[0]\n\n        with pytest.raises(InvalidToken, match=r\"Missing token\"):\n            auth.verify_token(None, raiseErrors=True)\n\n        # Test token validiy\n        _, token = self.do_login(client, None, None)\n\n        tokens = auth.get_tokens(get_all=True)\n        jti = None\n        user = None\n        for t in tokens:\n            if t[\"token\"] == token:\n                jti = t[\"id\"]\n                user = t[\"user\"]\n                break\n        assert jti is not None\n        assert user is not None\n\n        assert auth.verify_token_validity(jti, user)\n\n        # Verify token against a wrong user\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        another_user = auth.create_user(\n            {\n                \"email\": faker.ascii_email(),\n                \"name\": \"Default\",\n                \"surname\": \"User\",\n                \"password\": faker.password(strong=True),\n                \"last_password_change\": datetime.now(pytz.utc),\n            },\n            # It will be expanded with the default role\n            roles=[],\n            group=group,\n        )\n        auth.save_user(another_user)\n\n        assert not auth.verify_token_validity(jti, another_user)\n\n    @staticmethod\n    def test_users_groups_roles(faker: Faker) -> None:\n        auth = Connector.get_authentication_instance()\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        group = auth.get_group(name=\"Default\")\n        assert user is not None\n\n        user = auth.get_user(user_id=user.uuid)\n        assert user is not None\n\n        user = auth.get_user(username=\"invalid\")\n        assert user is None\n\n        user = auth.get_user(user_id=\"invalid\")\n        assert user is None\n\n        user = auth.get_user(username=None, user_id=None)\n        assert user is None\n\n        # Test the precedence, username valid  and user invalid => user\n        user = auth.get_user(\n            username=BaseAuthentication.default_user, user_id=\"invalid\"\n        )\n        assert user is not None\n\n        # Test the precedence, username invalid and user valid => None\n        user = auth.get_user(username=\"invalid\", user_id=user.uuid)\n        assert user is None\n\n        assert auth.get_user(None, None) is None\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user is not None\n        assert not auth.save_user(None)\n        assert auth.save_user(user)\n        assert not auth.delete_user(None)\n\n        assert auth.get_group(None, None) is None\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert group is not None\n        assert not auth.save_group(None)\n        assert auth.save_group(group)\n        assert not auth.delete_group(None)\n\n        # None user has no roles ... verify_roles will always be False\n        assert not auth.verify_roles(None, [\"A\", \"B\"], required_roles=\"invalid\")\n        assert not auth.verify_roles(None, [\"A\", \"B\"], required_roles=\"ALL\")\n        assert not auth.verify_roles(None, [\"A\", \"B\"], required_roles=\"ANY\")\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user is not None\n        group = auth.get_group(name=\"Default\")\n        assert group is not None\n\n        assert not auth.delete_user(None)\n        assert not auth.delete_group(None)\n\n        # Delete default user, default group and all users belonging to it\n        members = auth.get_group_members(group)\n        for u in members:\n            assert auth.delete_user(u)\n        assert auth.delete_user(user)\n        assert auth.delete_group(group)\n\n        # Verify that both user and group are now deleted\n        assert auth.get_user(username=BaseAuthentication.default_user) is None\n        assert auth.get_group(name=\"Default\") is None\n\n        # init_auth_db should restore missing default user and group.\n        # But previous tests created additional users and groups, so that\n        # the init auth db without force flags is not able to re-add\n        # the missing and user and group\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\"):\n            auth.init_auth_db({})\n            assert auth.get_user(username=BaseAuthentication.default_user) is None\n            assert auth.get_group(name=\"Default\") is None\n\n        # Let's add the force flags to re-create the default user and group\n        auth.init_auth_db({\"force_user\": True, \"force_group\": True})\n        assert auth.get_user(username=BaseAuthentication.default_user) is not None\n        assert auth.get_group(name=\"Default\") is not None\n\n        # Let's save the current password to be checked later\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        # expected_pwd = user.password\n        # Let's verify that the user now is ADMIN\n        assert Role.ADMIN.value in auth.get_roles_from_user(user)\n\n        # Modify default user and group\n        # # Change name, password and roles\n        user.name = \"Changed\"\n        # user.password = BaseAuthentication.get_password_hash(\"new-pwd#2!\")\n        auth.link_roles(user, [Role.USER.value])\n        auth.save_user(user)\n\n        # Change fullname (not the shortname, since it is the primary key)\n        group = auth.get_group(name=\"Default\")\n        group.fullname = \"Changed\"\n        auth.save_group(group)\n\n        # Verify that user and group are changed\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user.name == \"Changed\"\n        # assert user.password != expected_pwd\n        assert Role.ADMIN.value not in auth.get_roles_from_user(user)\n        assert Role.USER.value in auth.get_roles_from_user(user)\n\n        group = auth.get_group(name=\"Default\")\n        assert group.fullname == \"Changed\"\n\n        roles: list[RoleObj] = auth.get_roles()\n        assert isinstance(roles, list)\n        assert len(roles) > 0\n\n        # Pick one of the default roles and change the description\n        role: RoleObj = roles[0]\n        assert role is not None\n        default_name = role.name\n        default_description = role.description\n        new_description = faker.pystr()\n        role.description = new_description\n        assert auth.save_role(role)\n        assert not auth.save_role(None)\n\n        # Create a new custom role\n        new_role_name = faker.pystr()\n        new_role_descr = faker.pystr()\n        auth.create_role(name=new_role_name, description=new_role_descr)\n\n        # Verify the change on the roles and the creation of the new one\n        for r in auth.get_roles():\n            if r.name == default_name:\n                assert r.description == new_description\n                assert r.description != default_description\n\n            if r.name == new_role_name:\n                assert r.description == new_role_descr\n\n        # Verify that duplicated role names are refused at init time\n        roles_data_backup = auth.roles_data\n        auth.roles_data = {\n            \"admin_root\": \"Admin\",\n            \"staff_user\": \"Coordinator\",\n            \"group_coordinator\": \"Coordinator\",\n            \"normal_user\": \"User\",\n        }\n        with pytest.raises(SystemExit):\n            auth.init_roles()\n\n        auth.roles_data = roles_data_backup\n\n        # Verify that init_roles restores description of default roles\n        # While custom roles are not modified\n        auth.init_roles()\n\n        for r in auth.get_roles():\n            # default description restored for this default role\n            if r.name == default_name:\n                assert r.description != new_description\n                assert r.description == default_description\n\n            # custom additional role not modified by init roles\n            if r.name == new_role_name:\n                assert r.description == new_role_descr\n\n        # Verify init without force flag will not restore default user and group\n        auth.init_auth_db({})\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user.name == \"Changed\"\n        # assert user.password != expected_pwd\n        assert Role.ADMIN.value not in auth.get_roles_from_user(user)\n        assert Role.USER.value in auth.get_roles_from_user(user)\n\n        group = auth.get_group(name=\"Default\")\n        assert group.fullname == \"Changed\"\n\n        # Verify init with force flag will not restore the default user and group\n        auth.init_auth_db({\"force_user\": True, \"force_group\": True})\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user.name != \"Changed\"\n        # assert user.password == expected_pwd\n        assert Role.ADMIN.value in auth.get_roles_from_user(user)\n        assert Role.USER.value in auth.get_roles_from_user(user)\n\n        group = auth.get_group(name=\"Default\")\n        assert group.fullname != \"Changed\"\n\n    @staticmethod\n    def test_authentication_abstract_methods(faker: Faker) -> None:\n        # Super trick!\n        # https://clamytoe.github.io/articles/2020/Mar/12/testing-abcs-with-abstract-methods-with-pytest\n        abstractmethods = BaseAuthentication.__abstractmethods__\n        BaseAuthentication.__abstractmethods__ = frozenset()\n\n        auth = Connector.get_authentication_instance()\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        role = auth.get_roles()[0]\n\n        auth = BaseAuthentication()  # type: ignore\n\n        assert (\n            auth.get_user(username=faker.ascii_email(), user_id=faker.pystr()) is None\n        )\n\n        assert auth.get_users() is None\n        assert auth.save_user(user=user) is None\n        assert auth.delete_user(user=user) is None\n\n        assert auth.get_group(group_id=faker.pystr(), name=faker.pystr()) is None\n\n        assert auth.get_groups() is None\n        assert auth.get_user_group(user=user) is None\n\n        assert auth.get_group_members(group=group) is None\n\n        assert auth.save_group(group=group) is None\n\n        assert auth.delete_group(group=group) is None\n\n        assert auth.get_tokens(user=user, token_jti=faker.pystr(), get_all=True) is None\n\n        assert auth.verify_token_validity(jti=faker.pystr(), user=user) is None\n\n        assert (\n            auth.save_token(\n                user=user, token=faker.pystr(), payload={}, token_type=faker.pystr()\n            )\n            is None\n        )\n\n        assert auth.invalidate_token(token=faker.pystr()) is None\n\n        assert auth.get_roles() is None\n\n        assert auth.get_roles_from_user(user=user) is None\n\n        assert auth.create_role(name=faker.pystr(), description=faker.pystr()) is None\n        assert auth.save_role(role=role) is None\n\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert auth.create_user(userdata={}, roles=[faker.pystr()], group=group) is None\n\n        assert auth.link_roles(user=user, roles=[faker.pystr()]) is None\n        assert auth.create_group(groupdata={}) is None\n\n        assert auth.add_user_to_group(user=user, group=group) is None\n\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=user, failed=True)\n            is None\n        )\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=None, failed=True)\n            is None\n        )\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=user, failed=False)\n            is None\n        )\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=None, failed=False)\n            is None\n        )\n\n        assert auth.get_logins(username=faker.ascii_email) is None\n\n        assert auth.flush_failed_logins(username=faker.ascii_email) is None\n\n        BaseAuthentication.__abstractmethods__ = abstractmethods\n", "cache.py": "from typing import Any, Callable\n\nfrom flask import Flask\nfrom flask_caching import Cache as FlaskCache\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.utilities.globals import mem\n\n\nclass Cache:\n    @staticmethod\n    def get_instance(app: Flask) -> FlaskCache:\n        if not Connector.check_availability(\"redis\"):\n            raise ServiceUnavailable(\"Can't enable the cache without Redis\")\n\n        # This check prevents KeyError raised during tests\n        # Exactly as reported here:\n        # https://github.com/sh4nks/flask-caching/issues/191\n        if not hasattr(mem, \"cache\"):\n            redis = Env.load_variables_group(prefix=\"redis\")\n            mem.cache = FlaskCache(\n                config={\n                    \"CACHE_TYPE\": \"RedisCache\",\n                    \"CACHE_REDIS_HOST\": redis.get(\"host\"),\n                    \"CACHE_REDIS_PORT\": redis.get(\"port\"),\n                    \"CACHE_REDIS_PASSWORD\": redis.get(\"password\"),\n                    # Usually 1=celery, 3=celery-beat\n                    \"CACHE_REDIS_DB\": \"2\",\n                }\n            )\n\n        mem.cache.init_app(app)\n\n        return mem.cache\n\n    @staticmethod\n    def clear() -> None:\n        mem.cache.clear()\n\n    # This can be used to invalidate any endpoint, for example:\n    # # 1 - From an endpoint\n    # Cache.invalidate(self.get)\n    # # 2 - import endpoint\n    # from myproject.endpoints.mymodule import MyEndpoint\n    # Cache.invalidate(MyEndpoint.get)\n    # # 3 - With meta\n    # c = Meta.get_class(\"endpoints.mymodule\", \"MyEndpoint\")\n    # Cache.invalidate(c.get)\n    @staticmethod\n    def invalidate(func: Callable[[Any], Any], *args: Any, **kwargs: Any) -> None:\n        mem.cache.delete_memoized(func, *args, **kwargs)\n", "download.py": "import io\nimport os\nimport warnings\n\nfrom faker import Faker\n\nfrom restapi.config import DATA_PATH, PRODUCTION, get_backend_url\nfrom restapi.tests import API_URI, SERVER_URI, BaseTests, FlaskClient\n\n\ndef get_location_header(headers: dict[str, str], expected: str) -> str:\n    assert \"Location\" in headers\n    location = headers[\"Location\"]\n\n    if PRODUCTION:\n        assert location.startswith(\"https://\")\n\n    host = get_backend_url()\n    assert location.startswith(host)\n    location = location.replace(host, SERVER_URI)\n    assert location == expected\n    return location\n\n\nclass TestUploadAndDownload(BaseTests):\n    def test_simple_upload_and_download(\n        self, client: FlaskClient, faker: Faker\n    ) -> None:\n        warnings.filterwarnings(\n            \"ignore\", message=\"unclosed file <_io.BufferedReader name=\"\n        )\n        self.fcontent = faker.paragraph()\n        self.save(\"fcontent\", self.fcontent)\n        # as defined in test_upload.py for normal uploads\n        upload_folder = \"fixsubfolder\"\n\n        self.fname = f\"{faker.pystr()}.notallowed\"\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname),\n                # By setting force False only txt files will be allowed for upload\n                # Strange, but it is how the endpoint is configured to improve the tests\n                \"force\": False,\n            },\n        )\n        assert r.status_code == 400\n        assert self.get_content(r) == \"File extension not allowed\"\n\n        self.fname = f\"{faker.pystr()}.txt\"\n        self.save(\"fname\", self.fname)\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname),\n                # By setting force False only txt files will be allowed for upload\n                # Strange, but it is how the endpoint is configured to improve the tests\n                \"force\": False,\n            },\n        )\n        assert r.status_code == 200\n\n        destination_path = DATA_PATH.joinpath(upload_folder, self.fname)\n        assert destination_path.exists()\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname)},\n        )\n        assert r.status_code == 409\n        err = f\"File '{self.fname}' already exists, use force parameter to overwrite\"\n        assert self.get_content(r) == err\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname),\n                \"force\": True,\n            },\n        )\n        assert r.status_code == 200\n\n        destination_path = DATA_PATH.joinpath(upload_folder, self.fname)\n        assert destination_path.exists()\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"filename\") == self.fname\n        meta = c.get(\"meta\")\n        assert meta is not None\n        assert meta.get(\"charset\") is not None\n        assert meta.get(\"type\") is not None\n\n        self.fname = self.get(\"fname\")\n        self.fcontent = self.get(\"fcontent\")\n        # as defined in test_upload.py for normal uploads\n        upload_folder = \"fixsubfolder\"\n\n        r = client.get(f\"{API_URI}/tests/download/folder/doesnotexist\")\n        assert r.status_code == 404\n        assert self.get_content(r) == \"The requested file does not exist\"\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{self.fname}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == self.fcontent\n\n        new_content = \"new content\"\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(new_content)), self.fname),\n                \"force\": True,\n            },\n        )\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{self.fname}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content != self.fcontent\n        assert content == new_content\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{self.fname}\",\n            query_string={\"stream\": True},\n        )\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == new_content\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/doesnotexist\",\n            query_string={\"stream\": True},\n        )\n        assert r.status_code == 404\n\n    def test_chunked_upload_and_download(\n        self, client: FlaskClient, faker: Faker\n    ) -> None:\n        warnings.filterwarnings(\n            \"ignore\", message=\"unclosed file <_io.BufferedReader name=\"\n        )\n\n        self.fname = self.get(\"fname\")\n        self.fcontent = self.get(\"fcontent\")\n\n        # as defined in test_upload.py for chunked uploads\n        upload_folder = \"fixed\"\n\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data={\"force\": True})\n        assert r.status_code == 400\n\n        filename = \"fixed.filename.txt\"\n        data = {\n            \"force\": True,\n            \"name\": filename,\n            \"size\": \"999\",\n            \"mimeType\": \"application/zip\",\n            \"lastModified\": 1590302749209,\n        }\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 201\n        assert self.get_content(r) == \"\"\n        upload_endpoint = get_location_header(\n            r.headers, expected=f\"{API_URI}/tests/chunkedupload/{filename}\"\n        )\n\n        data[\"force\"] = False\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 409\n        assert self.get_content(r) == f\"File '{filename}' already exists\"\n\n        with io.StringIO(faker.text()) as f:\n            r = client.put(upload_endpoint, data=f)\n        assert r.status_code == 400\n        assert self.get_content(r) == \"Invalid request\"\n\n        with io.StringIO(faker.text()) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": \"!\"},\n            )\n        assert r.status_code == 400\n        assert self.get_content(r) == \"Invalid request\"\n\n        up_data = faker.pystr(min_chars=24, max_chars=48).lower()\n        STR_LEN = len(up_data)\n        with io.StringIO(up_data[0:5]) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes 0-5/{STR_LEN}\"},\n            )\n        assert r.status_code == 206\n        assert self.get_content(r) == \"partial\"\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert destination_path.exists()\n        # The file is still writeable because the upload is in progress\n        assert oct(os.stat(destination_path).st_mode & 0o777) != \"0o440\"\n\n        with io.StringIO(up_data[5:]) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes 5-{STR_LEN}/{STR_LEN}\"},\n            )\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"filename\") is not None\n        uploaded_filename = c.get(\"filename\")\n        meta = c.get(\"meta\")\n        assert meta is not None\n        assert meta.get(\"charset\") == \"us-ascii\"\n        assert meta.get(\"type\") == \"text/plain\"\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert destination_path.exists()\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": \"\"},\n        )\n        assert r.status_code == 416\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": f\"0-{STR_LEN - 1}\"},\n        )\n        assert r.status_code == 416\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": \"bytes=0-9999999999999999\"},\n        )\n        assert r.status_code == 206\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": \"bytes=0-4\"},\n        )\n        assert r.status_code == 206\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data[0:5]\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": f\"bytes=5-{STR_LEN - 1}\"},\n        )\n        assert r.status_code == 206\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data[5:]\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": f\"bytes=0-{STR_LEN - 1}\"},\n        )\n        assert r.status_code == 206\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data\n\n        # Send a new string as content file. Will be appended as prefix\n        up_data2 = faker.pystr(min_chars=24, max_chars=48)\n        STR_LEN = len(up_data2)\n        with io.StringIO(up_data2) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes */{STR_LEN}\"},\n            )\n        assert r.status_code == 503\n        assert self.get_content(r) == \"Permission denied: failed to write the file\"\n\n        # force the file to be writeable again\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        # -rw-rw----\n        destination_path.chmod(0o660)\n\n        with io.StringIO(up_data2) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes */{STR_LEN}\"},\n            )\n\n        assert r.status_code == 200\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert destination_path.exists()\n        # File permissions are restored\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        # c = self.get_content(r)\n        # assert c.get('filename') is not None\n        # uploaded_filename = c.get('filename')\n        # meta = c.get('meta')\n        # assert meta is not None\n        # assert meta.get('charset') == 'us-ascii'\n        # assert meta.get('type') == 'text/plain'\n\n        # r = client.get(\n        #     f'{API_URI}/tests/download/{upload_folder}/{uploaded_filename}'\n        # )\n        # assert r.status_code == 200\n        # content = r.data.decode('utf-8')\n        # # Uhmmm... should not be up_data2 + up_data ??\n        # assert content == up_data + up_data2\n\n        data[\"force\"] = False\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 409\n        err = f\"File '{uploaded_filename}' already exists\"\n        assert self.get_content(r) == err\n\n        data[\"force\"] = True\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 201\n        assert self.get_content(r) == \"\"\n        upload_endpoint = get_location_header(\n            r.headers, expected=f\"{API_URI}/tests/chunkedupload/{filename}\"\n        )\n\n        data[\"name\"] = \"fixed.filename.notallowed\"\n        data[\"force\"] = False\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 400\n        assert self.get_content(r) == \"File extension not allowed\"\n\n        # Send an upload on a file endpoint not previously initialized\n        filename = f\"{faker.pystr()}.txt\"\n        with io.StringIO(up_data2) as f:\n            r = client.put(\n                f\"{API_URI}/tests/chunkedupload/{filename}\",\n                data=f,\n                headers={\"Content-Range\": f\"bytes */{STR_LEN}\"},\n            )\n\n        assert r.status_code == 503\n        error = \"Permission denied: the destination file does not exist\"\n        assert self.get_content(r) == error\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert not destination_path.exists()\n", "uploader.py": "from pathlib import Path\nfrom typing import Optional\n\nfrom flask import request\nfrom plumbum.cmd import file\nfrom werkzeug.http import parse_content_range_header\nfrom werkzeug.utils import secure_filename\n\nfrom restapi.config import DATA_PATH, get_backend_url\nfrom restapi.exceptions import BadRequest, Conflict, Forbidden, ServiceUnavailable\nfrom restapi.rest.definition import EndpointResource, Response\nfrom restapi.utilities.logs import log\n\n# Equivalent to -r--r-----\nDEFAULT_PERMISSIONS = 0o440\n\n\nclass Uploader:\n    allowed_exts: list[str] = []\n\n    def set_allowed_exts(self, exts: list[str]) -> None:\n        self.allowed_exts = exts\n\n    def allowed_file(self, filename: str) -> bool:\n        if not self.allowed_exts:\n            return True\n        return (\n            \".\" in filename and filename.rsplit(\".\", 1)[1].lower() in self.allowed_exts\n        )\n\n    @staticmethod\n    def validate_upload_folder(path: Path) -> None:\n        if \"\\x00\" in str(path):\n            raise BadRequest(\"Invalid null byte in subfolder parameter\")\n\n        if path != path.resolve():\n            log.error(\"Invalid path: path is relative or contains double-dots\")\n            raise Forbidden(\"Invalid file path\")\n\n        if path != DATA_PATH and DATA_PATH not in path.parents:\n            log.error(\n                \"Invalid root path: {} is expected to be a child of {}\",\n                path,\n                DATA_PATH,\n            )\n            raise Forbidden(\"Invalid file path\")\n\n    @staticmethod\n    def get_file_metadata(abs_file: Path) -> dict[str, str]:\n        try:\n            # Check the type\n            # Example of output:\n            # text/plain; charset=us-ascii\n            out = file[\"-ib\", str(abs_file)]().split(\";\")\n            return {\"type\": out[0].strip(), \"charset\": out[1].split(\"=\")[1].strip()}\n        except Exception:\n            log.warning(\"Unknown type for '{}'\", abs_file)\n            return {}\n\n    # this method is used by mistral\n    def upload(self, subfolder: Path, force: bool = False) -> Response:\n        if \"file\" not in request.files:\n            raise BadRequest(\"No files specified\")  # pragma: no cover\n\n        myfile = request.files[\"file\"]\n\n        if not myfile.filename:  # pragma: no cover\n            raise BadRequest(\"Invalid filename\")\n\n        if not self.allowed_file(myfile.filename):\n            raise BadRequest(\"File extension not allowed\")\n\n        Uploader.validate_upload_folder(subfolder)\n\n        if not subfolder.exists():\n            subfolder.mkdir(parents=True, exist_ok=True)\n\n        fname = secure_filename(myfile.filename)\n        abs_file = subfolder.joinpath(fname)\n\n        log.info(\"File request for [{}]({})\", myfile, abs_file)\n\n        if abs_file.exists():\n            if not force:\n                raise Conflict(\n                    f\"File '{fname}' already exists, use force parameter to overwrite\"\n                )\n            abs_file.unlink()\n\n        # Save the file\n        try:\n            myfile.save(abs_file)\n            log.debug(\"Absolute file path should be '{}'\", abs_file)\n        except Exception as e:  # pragma: no cover\n            log.error(e)\n            raise ServiceUnavailable(\n                \"Permission denied: failed to write the file\"\n            ) from e\n\n        # Check exists - but it is basicaly a test that cannot fail...\n        # The has just been uploaded!\n        if not abs_file.exists():  # pragma: no cover\n            raise ServiceUnavailable(\"Unable to retrieve the uploaded file\")\n\n        ########################\n        # ## Final response\n\n        abs_file.chmod(DEFAULT_PERMISSIONS)\n\n        # Default redirect is to 302 state, which makes client\n        # think that response was unauthorized....\n        # see http://dotnet.dzone.com/articles/getting-know-cross-origin\n\n        return EndpointResource.response(\n            {\"filename\": fname, \"meta\": self.get_file_metadata(abs_file)},\n            code=200,\n        )\n\n    # Compatible with\n    # https://developers.google.com/drive/api/v3/manage-uploads#resumable\n    # and with https://www.npmjs.com/package/ngx-uploadx and with\n    def init_chunk_upload(\n        self, upload_dir: Path, filename: str, force: bool = True\n    ) -> Response:\n        if not self.allowed_file(filename):\n            raise BadRequest(\"File extension not allowed\")\n\n        Uploader.validate_upload_folder(upload_dir)\n\n        if not upload_dir.exists():\n            upload_dir.mkdir(parents=True, exist_ok=True)\n\n        filename = secure_filename(filename)\n\n        file_path = upload_dir.joinpath(filename)\n\n        if file_path.exists():\n            log.warning(\"File already exists\")\n            if force:\n                file_path.unlink()\n                log.debug(\"Forced removal\")\n            else:\n                raise Conflict(f\"File '{filename}' already exists\")\n\n        file_path.touch()\n\n        host = get_backend_url()\n        url = f\"{host}{request.path}/{filename}\"\n\n        log.info(\"Upload initialized on url: {}\", url)\n\n        return EndpointResource.response(\n            \"\",\n            headers={\"Access-Control-Expose-Headers\": \"Location\", \"Location\": url},\n            code=201,\n        )\n\n    @staticmethod\n    def parse_content_range(\n        range_header: Optional[str],\n    ) -> tuple[Optional[int], Optional[int], Optional[int]]:\n        if range_header is None:\n            return None, None, None\n\n        content_range = parse_content_range_header(range_header)\n\n        if content_range is None:\n            log.error(\"Unable to parse Content-Range: {}\", range_header)\n            tokens = range_header.split(\"/\")\n\n            if len(tokens) != 2:\n                log.error(\"Invalid Content-Range: {}\", range_header)\n                return None, None, None\n\n            if not tokens[1].isnumeric():\n                log.error(\"Invalid Content-Range: {}\", range_header)\n                return None, None, None\n\n            # A pattern like */len is expected\n            # => is returned start == 0 and stop == len\n            tot_len = int(tokens[1])\n            return tot_len, 0, tot_len\n\n        total_length = content_range.length\n        # es: 'bytes */35738983'\n        if content_range.start is None:\n            start = 0\n        else:\n            start = content_range.start\n\n        if content_range.stop is None:\n            stop = total_length\n        else:\n            stop = content_range.stop\n\n        return total_length, start, stop\n\n    # Please note that chunk_upload as to be used from a PUT endpoint\n    # PUT request is way different compared to POST request. With PUT request\n    # the file contents can be accessed using either request.data or request.stream.\n    # The first one stores incoming data as string, while request.stream acts\n    # more like a file object, making it more suitable for binary data\n    # Ref. http://stackoverflow.com/a/9533843/2114395\n    def chunk_upload(\n        self, upload_dir: Path, filename: str, chunk_size: Optional[int] = None\n    ) -> tuple[bool, Response]:\n        Uploader.validate_upload_folder(upload_dir)\n\n        filename = secure_filename(filename)\n\n        range_header = request.headers.get(\"Content-Range\", \"\")\n        total_length, start, stop = self.parse_content_range(range_header)\n\n        if total_length is None or start is None or stop is None:\n            raise BadRequest(\"Invalid request\")\n\n        completed = stop >= total_length\n\n        # Default chunk size, put this somewhere\n        if chunk_size is None:\n            chunk_size = 1048576\n\n        file_path = upload_dir.joinpath(filename)\n\n        # Uhm... this upload is not initialized?\n        if not file_path.exists():\n            raise ServiceUnavailable(\n                \"Permission denied: the destination file does not exist\"\n            )\n\n        try:\n            with open(file_path, \"ab\") as f:\n                while True:\n                    chunk = request.stream.read(chunk_size)\n                    if not chunk:\n                        break\n                    f.seek(start)\n                    f.write(chunk)\n        except PermissionError as e:\n            raise ServiceUnavailable(\n                \"Permission denied: failed to write the file\"\n            ) from e\n\n        if completed:\n            file_path.chmod(DEFAULT_PERMISSIONS)\n            return (\n                completed,\n                EndpointResource.response(\n                    {\"filename\": filename, \"meta\": self.get_file_metadata(file_path)},\n                    code=200,\n                ),\n            )\n\n        return (\n            completed,\n            EndpointResource.response(\n                \"partial\",\n                headers={\n                    \"Access-Control-Expose-Headers\": \"Range\",\n                    \"Range\": f\"0-{stop - 1}\",\n                },\n                code=206,\n            ),\n        )\n", "index.html": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <title>HTTP-API</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, maximum-scale=1.0\"\n    />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <meta name=\"description\" content=\"\" />\n    <meta name=\"author\" content=\"\" />\n    <style>\n      .red {\n        color: red;\n      }\n    </style>\n  </head>\n  <body>\n    {% if is_error %}\n\n    <main class=\"red\">{{ body_content }}<br /></main>\n\n    {% elif body_content is mapping %} {% for key, value in body_content.items()\n    %}\n    <strong>{{ key }}</strong>: {{ value }}<br />\n    {% endfor %} {% else %}\n    <main>{{ body_content }}</main>\n    {% endif %}\n  </body>\n</html>\n", "tests.py": "\"\"\"\nBase class for unit tests\n\"\"\"\n\nimport base64\nimport os\nimport re\nimport urllib.parse\nimport uuid\nfrom collections import namedtuple\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Any, Optional, TypedDict, Union, cast\n\nimport jwt\nimport orjson\nimport pyotp\nimport pytest\nimport pytz\nfrom faker import Faker\nfrom flask import Flask\nfrom flask.testing import FlaskClient\nfrom werkzeug.test import TestResponse as Response\n\nfrom restapi.config import (\n    API_URL,\n    AUTH_URL,\n    CODE_DIR,\n    DEFAULT_HOST,\n    DEFAULT_PORT,\n    JWT_SECRET_FILE,\n    get_frontend_url,\n)\nfrom restapi.connectors import Connector, celery\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication, Role\nfrom restapi.utilities.faker import get_faker\nfrom restapi.utilities.logs import LOGS_FOLDER, Events, log\n\n\nclass MockedEmail(TypedDict):\n    # from: str\n    cc: list[str]\n    msg: str\n    # body and headers are added by read_mock_email function\n    body: str\n    headers: str\n\n\nSERVER_URI = f\"http://{DEFAULT_HOST}:{DEFAULT_PORT}\"\nAPI_URI = f\"{SERVER_URI}{API_URL}\"\nAUTH_URI = f\"{SERVER_URI}{AUTH_URL}\"\n\nEvent = namedtuple(\n    \"Event\",\n    [\"date\", \"ip\", \"user\", \"event\", \"target_type\", \"target_id\", \"url\", \"payload\"],\n)\n\n\n@contextmanager\ndef execute_from_code_dir() -> Generator[None, None, None]:\n    \"\"\"Sets the cwd within the context\"\"\"\n\n    origin = Path().absolute()\n    try:\n        os.chdir(CODE_DIR)\n        yield\n    finally:\n        os.chdir(origin)\n\n\nclass BaseTests:\n    faker: Faker = get_faker()\n    # This will store credentials to be used to test unused credentials ban\n    # tuple = (email, password, uuid)\n    unused_credentials: Optional[tuple[str, str, str]] = None\n\n    @classmethod\n    def save(cls, variable: str, value: Any) -> None:\n        \"\"\"\n        Save a variable in the class, to be re-used in further tests\n        \"\"\"\n\n        setattr(cls, variable, value)\n\n    @classmethod\n    def get(cls, variable: str) -> Any:\n        \"\"\"\n        Retrieve a previously stored variable using the .save method\n        \"\"\"\n        if hasattr(cls, variable):\n            return getattr(cls, variable)\n\n        raise AttributeError(f\"Class variable {variable} not found\")  # pragma: no cover\n\n    @staticmethod\n    def get_dynamic_input_schema(\n        client: FlaskClient,\n        endpoint: str,\n        headers: Optional[dict[str, str]],\n        method: str = \"post\",\n    ) -> list[dict[str, Any]]:\n        \"\"\"\n        Retrieve a dynamic data schema associated with a endpoint\n        \"\"\"\n\n        method = method.lower()\n\n        if method == \"post\":\n            r = client.post(\n                f\"{API_URI}/{endpoint}\", json={\"get_schema\": 1}, headers=headers\n            )\n        else:\n            r = client.put(\n                f\"{API_URI}/{endpoint}\", json={\"get_schema\": 1}, headers=headers\n            )\n\n        assert r.status_code == 200\n\n        schema = orjson.loads(r.data.decode(\"utf-8\"))\n        assert isinstance(schema, list)\n        for f in schema:\n            assert isinstance(f, dict)\n        return schema\n\n    @staticmethod\n    def get_content(\n        http_out: Response,\n    ) -> Union[str, float, int, bool, list[Any], dict[str, Any]]:\n        try:\n            response = orjson.loads(http_out.get_data().decode())\n            if isinstance(\n                response,\n                (\n                    str,\n                    bool,\n                    float,\n                    int,\n                    list,\n                    dict,\n                ),\n            ):\n                return response\n\n            raise ValueError(  # pragma: no cover\n                f\"Unknown response type: {type(response)}\"\n            )\n        except Exception as e:  # pragma: no cover\n            log.error(\"Failed to load response:\\n{}\", e)\n            raise ValueError(f\"Malformed response: {http_out}\") from e\n\n    @staticmethod\n    def generate_totp(email: Optional[str]) -> str:\n        assert email is not None\n        auth = Connector.get_authentication_instance()\n\n        user = auth.get_user(username=email.lower())\n\n        secret = auth.get_totp_secret(user)\n\n        return pyotp.TOTP(secret).now()\n\n    @classmethod\n    def do_login(\n        cls,\n        client: FlaskClient,\n        USER: Optional[str],\n        PWD: Optional[str],\n        status_code: int = 200,\n        data: Optional[dict[str, Any]] = None,\n        test_failures: bool = False,\n    ) -> tuple[Optional[dict[str, str]], str]:\n        \"\"\"\n        Make login and return both token and authorization header\n        \"\"\"\n\n        if not Connector.check_availability(\"authentication\"):  # pragma: no cover\n            pytest.fail(\"Authentication is not enabled\")\n\n        if USER is None or PWD is None:\n            BaseAuthentication.load_default_user()\n            BaseAuthentication.load_roles()\n        if USER is None:\n            USER = BaseAuthentication.default_user\n        if PWD is None:\n            PWD = BaseAuthentication.default_password\n\n        assert USER is not None\n        assert PWD is not None\n\n        if data is None:\n            data = {}\n\n        data[\"username\"] = USER\n        data[\"password\"] = PWD\n\n        r = client.post(f\"{AUTH_URI}/login\", json=data)\n        content = orjson.loads(r.data.decode(\"utf-8\"))\n\n        if r.status_code == 403:\n            # This 403 is expected, return an invalid value or you can enter a loop!\n            if status_code == 403:\n                return None, content\n\n            if isinstance(content, dict) and content.get(\"actions\"):\n                actions = content.get(\"actions\", [])\n\n                for action in actions:\n                    if action == \"TOTP\":\n                        continue\n                    if action == \"FIRST LOGIN\":\n                        continue\n                    if action == \"PASSWORD EXPIRED\":\n                        continue\n\n                data = {}\n\n                if \"FIRST LOGIN\" in actions or \"PASSWORD EXPIRED\" in actions:\n                    events = cls.get_last_events(1)\n                    assert events[0].event == Events.password_expired.value\n                    # assert events[0].user == USER\n\n                    newpwd = cls.faker.password(strong=True)\n                    if test_failures:\n                        data[\"new_password\"] = newpwd\n                        data[\"password_confirm\"] = cls.faker.password(strong=True)\n                        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n                            data[\"totp_code\"] = BaseTests.generate_totp(USER)\n\n                        BaseTests.do_login(\n                            client,\n                            USER,\n                            PWD,\n                            data=data,\n                            status_code=409,\n                        )\n\n                        # Test failure of password change if TOTP is wrong or missing\n                        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n                            data[\"new_password\"] = newpwd\n                            data[\"password_confirm\"] = newpwd\n                            data.pop(\"totp_code\", None)\n\n                            BaseTests.do_login(\n                                client,\n                                USER,\n                                PWD,\n                                data=data,\n                                status_code=403,\n                            )\n\n                            data[\"new_password\"] = newpwd\n                            data[\"password_confirm\"] = newpwd\n                            # random int with 6 digits\n                            data[\"totp_code\"] = str(\n                                cls.faker.pyint(min_value=100000, max_value=999999)\n                            )\n                            BaseTests.do_login(\n                                client,\n                                USER,\n                                PWD,\n                                data=data,\n                                status_code=401,\n                            )\n\n                    # Change the password to silence FIRST_LOGIN and PASSWORD_EXPIRED\n                    data[\"new_password\"] = newpwd\n                    data[\"password_confirm\"] = newpwd\n                    if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n                        data[\"totp_code\"] = BaseTests.generate_totp(USER)\n                    BaseTests.do_login(\n                        client,\n                        USER,\n                        PWD,\n                        data=data,\n                    )\n                    # Change again to restore the default password\n                    # and keep all other tests fully working\n                    data[\"new_password\"] = PWD\n                    data[\"password_confirm\"] = PWD\n                    if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n                        data[\"totp_code\"] = BaseTests.generate_totp(USER)\n                    return BaseTests.do_login(\n                        client,\n                        USER,\n                        newpwd,\n                        data=data,\n                    )\n\n                # in this case FIRST LOGIN has not been executed\n                # => login by sending the TOTP code\n                if \"TOTP\" in actions:\n                    # Only directly tested => no coverage\n                    if test_failures:  # pragma: no cover\n                        # random int with 6 digits\n                        data[\"totp_code\"] = cls.faker.pyint(\n                            min_value=100000, max_value=999999\n                        )\n                        BaseTests.do_login(\n                            client,\n                            USER,\n                            PWD,\n                            data=data,\n                            status_code=401,\n                        )\n\n                    data[\"totp_code\"] = BaseTests.generate_totp(USER)\n                    return BaseTests.do_login(\n                        client,\n                        USER,\n                        PWD,\n                        data=data,\n                    )\n\n        # FOR DEBUGGING WHEN ADVANCED AUTH OPTIONS ARE ON\n        # if r.status_code != 200:\n        #     c = orjson.loads(r.data.decode(\"utf-8\"))\n        #     log.error(c)\n\n        assert r.status_code == status_code\n\n        # when 200 OK content is the token\n        assert content is not None\n\n        return {\"Authorization\": f\"Bearer {content}\"}, content\n\n    @classmethod\n    def create_user(\n        cls,\n        client: FlaskClient,\n        data: Optional[dict[str, Any]] = None,\n        roles: Optional[list[Union[str, Role]]] = None,\n        group: Optional[str] = None,\n    ) -> tuple[str, dict[str, Any]]:\n        assert Env.get_bool(\"MAIN_LOGIN_ENABLE\")\n\n        admin_headers, _ = cls.do_login(client, None, None)\n        assert admin_headers is not None\n        schema = cls.get_dynamic_input_schema(client, \"admin/users\", admin_headers)\n        user_data = cls.buildData(schema)\n        if Connector.check_availability(\"smtp\"):\n            user_data[\"email_notification\"] = False\n        user_data[\"is_active\"] = True\n        user_data[\"expiration\"] = None\n\n        if group:\n            user_data[\"group\"] = group\n\n        if roles:\n            for idx, role in enumerate(roles):\n                if isinstance(role, Role):\n                    roles[idx] = role.value\n\n            user_data[\"roles\"] = orjson.dumps(roles).decode(\"UTF8\")\n\n        if data:\n            user_data.update(data)\n\n        r = client.post(f\"{API_URI}/admin/users\", json=user_data, headers=admin_headers)\n        assert r.status_code == 200\n        uuid = cls.get_content(r)\n        assert isinstance(uuid, str)\n\n        return uuid, user_data\n\n    @classmethod\n    def delete_user(cls, client: FlaskClient, uuid: str) -> None:\n        assert Env.get_bool(\"MAIN_LOGIN_ENABLE\")\n\n        admin_headers, _ = cls.do_login(client, None, None)\n        assert admin_headers is not None\n        r = client.delete(f\"{API_URI}/admin/users/{uuid}\", headers=admin_headers)\n        assert r.status_code == 204\n\n    @classmethod\n    def create_group(\n        cls, client: FlaskClient, data: Optional[dict[str, Any]] = None\n    ) -> tuple[str, dict[str, Any]]:\n        assert Env.get_bool(\"MAIN_LOGIN_ENABLE\")\n\n        admin_headers, _ = cls.do_login(client, None, None)\n        assert admin_headers is not None\n        schema = cls.get_dynamic_input_schema(client, \"admin/groups\", admin_headers)\n        group_data = cls.buildData(schema)\n        if data:\n            group_data.update(data)\n        r = client.post(\n            f\"{API_URI}/admin/groups\", json=group_data, headers=admin_headers\n        )\n        assert r.status_code == 200\n        uuid = cls.get_content(r)\n        assert isinstance(uuid, str)\n\n        return uuid, group_data\n\n    # Simple wrappers to ensure names and surnames longer than 3 characters\n    # Note: short names/surnamed are not verified for password strenght checks\n    @classmethod\n    def get_first_name(cls, faker: Faker, recursion: int = 0) -> str:\n        # Please Faker, add some types hints and let me remove this str()!\n        name = str(faker.first_name())\n        if len(name) > 3:\n            return name\n\n        # Probably this Faker locale only has very short names.\n        # It can happens with Chinese?\n        # Let's return a repetition of the name it self\n        if recursion >= 10:  # pragma: no cover\n            return name * 4\n        return cls.get_first_name(faker, recursion=recursion + 1)  # pragma: no cover\n\n    @classmethod\n    def get_last_name(cls, faker: Faker, recursion: int = 0) -> str:\n        # Please Faker, add some types hints and let me remove this str()!\n        surname = str(faker.last_name())\n        if len(surname) > 3:\n            # Please Faker, add some types hints!\n            return surname\n        # Probably this Faker locale only has very short names.\n        # It can happens with Chinese?\n        # Let's return a repetition of the name it self\n        if recursion >= 10:  # pragma: no cover\n            return surname * 4\n        return cls.get_last_name(faker, recursion=recursion + 1)  # pragma: no cover\n\n    @classmethod\n    def get_random_email(\n        cls, faker: Faker, name: str, surname: str, recursion: int = 0\n    ) -> str:\n        # Please Faker, add some types hints and let me remove this str()!\n        email = str(faker.ascii_email())\n\n        # This email contains the name, re-sampling again\n        if name.lower() in email.lower():  # pragma: no cover\n            return cls.get_random_email(faker, name, surname, recursion=recursion + 1)\n\n        # This email contains the surname, re-sampling again\n        if surname.lower() in email.lower():  # pragma: no cover\n            return cls.get_random_email(faker, name, surname, recursion=recursion + 1)\n\n        email_tokens = email.split(\"@\")\n        email_username = email_tokens[0]\n        if len(email_username) > 3:\n            # Please Faker, add some types hints!\n            return email\n\n        # Probably this Faker locale only has very short emails.\n        # It can happens with Chinese?\n        # Let's return a repetition of the name it self\n        if recursion >= 10:  # pragma: no cover\n            return f\"{email_username * 4}@{email_tokens[1]}\"\n\n        return cls.get_random_email(  # pragma: no cover\n            faker, surname, surname, recursion=recursion + 1\n        )\n\n    @classmethod\n    def buildData(cls, schema: list[dict[str, Any]]) -> dict[str, Any]:\n        \"\"\"\n        Input: a Marshmallow schema\n        Output: a dictionary of random data\n        \"\"\"\n        data: dict[str, Any] = {}\n        for d in schema:\n            assert \"key\" in d\n            assert \"type\" in d\n\n            key = d.get(\"key\")\n            field_type = d.get(\"type\")\n\n            assert key is not None\n            assert field_type is not None\n\n            if is_array := field_type.endswith(\"[]\"):\n                field_type = field_type.removesuffix(\"[]\")\n\n            if \"options\" in d:\n                assert isinstance(d[\"options\"], dict)\n                if len(d[\"options\"]) > 0:\n                    keys = list(d[\"options\"].keys())\n                    if is_array:\n                        data[key] = [cls.faker.random_element(keys)]\n                    else:\n                        data[key] = cls.faker.random_element(keys)\n                # else:  # pragma: no cover\n                #     pytest.fail(f\"BuildData for {key}: invalid options (empty?)\")\n            elif field_type == \"number\" or field_type == \"int\":\n                min_value = d.get(\"min\", 0)\n                max_value = d.get(\"max\", 9999)\n                data[key] = cls.faker.pyint(min_value=min_value, max_value=max_value)\n            elif field_type == \"date\":\n                min_date = None\n                max_date = None\n\n                if min_value := d.get(\"min\"):  # pragma: no cover\n                    min_date = datetime.fromisoformat(min_value)\n\n                if max_value := d.get(\"max\"):  # pragma: no cover\n                    max_date = datetime.fromisoformat(max_value)\n\n                random_date = cls.faker.date_time_between_dates(\n                    datetime_start=min_date, datetime_end=max_date\n                )\n                data[key] = random_date.date()\n            elif field_type == \"datetime\":\n                min_date = None\n                max_date = None\n\n                if min_value := d.get(\"min\"):\n                    min_date = datetime.fromisoformat(min_value)\n\n                if max_value := d.get(\"max\"):\n                    max_date = datetime.fromisoformat(max_value)\n\n                random_date = cls.faker.date_time_between_dates(\n                    datetime_start=min_date, datetime_end=max_date\n                )\n                data[key] = f\"{random_date.isoformat(timespec='seconds')}.000Z\"\n            elif field_type == \"email\":\n                data[key] = cls.faker.ascii_email()\n            elif field_type == \"boolean\":\n                data[key] = cls.faker.pybool()\n            elif field_type == \"password\":\n                data[key] = cls.faker.password(strong=True)\n            elif field_type == \"string\":\n                min_value = d.get(\"min\")\n                max_value = d.get(\"max\")\n\n                # No min/max validation\n                if min_value is None and max_value is None:\n                    min_value = 16\n                    max_value = 32\n                # Only min value provided\n                elif max_value is None:\n                    assert min_value is not None\n                    # max(min_value, 1) is need in case of min_value == 0\n                    max_value = max(min_value, 1) * 2\n                # Only max value provided\n                elif min_value is None:\n                    assert max_value is not None\n                    min_value = 1\n                # Otherwise both min and max values provided => nothing to do\n\n                data[key] = cls.faker.pystr(min_chars=min_value, max_chars=max_value)\n            elif field_type == \"nested\":\n                assert \"schema\" in d\n                # build a sub-schema based on d[\"schema\"]\n                nested_data = cls.buildData(d[\"schema\"])\n                data[key] = orjson.dumps(nested_data).decode(\"UTF8\")\n            else:\n                # Reached for example with lists of custom fields. In this case\n                # the input can't be automatically set and here is simply ignored\n                log.warning(\"BuildData for {}: unknow type {}\", key, field_type)\n                continue\n\n            if is_array:  # i.e. the field type is anytype[]\n                if not isinstance(data[key], list):\n                    data[key] = [data[key]]\n\n                # requests is unable to send lists, if not json-dumped\n                data[key] = orjson.dumps(data[key]).decode(\"UTF8\")\n\n        return data\n\n    @staticmethod\n    def delete_mock_email(previous: bool = False) -> None:\n        target = \"prevsent\" if previous else \"lastsent\"\n        fpath = LOGS_FOLDER.joinpath(f\"mock.mail.{target}.json\")\n        fpath.unlink(missing_ok=True)\n\n    @staticmethod\n    def read_mock_email(previous: bool = False) -> MockedEmail:\n        target = \"prevsent\" if previous else \"lastsent\"\n        fpath = LOGS_FOLDER.joinpath(f\"mock.mail.{target}.json\")\n        if not fpath.exists():\n            raise FileNotFoundError(fpath)\n\n        with open(fpath) as file:\n            data = cast(MockedEmail, orjson.loads(file.read()))\n\n        if \"msg\" in data:\n            tokens = data[\"msg\"].split(\"\\n\\n\")\n            data[\"headers\"] = tokens[0]\n            data[\"body\"] = \"\".join(tokens[1:])\n\n        # Longer email are base64 encoded\n        if \"Content-Transfer-Encoding: base64\" in data[\"body\"]:  # pragma: no cover\n            encodings = data[\"body\"].split(\"Content-Transfer-Encoding: base64\")\n            # Get the last message... should the be the html content\n            # A proper email parser would be need to improve this part\n            base64_body = re.sub(r\"--===============.*$\", \"\", encodings[-1])\n            base64_body = base64_body.replace(\"\\n\", \"\")\n\n            # b64decode gives as output bytes, decode(\"utf-8\") needed to get a string\n            data[\"body\"] = base64.b64decode(base64_body).decode(\"utf-8\")\n\n        fpath.unlink()\n        return data\n\n    @staticmethod\n    def get_token_from_body(body: str) -> Optional[str]:\n        token = None\n\n        # if a token is not found the email is considered to be plain text\n        # Emails are always html now\n        if \"</a>\" not in body:  # pragma: no cover\n            token = body[1 + body.rfind(\"/\") :]\n        # if a token is found the email is considered to be html\n        else:\n            urls = re.findall(\n                r'href=[\"|\\'](https?://[^\\s<>\"]+|www\\.[^\\s<>\"]+)[\"|\\']', body\n            )\n\n            log.warning(\"Found urls: {}\", urls)\n            if urls:\n                for url in urls:\n                    frontend_host = get_frontend_url()\n                    # Search the first url that contains the frontend host,\n                    # to skip any external url\n                    if frontend_host in url:\n                        # token is the last part of the url, extract as a path\n                        token = Path(url).name\n                        break\n\n        if token:\n            token = urllib.parse.unquote(token)\n\n        return token\n\n    @classmethod\n    def get_crafted_token(\n        cls,\n        token_type: str,\n        user_id: Optional[str] = None,\n        expired: bool = False,\n        immature: bool = False,\n        wrong_secret: bool = False,\n        wrong_algorithm: bool = False,\n    ) -> str:\n        if wrong_secret:\n            secret = cls.faker.password()\n        else:\n            with open(JWT_SECRET_FILE, \"rb\") as f:\n                secret = f.read()\n\n        if wrong_algorithm:\n            algorithm = \"HS256\"\n        else:\n            algorithm = BaseAuthentication.JWT_ALGO\n\n        if user_id is None:\n            user_id = str(uuid.uuid4())\n\n        payload: dict[str, Any] = {\"user_id\": user_id, \"jti\": str(uuid.uuid4())}\n        payload[\"t\"] = token_type\n        now = datetime.now(pytz.utc)\n        payload[\"iat\"] = now\n        if immature:\n            payload[\"nbf\"] = now + timedelta(seconds=999)\n        else:\n            payload[\"nbf\"] = now - timedelta(seconds=999)\n        if expired:\n            payload[\"exp\"] = now - timedelta(seconds=999)\n        else:\n            payload[\"exp\"] = now + timedelta(seconds=999)\n\n        return jwt.encode(payload, secret, algorithm=algorithm)\n\n    @staticmethod\n    def event_matches_filters(event: Event, filters: dict[str, str]) -> bool:\n        for filt, value in filters.items():  # pragma: no cover\n            if filt == \"date\" and event.date != value:\n                return False\n            if filt == \"ip\" and event.ip != value:\n                return False\n            if filt == \"user\" and event.user != value:\n                return False\n            if filt == \"event\" and event.event != value:\n                return False\n            if filt == \"target_type\" and event.target_type != value:\n                return False\n            if filt == \"target_id\" and event.target_id != value:\n                return False\n            # filter by payload ... ?\n        return True\n\n    @classmethod\n    def get_last_events(\n        cls, num: int = 1, filters: Optional[dict[str, str]] = None\n    ) -> list[Event]:\n        fpath = LOGS_FOLDER.joinpath(\"security-events.log\")\n        if not fpath.exists():  # pragma: no cover\n            return []\n\n        with open(fpath) as file:\n            # Not efficient read the whole file to get the last lines, to be improved!\n            lines = file.readlines()\n            lines.reverse()\n\n            events: list[Event] = []\n            # read last num lines\n            for line in lines:\n                # Found enough events, let's stop\n                if len(events) == num:\n                    break\n\n                tokens = line.strip().split(\" \")\n\n                payload = orjson.loads(\" \".join(tokens[8:])) if len(tokens) >= 9 else {}\n\n                event = Event(\n                    # datetime\n                    f\"{tokens[0]} {tokens[1]}\",\n                    # IP Address\n                    tokens[2],\n                    # User email or -\n                    tokens[3],\n                    # Event name\n                    tokens[4],\n                    # Target type or empty\n                    tokens[5] if len(tokens) >= 6 else \"\",\n                    # Target ID or empty\n                    tokens[6] if len(tokens) >= 7 else \"\",\n                    # Target ID or empty\n                    tokens[7] if len(tokens) >= 8 else \"\",\n                    # Payload dictionary\n                    payload,\n                )\n\n                if filters and not cls.event_matches_filters(\n                    event, filters\n                ):  # pragma: no cover\n                    continue\n\n                events.append(event)\n\n        events.reverse()\n        return events\n\n    @staticmethod\n    def send_task(app: Flask, task_name: str, *args: Any, **kwargs: Any) -> Any:\n        c = celery.get_instance()\n        c.app = app\n\n        # Celery type hints are wrong!?\n        # Mypy complains about: error: \"Callable[[], Any]\" has no attribute \"get\"\n        # But .tasks is a TaskRegistry and it is child of dict...\n        # so that .get is totally legit!\n        task = c.celery_app.tasks.get(task_name)\n\n        if not task:\n            raise AttributeError(\"Task not found\")\n\n        with execute_from_code_dir():\n            return task(*args, **kwargs)\n", "tests_initialization.py": "\"\"\"\nInitialization script for unit tests\n\"\"\"\n\nfrom datetime import datetime\n\nimport pytz\n\nfrom restapi.config import TESTING\nfrom restapi.services.authentication import DEFAULT_GROUP_NAME, BaseAuthentication\nfrom restapi.utilities.faker import get_faker\n\n\ndef initialize_testing_environment(auth: BaseAuthentication) -> None:\n    assert TESTING\n\n    faker = get_faker()\n    email = faker.ascii_email()\n    password = faker.password(strong=True)\n    default_group = auth.get_group(name=DEFAULT_GROUP_NAME)\n    user = auth.create_user(\n        {\n            \"email\": email,\n            \"name\": \"Default\",\n            \"surname\": \"User\",\n            \"password\": password,\n            \"last_password_change\": datetime.now(pytz.utc),\n        },\n        # It will be expanded with the default role\n        roles=[],\n        group=default_group,\n    )\n    # This is required to execute the commit on sqlalchemy...\n    auth.save_user(user)\n\n    for _ in range(0, 20):\n        payload, full_payload = auth.fill_payload(user)\n        token = auth.create_token(payload)\n        auth.save_token(user, token, full_payload)\n", "utilities": {}, "configuration.py": "from pathlib import Path\nfrom typing import Any, Optional, cast\n\nimport yaml\n\nfrom restapi.utilities import print_and_exit\nfrom restapi.utilities.logs import log\n\nPROJECTS_DEFAULTS_FILE = Path(\"projects_defaults.yaml\")\nPROJECT_CONF_FILENAME = Path(\"project_configuration.yaml\")\n\n\nConfigurationType = dict[str, Any]\n\n\n# REVIEW: \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0434\u043e\u043b\u0436\u043d\u0430 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0442\u044c\u0441\u044f \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c Settings\ndef read_configuration(\n    default_file_path: Path,\n    base_project_path: Path,\n    projects_path: Path,\n    submodules_path: Path,\n) -> tuple[ConfigurationType, Optional[str], Optional[Path]]:\n    \"\"\"\n    Read default configuration\n    \"\"\"\n\n    custom_configuration = load_yaml_file(\n        base_project_path.joinpath(PROJECT_CONF_FILENAME)\n    )\n\n    # Verify custom project configuration\n    project = custom_configuration.get(\"project\")\n    # Can't be tested because it is included in default configuration\n    if project is None:  # pragma: no cover\n        raise AttributeError(\"Missing project configuration\")\n\n    base_configuration = load_yaml_file(\n        default_file_path.joinpath(PROJECTS_DEFAULTS_FILE)\n    )\n\n    extended_project = project.get(\"extends\")\n\n    if extended_project is None:\n        # Mix default and custom configuration\n        return mix(base_configuration, custom_configuration), None, None\n\n    extends_from = project.get(\"extends_from\", \"projects\")\n\n    if extends_from == \"projects\":\n        extend_path = projects_path\n    elif extends_from.startswith(\"submodules/\"):  # pragma: no cover\n        repository_name = (extends_from.split(\"/\")[1]).strip()\n        if repository_name == \"\":\n            print_and_exit(\"Invalid repository name in extends_from, name is empty\")\n\n        extend_path = submodules_path\n    else:  # pragma: no cover\n        suggest = \"Expected values: 'projects' or 'submodules/${REPOSITORY_NAME}'\"\n        print_and_exit(\"Invalid extends_from parameter: {}.\\n{}\", extends_from, suggest)\n\n    if not extend_path.exists():  # pragma: no cover\n        print_and_exit(\"From project not found: {}\", str(extend_path))\n\n    extend_file = Path(f\"extended_{PROJECT_CONF_FILENAME}\")\n    extended_configuration = load_yaml_file(extend_path.joinpath(extend_file))\n    m1 = mix(base_configuration, extended_configuration)\n    return mix(m1, custom_configuration), extended_project, extend_path\n\n\ndef mix(base: ConfigurationType, custom: ConfigurationType) -> ConfigurationType:\n    for key, elements in custom.items():\n        if key not in base:\n            base[key] = custom[key]\n            continue\n\n        if elements is None:\n            if isinstance(base[key], dict):\n                log.warning(\"Cannot replace {} with empty list\", key)\n                continue\n\n        if isinstance(elements, dict):\n            mix(base[key], custom[key])\n\n        elif isinstance(elements, list):\n            for e in elements:\n                base[key].append(e)\n        else:\n            base[key] = elements\n\n    return base\n\n\ndef load_yaml_file(filepath: Path) -> ConfigurationType:\n    if not filepath.exists():\n        raise AttributeError(f\"YAML file does not exist: {filepath}\")\n\n    with open(filepath) as fh:\n        try:\n            docs = list(yaml.safe_load_all(fh))\n\n            if not docs:\n                raise AttributeError(f\"YAML file is empty: {filepath}\")\n\n            return cast(ConfigurationType, docs[0])\n\n        except Exception as e:\n            # # IF dealing with a strange exception string (escaped)\n            # import codecs\n            # error, _ = codecs.getdecoder(\"unicode_escape\")(str(error))\n\n            raise AttributeError(f\"Failed to read file {filepath}: {e}\") from e\n", "faker.py": "import secrets\nimport string\n\nfrom faker import Faker\nfrom faker.providers import BaseProvider\n\nfrom restapi.utilities.logs import log\n\nFAKER_LOCALES = {\n    \"ar_EG\": \"Arabic\",\n    \"bg_BG\": \"Bulgarian\",\n    \"bs_BA\": \"Bosnian\",\n    \"cs_CZ\": \"Czech\",\n    \"de_DE\": \"German\",\n    \"dk_DK\": \"Danish\",\n    \"el_GR\": \"Greek\",\n    \"en_US\": \"English\",\n    \"es_ES\": \"Spanish\",\n    \"et_EE\": \"Estonian\",\n    \"fa_IR\": \"Persian\",\n    \"fi_FI\": \"Finnish\",\n    \"fr_FR\": \"French\",\n    \"hi_IN\": \"Hindi\",\n    \"hr_HR\": \"Croatian\",\n    \"hu_HU\": \"Hungarian\",\n    # 'hy_AM': 'Armenian',\n    \"it_IT\": \"Italian\",\n    \"ja_JP\": \"Japanese\",\n    \"ka_GE\": \"Georgian\",\n    \"ko_KR\": \"Korean\",\n    \"lt_LT\": \"Lithuanian\",\n    \"lv_LV\": \"Latvian\",\n    \"ne_NP\": \"Nepali\",\n    \"nl_NL\": \"Dutch\",\n    \"no_NO\": \"Norwegian\",\n    \"pl_PL\": \"Polish\",\n    \"pt_PT\": \"Portuguese\",\n    \"ro_RO\": \"Romanian\",\n    \"ru_RU\": \"Russian\",\n    \"sl_SI\": \"Slovene\",\n    \"sv_SE\": \"Swedish\",\n    \"tr_TR\": \"Turkish\",\n    \"uk_UA\": \"Ukrainian\",\n    \"zh_CN\": \"Chinese\",\n}\n\n\n# Create a random password to be used to build data for tests\nclass PasswordProvider(BaseProvider):\n    def password(\n        self,\n        length: int = 8,\n        strong: bool = False,  # this enables all low, up, digits and symbols\n        low: bool = True,\n        up: bool = False,\n        digits: bool = False,\n        symbols: bool = False,\n    ) -> str:\n        if strong:\n            if length < 16:\n                length = 16\n            low = True\n            up = True\n            digits = True\n            symbols = True\n\n        charset = \"\"\n        if low:\n            charset += string.ascii_lowercase\n        if up:\n            charset += string.ascii_uppercase\n        if digits:\n            charset += string.digits\n        if symbols:\n            charset += string.punctuation\n            # Removed \\ from allowed characters\n            charset = charset.replace(\"\\\\\", \"\")\n\n        rand = secrets.SystemRandom()\n\n        randstr = \"\".join(rand.choices(charset, k=length))\n        # Password is randomly resampled, can't be sure that will be covered by tests\n        if low and not any(\n            s in randstr for s in string.ascii_lowercase\n        ):  # pragma: no cover\n            log.warning(\n                \"Password is not strong enough: missing lower case. Sampling again...\"\n            )\n            return self.password(\n                length, strong=strong, low=low, up=up, digits=digits, symbols=symbols\n            )\n        # Password is randomly resampled, can't be sure that will be covered by tests\n        if up and not any(\n            s in randstr for s in string.ascii_uppercase\n        ):  # pragma: no cover\n            log.warning(\n                \"Password is not strong enough: missing upper case. Sampling again...\"\n            )\n            return self.password(\n                length, strong=strong, low=low, up=up, digits=digits, symbols=symbols\n            )\n        # Password is randomly resampled, can't be sure that will be covered by tests\n        if digits and not any(s in randstr for s in string.digits):  # pragma: no cover\n            log.warning(\n                \"Password is not strong enough: missing digits. Sampling again...\"\n            )\n            return self.password(\n                length, strong=strong, low=low, up=up, digits=digits, symbols=symbols\n            )\n        # Password is randomly resampled, can't be sure that will be covered by tests\n        if symbols and not any(\n            s in randstr for s in string.punctuation\n        ):  # pragma: no cover\n            log.warning(\n                \"Password is not strong enough: missing symbols. Sampling again...\"\n            )\n            return self.password(\n                length, strong=strong, low=low, up=up, digits=digits, symbols=symbols\n            )\n\n        return randstr\n\n\ndef get_faker() -> Faker:\n    loc = secrets.choice(list(FAKER_LOCALES.keys()))\n    log.warning(f\"Today I'm {FAKER_LOCALES.get(loc)}\")\n    faker = Faker(loc)\n\n    faker.add_provider(PasswordProvider)\n\n    return faker\n", "globals.py": "\"\"\"\nIf you need things globally, come here and take.\n\nSource:\nhttps://pythonconquerstheuniverse.wordpress.com/\n    2010/10/20/a-globals-class-pattern-for-python/\n\n\"\"\"\n\nfrom typing import Any, Optional\n\nfrom flask_caching import Cache\nfrom sqlalchemy.engine.base import Engine\nfrom sqlalchemy.engine.url import URL\n\n\nclass mem:\n    cache: Cache\n    customizer: Any\n    initializer: Any\n    configuration: dict[str, Any]\n    private_endpoints: Any\n    authenticated_endpoints: Any\n    docs: Any\n    # default to True to save connectors by default\n    # is set False during server boot\n    boot_completed: bool = True\n\n    # None URL is used as default URL\n    sqlalchemy_engines: dict[Optional[URL], Engine] = {}\n", "logs.py": "import os\nimport re\nimport sys\nimport urllib.parse\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, Optional\n\nimport orjson\nfrom loguru import logger as log\n\nfrom restapi.config import HOST_TYPE, PRODUCTION\nfrom restapi.env import Env\n\nlog_level = Env.get(\"LOGURU_LEVEL\", \"DEBUG\")\nLOG_RETENTION = Env.get(\"LOG_RETENTION\", \"180\")\nFILE_LOGLEVEL = Env.get(\"FILE_LOGLEVEL\", \"WARNING\")\n# FILE_LOGLEVEL = \"WARNING\" if not TESTING else \"INFO\"\nLOGS_FOLDER = Path(\"/logs\")\n\nLOGS_PATH: Optional[str] = LOGS_FOLDER.joinpath(f\"{HOST_TYPE}.log\")\nEVENTS_PATH: Optional[str] = LOGS_FOLDER.joinpath(\"security-events.log\")\n\nif Path(LOGS_PATH).exists() and not os.access(LOGS_PATH, os.W_OK):  # pragma: no cover\n    print(\n        f\"\\nCan't initialize logging because {LOGS_PATH} is not writeable, \"\n        \"backend server cannot start\\n\"\n    )\n    sys.exit(1)\n\nif Path(EVENTS_PATH).exists() and not os.access(\n    EVENTS_PATH, os.W_OK\n):  # pragma: no cover\n    print(\n        f\"\\nCan't initialize logging because {EVENTS_PATH} is not writeable, \"\n        \"backend server cannot start\\n\"\n    )\n    sys.exit(1)\n\n\nclass Events(str, Enum):\n    access = \"access\"\n    create = \"create\"\n    modify = \"modify\"\n    delete = \"delete\"\n    login = \"login\"\n    logout = \"logout\"\n    failed_login = \"failed_login\"\n    refused_login = \"refused_login\"\n    activation = \"activation\"\n    login_unlock = \"login_unlock\"\n    password_expired = \"password_expired\"\n    change_password = \"change_password\"\n    reset_password_request = \"reset_password_request\"\n    server_startup = \"server_startup\"\n\n\nlog.level(\"VERBOSE\", no=1, color=\"<fg #666>\")\nlog.level(\"INFO\", color=\"<green>\")\nlog.level(\"EVENT\", no=0)\n\nlog.remove()\n\n\n# Prevent exceptions on standard sink\ndef print_message_on_stderr(record):\n    return record.get(\"exception\") is None\n\n\nif LOGS_PATH is not None:\n    try:\n        log.add(\n            LOGS_PATH,\n            level=FILE_LOGLEVEL,\n            rotation=\"1 week\",\n            retention=f\"{LOG_RETENTION} days\",\n            # If True the exception trace is extended upward, beyond the catching point\n            # to show the full stacktrace which generated the error.\n            backtrace=False,\n            # Display variables values in exception trace to eases the debugging.\n            # Disabled in production to avoid leaking sensitive data.\n            diagnose=not PRODUCTION,\n            # Messages pass through a multiprocess-safe queue before reaching the sink\n            # This is useful while logging to a file through multiple processes.\n            # This also has the advantage of making logging calls non-blocking.\n            # Unfortunately it fails to serialize some exceptions with pickle\n            enqueue=False,\n            # Errors occurring while sink handles logs messages are automatically caught\n            # an exception message is displayed on sys.stderr but the exception\n            # is not propagated to the caller, preventing your app to crash.\n            # This is the case when picle fails to serialize before sending to the queue\n            catch=True,\n        )\n\n        fmt = \"\"\n        fmt += \"{time:YYYY-MM-DD HH:mm:ss,SSS} \"\n        fmt += \"{extra[ip]} \"\n        fmt += \"{extra[user]} \"\n        fmt += \"{extra[event]} \"\n        fmt += \"{extra[target_type]} \"\n        fmt += \"{extra[target_id]} \"\n        fmt += \"{extra[url]} \"\n        fmt += \"{extra[payload]} \"\n        log.add(\n            EVENTS_PATH,\n            level=0,\n            rotation=\"1 month\",\n            retention=f\"{LOG_RETENTION} days\",\n            filter=lambda record: \"event\" in record[\"extra\"],\n            format=fmt,\n            # Otherwise in case of missing extra fields the event will be simply ignored\n            catch=False,\n        )\n    except PermissionError as p:  # pragma: no cover\n        log.error(p)\n        LOGS_PATH = None\n\n\nfmt = \"\"\nfmt += \"<fg #FFF>{time:YYYY-MM-DD HH:mm:ss,SSS}</fg #FFF> \"\nfmt += \"[<level>{level}</level> \"\nfmt += \"<fg #666>{name}:{line}</fg #666>] \"\nfmt += \"<fg #FFF>{message}</fg #FFF>\"\n\n\n# Set the default logger with the given log level and save the log_id as static variable\n# Further call to this function will remove the previous logger (based on saved log_id)\ndef set_logger(level: str) -> None:\n    if hasattr(set_logger, \"log_id\"):  # pragma: no cover\n        log_id = set_logger.log_id\n        log.remove(log_id)\n\n    log_id = log.add(\n        sys.stderr,\n        level=level,\n        colorize=True,\n        format=fmt,\n        # If True the exception trace is extended upward, beyond the catching point\n        # to show the full stacktrace which generated the error.\n        backtrace=False,\n        # Display variables values in exception trace to eases the debugging.\n        # Disabled in production to avoid leaking sensitive data.\n        # Note: enabled in development mode on the File Logger\n        diagnose=False,\n        filter=print_message_on_stderr,\n    )\n\n    set_logger.log_id = log_id\n\n\nset_logger(log_level)\n\n# Logs utilities\n\n# Can't understand why mypy is unable to understand Env.get_int, since it is annotated\n# with `-> int` .. but mypy raises:\n# Cannot determine type of 'get_int'\n# mypy: ignore-errors\nMAX_CHAR_LEN = Env.get_int(\"MAX_LOGS_LENGTH\", 200)\nOBSCURE_VALUE = \"****\"\nOBSCURED_FIELDS = [\n    \"password\",\n    \"pwd\",\n    \"token\",\n    \"access_token\",\n    \"file\",\n    \"filename\",\n    \"new_password\",\n    \"password_confirm\",\n    \"totp\",\n    \"totp_code\",\n]\n\n\ndef handle_log_output(original_parameters_string: Optional[Any]) -> dict[str, Any]:\n    \"\"\"Print a log line by preventing the exposure of sensitive information\"\"\"\n    if original_parameters_string is None:\n        return {}\n\n    if isinstance(original_parameters_string, bytes):\n        mystr = original_parameters_string.decode(\"utf-8\")\n    elif isinstance(original_parameters_string, str):\n        mystr = original_parameters_string\n    else:\n        mystr = str(original_parameters_string)\n\n    if mystr.strip() == \"\":\n        return {}\n\n    urlencoded = False\n    try:\n        parameters = orjson.loads(mystr)\n    except orjson.JSONDecodeError:\n        try:\n            parameters = urllib.parse.parse_qs(mystr)\n            urlencoded = True\n        except Exception:  # pragma: no cover\n            return original_parameters_string\n\n    return obfuscate_dict(parameters, urlencoded=urlencoded)\n\n\ndef obfuscate_url(url: str) -> str:\n    \"\"\"Obfuscate a sensitive information with a placeholder\"\"\"\n    return re.sub(r\"\\/\\/.*:.*@\", \"//***:***@\", url)\n\n\ndef obfuscate_dict(\n    parameters: dict[str, Any], urlencoded: bool = False, max_len: int = MAX_CHAR_LEN\n) -> dict[str, Any]:\n    \"\"\"Obfuscate sensitive information in a dictionary by looking at sensitive keys\"\"\"\n\n    if not isinstance(parameters, dict):\n        return parameters\n\n    output = {}\n    for key, value in parameters.items():\n        if key in OBSCURED_FIELDS:\n            value = OBSCURE_VALUE\n        elif urlencoded and isinstance(value, list):\n            # urllib.parse.parse_qs converts all elements in single-elements lists...\n            # converting back to the original element\n            if len(value) == 1:\n                value = value[0]\n        else:\n            value = str(value)\n            try:\n                if len(value) > max_len:\n                    value = value[:max_len] + \"...\"\n            except IndexError:  # pragma: no cover\n                pass\n\n        output[key] = value\n\n    return output\n\n\ndef parse_event_target(target: Any) -> tuple[str, str]:\n    \"\"\"Extract from an object an ID to be stored in logs\"\"\"\n    if not target:\n        return \"\", \"\"\n\n    target_type = type(target).__name__\n\n    if hasattr(target, \"uuid\"):\n        return target_type, target.uuid\n\n    if hasattr(target, \"id\"):\n        return target_type, target.id\n\n    return target_type, \"\"\n\n\ndef save_event_log(\n    event: Events,\n    target: Optional[Any] = None,\n    payload: Optional[dict[str, Any]] = None,\n    user: Optional[Any] = None,\n    ip: str = \"-\",\n    url: str = \"\",\n) -> None:\n    \"\"\"Save a log entry in security-events.log\"\"\"\n\n    target_type, target_id = parse_event_target(target)\n\n    if payload:\n        p = orjson.dumps(obfuscate_dict(payload, max_len=999)).decode(\"UTF8\")\n    else:\n        p = \"\"\n\n    log.log(\n        \"EVENT\",\n        \"\",\n        event=event.value,\n        ip=ip,\n        user=user.email if user else \"-\",\n        target_id=target_id,\n        target_type=target_type,\n        payload=p,\n        url=url,\n    )\n", "meta.py": "\"\"\"\nMeta thinking: python objects & introspection\n\nusefull documentation:\nhttp://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html\n\"\"\"\n\nimport inspect\nimport pkgutil\nfrom importlib import import_module\nfrom types import ModuleType\nfrom typing import Any, Callable, Optional\n\nfrom restapi.config import BACKEND_PACKAGE, CUSTOM_PACKAGE\nfrom restapi.utilities import print_and_exit\nfrom restapi.utilities.logs import log\n\n\nclass Meta:\n    \"\"\"Utilities with meta in mind\"\"\"\n\n    @staticmethod\n    def get_classes_from_module(module: ModuleType) -> dict[str, type[Any]]:\n        \"\"\"\n        Find classes inside a python module file.\n        \"\"\"\n\n        try:\n            return {\n                name: cls\n                for name, cls in module.__dict__.items()\n                if isinstance(cls, type)\n            }\n        except AttributeError:\n            log.warning(\"Could not find any class in module {}\", module)\n\n        return {}\n\n    @staticmethod\n    def get_new_classes_from_module(module: ModuleType) -> dict[str, type[Any]]:\n        \"\"\"\n        Skip classes not originated inside the module.\n        \"\"\"\n\n        classes = {}\n        for name, value in Meta.get_classes_from_module(module).items():\n            if module.__name__ in value.__module__:\n                classes[name] = value\n        return classes\n\n    # Should return `from types import ModuleType` -> Optional[ModuleType]\n    @staticmethod\n    def get_module_from_string(\n        modulestring: str, exit_on_fail: bool = False\n    ) -> Optional[ModuleType]:\n        \"\"\"\n        Getting a module import\n        when your module is stored as a string in a variable\n        \"\"\"\n\n        try:\n            return import_module(modulestring)\n        except ModuleNotFoundError as e:\n            if exit_on_fail:\n                log.error(e)\n                raise e\n            return None\n        except Exception as e:  # pragma: no cover\n            if exit_on_fail:\n                log.error(e)\n                raise e\n            log.error(\"Module {} not found.\\nError: {}\", modulestring, e)\n\n            return None\n\n    @staticmethod\n    def get_self_reference_from_args(*args: Any) -> Optional[Any]:\n        \"\"\"\n        Useful in decorators:\n        being able to call the internal method by getting\n        the 'self' reference from the decorated method\n        (when it's there)\n        \"\"\"\n\n        if len(args) > 0:\n            candidate_as_self = args[0]\n            cls_attribute = getattr(candidate_as_self, \"__class__\", None)\n            if cls_attribute is not None and inspect.isclass(cls_attribute):\n                return args[0]\n        return None\n\n    @staticmethod\n    def import_models(\n        name: str, package: str, mandatory: bool = False\n    ) -> dict[str, type[Any]]:\n        if package == BACKEND_PACKAGE:\n            module_name = f\"{package}.connectors.{name}.models\"\n        else:\n            module_name = f\"{package}.models.{name}\"\n\n        try:\n            module = Meta.get_module_from_string(module_name, exit_on_fail=True)\n        except Exception as e:\n            module = None\n            if mandatory:\n                log.critical(e)\n\n        if not module:\n            if mandatory:\n                print_and_exit(\"Cannot load {} models from {}\", name, module_name)\n\n            return {}\n\n        return Meta.get_new_classes_from_module(module)\n\n    @staticmethod\n    def get_celery_tasks(package_name: str) -> list[Callable[..., Any]]:\n        \"\"\"\n        Extract all celery tasks from a module.\n        Celery tasks are functions decorated by @CeleryExt.celery_app.task(...)\n        This decorator transform the function into a class child of\n        celery.local.PromiseProxy\n        \"\"\"\n        tasks: list[Callable[..., Any]] = []\n        # package = tasks folder\n        package = Meta.get_module_from_string(package_name)\n        if package is None:\n            return tasks\n\n        # get all modules in package (i.e. py files)\n        path = package.__path__\n        for _, module_name, ispkg in pkgutil.iter_modules(path):\n            # skip modules (i.e. subfolders)\n            if ispkg:  # pragma: no cover\n                continue\n\n            module_path = f\"{package_name}.{module_name}\"\n            log.debug(\"Loading module '{}'\", module_path)\n\n            # convert file name in submodule, i.e.\n            # tasks.filename\n            submodule = Meta.get_module_from_string(\n                module_path,\n                exit_on_fail=True,\n            )\n\n            # get all functions in py file\n            functions = inspect.getmembers(submodule)\n            for func in functions:\n                obj_type = type(func[1])\n\n                if obj_type.__module__ != \"celery.local\":\n                    continue\n\n                # This was a dict name => func\n                # tasks[func[0]] = func[1]\n                # Now it is a list\n                tasks.append(func[1])\n        return tasks\n\n    @staticmethod\n    def get_class(module_relpath: str, class_name: str) -> Optional[Any]:\n        abspath = f\"{CUSTOM_PACKAGE}.{module_relpath}\"\n\n        module = Meta.get_module_from_string(abspath)\n\n        if module is None:\n            log.debug(\"{} path does not exist\", abspath)\n            return None\n\n        if not hasattr(module, class_name):\n            return None\n\n        return getattr(module, class_name)\n", "processes.py": "import errno\nimport math\nimport os\nimport signal\nimport socket\nimport time\nfrom datetime import datetime\nfrom types import FrameType\nfrom typing import Optional\n\nimport psutil\n\nfrom restapi.config import TESTING\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.utilities.logs import log\n\nDEFAULT_MAX_RETRIES = 999 if not TESTING else 30\n\n\nclass Timeout(Exception):\n    pass\n\n\ndef handler(signum: int, frame: Optional[FrameType]) -> None:\n    raise Timeout(\"Operation timeout: interrupted\")\n\n\ndef start_timeout(time: int) -> None:\n    signal.signal(signal.SIGALRM, handler)\n    signal.alarm(time)\n\n\ndef stop_timeout() -> None:\n    signal.alarm(0)\n\n\ndef find_process(\n    process_name: str,\n    keywords: Optional[list[str]] = None,\n    prefix: Optional[str] = None,\n) -> bool:\n    if keywords is None:\n        keywords = []\n\n    if prefix:\n        keywords.append(f\"{prefix}{process_name}\")\n\n    current_pid = os.getpid()\n\n    for pid in psutil.pids():\n        if pid == current_pid or not psutil.pid_exists(pid):\n            continue  # pragma: no cover\n        process = psutil.Process(pid)\n\n        if process.name() != process_name:\n            continue\n        cmd = process.cmdline()\n\n        if not all(elem in cmd for elem in keywords):\n            continue\n\n        cmdline = \" \".join(cmd)\n        d = datetime.fromtimestamp(process.create_time()).strftime(\"%Y-%m-%d %H:%M:%S\")\n        log.warning(\n            \"Process is running\\nPID: {}\\nCreated: {}\\nCmd: {}\", pid, d, cmdline\n        )\n        return True\n\n    return False\n\n\ndef wait_socket(\n    host: str, port: int, service_name: str, retries: int = DEFAULT_MAX_RETRIES\n) -> None:\n    SLEEP_TIME = 2\n    TIMEOUT = 1\n\n    log.debug(\"Waiting for {} ({}:{})\", service_name, host, port)\n\n    counter = 0\n    begin = time.time()\n    while True:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.settimeout(TIMEOUT)\n\n            try:\n                result = s.connect_ex((host, port))\n            except socket.gaierror:\n                result = errno.ESRCH\n\n            if result == 0:\n                log.info(\"Service {} is reachable\", service_name)\n                break\n\n            counter += 1\n\n            if counter >= retries:\n                t = math.ceil(time.time() - begin)\n                raise ServiceUnavailable(\n                    f\"{service_name} ({host}:{port}) unavailable after {t} seconds\"\n                )\n\n            if counter % 15 == 0:  # pragma: no cover\n                log.warning(\n                    \"{} ({}:{}) is still unavailable after {} seconds\",\n                    service_name,\n                    host,\n                    port,\n                    math.ceil(1 + time.time() - begin),\n                )\n            else:\n                log.debug(\"{} ({}:{}) not reachable\", service_name, host, port)\n\n            time.sleep(SLEEP_TIME)\n", "time.py": "from datetime import datetime, timedelta\nfrom typing import Literal\n\nimport pytz\n\nfrom restapi.exceptions import BadRequest\n\nEPOCH: datetime = datetime.fromtimestamp(0, pytz.utc)\n\nAllowedTimedeltaPeriods = Literal[\n    \"days\", \"seconds\", \"microseconds\", \"milliseconds\", \"minutes\", \"hours\", \"weeks\"\n]\n\n\ndef date_lower_than(a: datetime, b: datetime) -> bool:\n    return a.replace(tzinfo=pytz.utc) < b.replace(tzinfo=pytz.utc)\n\n\ndef get_timedelta(every: int, period: AllowedTimedeltaPeriods) -> timedelta:\n    if period == \"seconds\":\n        return timedelta(seconds=every)\n\n    if period == \"days\":\n        return timedelta(days=every)\n\n    if period == \"microseconds\":\n        return timedelta(microseconds=every)\n\n    if period == \"milliseconds\":\n        return timedelta(milliseconds=every)\n\n    if period == \"minutes\":\n        return timedelta(minutes=every)\n\n    if period == \"hours\":\n        return timedelta(hours=every)\n\n    if period == \"weeks\":\n        return timedelta(weeks=every)\n\n    raise BadRequest(f\"Invalid timedelta period: {period}\")\n\n\ndef pluralize(value: int, unit: str) -> str:\n    if value == 1:\n        return f\"{value} {unit}\"\n    return f\"{value} {unit}s\"\n\n\n# REVIEW: \u041d\u0435\u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f, \u043c\u043e\u0436\u043d\u043e \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440:\n#   periods: list[tuple[int, str]] = [\n#           (seconds // 86400, \"day\"),\n#           (seconds // 3600 % 24, \"hour\"),\n#           (seconds // 60 % 60, \"minute\"),\n#           (seconds % 60, \"second\"),\n#       ]\n#   return \", \".join(\n#       pluralize(period[0], period[1])\n#       for period in periods\n#       if period[0] > 0\n#   )\ndef seconds_to_human(seconds: int) -> str:\n    elements: list[str] = []\n    if seconds < 60:\n        elements.append(pluralize(seconds, \"second\"))\n\n    elif seconds < 3600:\n        m, s = divmod(seconds, 60)\n        elements.append(pluralize(m, \"minute\"))\n        if s > 0:\n            elements.append(pluralize(s, \"second\"))\n\n    elif seconds < 86400:\n        m, s = divmod(seconds, 60)\n        h, m = divmod(m, 60)\n        elements.append(pluralize(h, \"hour\"))\n        if m > 0 or s > 0:\n            elements.append(pluralize(m, \"minute\"))\n        if s > 0:\n            elements.append(pluralize(s, \"second\"))\n    else:\n        m, s = divmod(seconds, 60)\n        h, m = divmod(m, 60)\n        d, h = divmod(h, 24)\n        elements.append(pluralize(d, \"day\"))\n        if h > 0 or m > 0 or s > 0:\n            elements.append(pluralize(h, \"hour\"))\n        if m > 0 or s > 0:\n            elements.append(pluralize(m, \"minute\"))\n        if s > 0:\n            elements.append(pluralize(s, \"second\"))\n\n    return \", \".join(elements)\n", "uuid.py": "\"\"\"\nHandling IDs in a more secure way\n\"\"\"\n\nimport uuid\n\n\ndef getUUID() -> str:\n    return str(uuid.uuid4())\n", "stubs": {}, "glom": {}, "__init__.pyi": "from typing import Any, MutableMapping, TypeVar\n\nT = TypeVar(\"T\")\n\n# With this annotation I'm introducing two STRONG contraints\n# 1) default is always required\n# 2) the return type is always equivalent to the default type\n# These assumptions are only valid for my use cases.\ndef glom(\n    target: MutableMapping[str, Any], spec: str, default: T, **kwargs: Any\n) -> T: ...\n", "tests": {}, "base": {}, "test_aaa_unused_credentials_step1.py": "\"\"\"\nHere some credentials will be created to be used at the end of the suite\nto verify that unused credentials are banned\n\"\"\"\n\nfrom faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.tests import BaseTests, FlaskClient\n\nif Env.get_int(\"AUTH_DISABLE_UNUSED_CREDENTIALS_AFTER\") > 0:\n\n    class TestApp1(BaseTests):\n        def test_create_credentials(self, client: FlaskClient, faker: Faker) -> None:\n            # Assign to a new group to prevent that tests working on the\n            # default group could delete this user\n            group_data = {\n                \"fullname\": \"Group to unused credentials\",\n                \"shortname\": faker.pystr(min_chars=12, max_chars=12),\n            }\n\n            group_uuid, _ = self.create_group(client, group_data)\n            user_uuid, user_data = self.create_user(client, group=group_uuid)\n\n            BaseTests.unused_credentials = (\n                user_data[\"email\"],\n                user_data[\"password\"],\n                user_uuid,\n            )\n            headers, _ = self.do_login(\n                client, BaseTests.unused_credentials[0], BaseTests.unused_credentials[1]\n            )\n            assert headers is not None\n", "test_cli.py": "# from datetime import datetime\n\nimport random\nimport time\n\nimport pytest\nfrom click.testing import CliRunner\n\nfrom restapi import __commands__ as cli\nfrom restapi import decorators\nfrom restapi.connectors import Connector\nfrom restapi.server import ServerModes\n\n\ndef test_cli() -> None:\n    runner = CliRunner()\n\n    response = runner.invoke(cli.verify, [\"test\"])\n    assert response.exit_code == 2\n\n    assert \"Got unexpected extra argument (test)\" in response.output\n\n    response = runner.invoke(cli.verify, [\"--services\", \"neo4j\"])\n    assert response.exit_code == 2\n    assert \"No such option: --services\" in response.output\n\n    response = runner.invoke(cli.verify, [\"--service\", \"x\"])\n    assert response.exit_code == 1\n\n    for service in (\"neo4j\", \"sqlalchemy\"):\n        if not Connector.check_availability(service):\n            continue\n\n        response = runner.invoke(cli.verify, [\"--service\", service])\n        assert response.exit_code == 0\n\n    response = runner.invoke(cli.wait, [])\n    assert response.exit_code == 0\n\n    response = runner.invoke(cli.init, [])\n    assert response.exit_code == 0\n\n    response = runner.invoke(cli.init, [\"--wait\"])\n    assert response.exit_code == 0\n\n    response = runner.invoke(cli.clean, [])\n    assert response.exit_code == 1\n    assert \"Do you want to continue? [y/N]:\" in response.output\n\n    response = runner.invoke(cli.tests, [\"--file\", \"x\"])\n    assert response.exit_code == 1\n\n    response = runner.invoke(cli.tests, [\"--folder\", \"x\"])\n    assert response.exit_code == 1\n\n    response = runner.invoke(cli.tests, [\"--wait\", \"--file\", \"x\"])\n    assert response.exit_code == 1\n\n    response = runner.invoke(cli.tests, [\"--core\", \"--file\", \"x\"])\n    assert response.exit_code == 1\n\n    variables = {\n        \"myhost\": \"myvalue\",\n        \"myport\": \"111\",\n    }\n    with pytest.raises(SystemExit):\n        cli.get_service_address(variables, \"host\", \"port\", \"myservice\")\n\n    with pytest.raises(SystemExit):\n        cli.get_service_address(variables, \"myhost\", \"port\", \"myservice\")\n\n    h, p = cli.get_service_address(variables, \"myhost\", \"myport\", \"myservice\")\n\n    assert h == \"myvalue\"\n    assert isinstance(p, int)\n    assert p == 111\n\n    from restapi.server import create_app\n\n    if Connector.check_availability(\"redis\"):\n        create_app(name=\"Cache clearing\", mode=ServerModes.NORMAL, options={})\n\n        # make_name prevents the use of rapydo default make_name function, that is only\n        # working on endpoints context since it is based on tokens from flask.request\n        @decorators.cache(timeout=3600, make_name=None)\n        def random_values() -> int:\n            return random.randrange(0, 100000)\n\n        val = random_values()\n        time.sleep(0.9)\n        assert random_values() == val\n        time.sleep(0.9)\n        assert random_values() == val\n\n        # Let's clear the cache\n        response = runner.invoke(cli.clearcache, [])\n        assert response.exit_code == 0\n\n        assert random_values() != val\n", "test_connector_celery.py": "import time\nfrom datetime import timedelta\nfrom unittest.mock import patch\n\nimport celery\nimport pytest\nfrom faker import Faker\nfrom flask import Flask\n\nfrom restapi.config import get_project_configuration\nfrom restapi.connectors import Connector\nfrom restapi.connectors import celery as connector\nfrom restapi.connectors.celery import CeleryExt, CeleryRetryTask, Ignore\nfrom restapi.env import Env\nfrom restapi.exceptions import BadRequest, ServiceUnavailable\nfrom restapi.server import ServerModes, create_app\nfrom restapi.tests import BaseTests\nfrom restapi.utilities.logs import log\n\nCONNECTOR = \"celery\"\nCONNECTOR_AVAILABLE = Connector.check_availability(CONNECTOR)\n\n\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be not available\"\n)\ndef test_no_celery() -> None:\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance()\n\n    log.warning(\"Skipping {} tests: service not available\", CONNECTOR)\n    return None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be available\"\n)\ndef test_celery(app: Flask, faker: Faker) -> None:\n    log.info(\"Executing {} tests\", CONNECTOR)\n\n    obj = connector.get_instance()\n    assert obj is not None\n\n    task = obj.celery_app.send_task(\"test_task\", args=(\"myinput\",))\n\n    assert task is not None\n    assert task.id is not None\n\n    # Mocked task\n    task_output = BaseTests.send_task(app, \"test_task\", \"myinput\")\n\n    # As defined in task template\n    assert task_output == \"Task executed!\"\n\n    # wrong is a special value included in tasks template\n    with pytest.raises(Ignore):\n        BaseTests.send_task(app, \"test_task\", \"wrong\")\n\n    project_title = get_project_configuration(\"project.title\", default=\"YourProject\")\n\n    mail = BaseTests.read_mock_email()\n\n    body = mail.get(\"body\")\n    headers = mail.get(\"headers\")\n    assert body is not None\n    assert headers is not None\n    assert f\"Subject: {project_title}: Task test_task failed\" in headers\n    assert \"this email is to notify you that a Celery task failed!\" in body\n    # fixed-id is a mocked value set in TESTING mode by @task in Celery connector\n    assert \"Task ID: fixed-id\" in body\n    assert \"Task name: test_task\" in body\n    assert \"Arguments: ('wrong',)\" in body\n    assert \"Error Stack\" in body\n    assert \"Traceback (most recent call last):\" in body\n\n    exc = (\n        \"AttributeError: \"\n        \"You can raise exceptions to stop the task execution in case of errors\"\n    )\n    assert exc in body\n\n    # celery.exceptions.Ignore exceptions are ignored\n\n    BaseTests.delete_mock_email()\n    # ignore is a special value included in tasks template\n    with pytest.raises(Ignore):\n        BaseTests.send_task(app, \"test_task\", \"ignore\")\n    # the errors decorator re-raise the Ignore exception, without any further action\n    # No email is sent in case of Ignore exceptions\n    with pytest.raises(FileNotFoundError):\n        mail = BaseTests.read_mock_email()\n\n    # retry is a special value included in tasks template\n    with pytest.raises(CeleryRetryTask):\n        BaseTests.send_task(app, \"test_task\", \"retry\")\n\n    mail = BaseTests.read_mock_email()\n\n    body = mail.get(\"body\")\n    headers = mail.get(\"headers\")\n    assert body is not None\n    assert headers is not None\n    assert f\"Subject: {project_title}: Task test_task failed (failure #1)\" in headers\n    assert \"this email is to notify you that a Celery task failed!\" in body\n    # fixed-id is a mocked value set in TESTING mode by @task in Celery connector\n    assert \"Task ID: fixed-id\" in body\n    assert \"Task name: test_task\" in body\n    assert \"Arguments: ('retry',)\" in body\n    assert \"Error Stack\" in body\n    assert \"Traceback (most recent call last):\" in body\n\n    exc = \"CeleryRetryTask: Force the retry of this task\"\n    assert exc in body\n\n    # retry2 is a special value included in tasks template\n    # Can't easily import the custom exception defined in the task...\n    # a generic exception is enough here\n    with pytest.raises(Exception):\n        BaseTests.send_task(app, \"test_task\", \"retry2\")\n\n    mail = BaseTests.read_mock_email()\n\n    body = mail.get(\"body\")\n    headers = mail.get(\"headers\")\n    assert body is not None\n    assert headers is not None\n    assert f\"Subject: {project_title}: Task test_task failed (failure #1)\" in headers\n    assert \"this email is to notify you that a Celery task failed!\" in body\n    # fixed-id is a mocked value set in TESTING mode by @task in Celery connector\n    assert \"Task ID: fixed-id\" in body\n    assert \"Task name: test_task\" in body\n    assert \"Arguments: ('retry2',)\" in body\n    assert \"Error Stack\" in body\n    assert \"Traceback (most recent call last):\" in body\n\n    exc = \"MyException: Force the retry of this task by using a custom exception\"\n    assert exc in body\n\n    with pytest.raises(AttributeError, match=r\"Task not found\"):\n        BaseTests.send_task(app, \"does-not-exist\")\n\n    if obj.variables.get(\"backend_service\") == \"RABBIT\":\n        log.warning(\n            \"Due to limitations on RABBIT backend task results will not be tested\"\n        )\n    else:\n        try:\n            r = task.get(timeout=10)\n            assert r is not None\n            # This is the task output, as defined in task_template.py.j2\n            assert r == \"Task executed!\"\n            assert task.status == \"SUCCESS\"\n            assert task.result == \"Task executed!\"\n        except celery.exceptions.TimeoutError:  # pragma: no cover\n            pytest.fail(f\"Task timeout, result={task.result}, status={task.status}\")\n\n    obj.disconnect()\n\n    # a second disconnect should not raise any error\n    obj.disconnect()\n\n    # Create new connector with short expiration time\n    obj = connector.get_instance(expiration=2, verification=1)\n    obj_id = id(obj)\n\n    # Connector is expected to be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # The connection should have been checked and should be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # Connection should have been expired and a new connector been created\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) != obj_id\n\n    assert obj.is_connected()\n    obj.disconnect()\n    assert not obj.is_connected()\n\n    # ... close connection again ... nothing should happen\n    obj.disconnect()\n\n    with connector.get_instance() as obj:\n        assert obj is not None\n\n    app = create_app(name=\"Flask Tests\", mode=ServerModes.WORKER, options={})\n    assert app is not None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE or Env.get_bool(\"CELERYBEAT_ENABLED\"),\n    reason=\"This test needs celery-beat to be NOT available\",\n)\ndef test_no_celerybeat() -> None:\n    obj = connector.get_instance()\n    assert obj is not None\n\n    with pytest.raises(\n        AttributeError, match=r\"Unsupported celery-beat scheduler: None\"\n    ):\n        # get_periodic_task with unknown CELERYBEAT_SCHEDULER\n        obj.get_periodic_task(\"does_not_exist\")\n\n    with pytest.raises(\n        AttributeError, match=r\"Unsupported celery-beat scheduler: None\"\n    ):\n        # delete_periodic_task with unknown CELERYBEAT_SCHEDULER\n        obj.delete_periodic_task(\"does_not_exist\")\n\n    with pytest.raises(\n        AttributeError, match=r\"Unsupported celery-beat scheduler: None\"\n    ):\n        # create_periodic_task with unknown CELERYBEAT_SCHEDULER\n        obj.create_periodic_task(name=\"task1\", task=\"task.does.not.exists\", every=\"60\")\n\n    with pytest.raises(\n        AttributeError, match=r\"Unsupported celery-beat scheduler: None\"\n    ):\n        # create_crontab_task with unknown CELERYBEAT_SCHEDULER\n        obj.create_crontab_task(\n            name=\"task2\", task=\"task.does.not.exists\", minute=\"0\", hour=\"1\"\n        )\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE or not Env.get_bool(\"CELERYBEAT_ENABLED\"),\n    reason=\"This test needs celery-beat to be available\",\n)\ndef test_celerybeat() -> None:\n    obj = connector.get_instance()\n    assert obj is not None\n\n    assert obj.get_periodic_task(\"does_not_exist\") is None\n    assert not obj.delete_periodic_task(\"does_not_exist\")\n\n    obj.create_periodic_task(name=\"task1\", task=\"task.does.not.exists\", every=\"60\")\n\n    assert obj.delete_periodic_task(\"task1\")\n    assert not obj.delete_periodic_task(\"task1\")\n\n    obj.create_periodic_task(\n        name=\"task1_bis\",\n        task=\"task.does.not.exists\",\n        every=\"60\",\n        period=\"seconds\",\n        args=[\"a\", \"b\", \"c\"],\n        kwargs={\"a\": 1, \"b\": 2, \"c\": 3},\n    )\n\n    assert obj.delete_periodic_task(\"task1_bis\")\n    assert not obj.delete_periodic_task(\"task1_bis\")\n\n    # cron at 01:00\n    obj.create_crontab_task(\n        name=\"task2\", task=\"task.does.not.exists\", minute=\"0\", hour=\"1\"\n    )\n\n    assert obj.delete_periodic_task(\"task2\")\n    assert not obj.delete_periodic_task(\"task2\")\n\n    obj.create_crontab_task(\n        name=\"task2_bis\",\n        task=\"task.does.not.exists\",\n        minute=\"0\",\n        hour=\"1\",\n        day_of_week=\"*\",\n        day_of_month=\"*\",\n        month_of_year=\"*\",\n        args=[\"a\", \"b\", \"c\"],\n        kwargs={\"a\": 1, \"b\": 2, \"c\": 3},\n    )\n\n    assert obj.delete_periodic_task(\"task2_bis\")\n    assert not obj.delete_periodic_task(\"task2_bis\")\n\n    if CeleryExt.CELERYBEAT_SCHEDULER == \"REDIS\":\n        obj.create_periodic_task(\n            name=\"task3\",\n            task=\"task.does.not.exists\",\n            every=60,\n        )\n        assert obj.delete_periodic_task(\"task3\")\n\n        obj.create_periodic_task(\n            name=\"task4\", task=\"task.does.not.exists\", every=60, period=\"seconds\"\n        )\n        assert obj.delete_periodic_task(\"task4\")\n\n        obj.create_periodic_task(\n            name=\"task5\", task=\"task.does.not.exists\", every=60, period=\"minutes\"\n        )\n        assert obj.delete_periodic_task(\"task5\")\n\n        obj.create_periodic_task(\n            name=\"task6\", task=\"task.does.not.exists\", every=60, period=\"hours\"\n        )\n        assert obj.delete_periodic_task(\"task6\")\n\n        obj.create_periodic_task(\n            name=\"task7\", task=\"task.does.not.exists\", every=60, period=\"days\"\n        )\n        assert obj.delete_periodic_task(\"task7\")\n\n        with pytest.raises(BadRequest, match=r\"Invalid timedelta period: years\"):\n            obj.create_periodic_task(\n                name=\"task8\",\n                task=\"task.does.not.exists\",\n                every=\"60\",\n                period=\"years\",  # type: ignore\n            )\n\n        obj.create_periodic_task(\n            name=\"task9\",\n            task=\"task.does.not.exists\",\n            every=timedelta(seconds=60),\n        )\n        assert obj.delete_periodic_task(\"task9\")\n\n        with pytest.raises(\n            AttributeError,\n            match=r\"Invalid input parameter every = \\['60'\\] \\(type list\\)\",\n        ):\n            obj.create_periodic_task(\n                name=\"task10\",\n                task=\"task.does.not.exists\",\n                every=[\"60\"],  # type: ignore\n            )\n\n        with pytest.raises(\n            AttributeError,\n            match=r\"Invalid input parameter every = invalid \\(type str\\)\",\n        ):\n            obj.create_periodic_task(\n                name=\"task11\",\n                task=\"task.does.not.exists\",\n                every=\"invalid\",\n            )\n", "test_connector_ftp.py": "import tempfile\nimport time\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nimport pytest\nfrom faker import Faker\nfrom flask import Flask\n\nfrom restapi.connectors import Connector\nfrom restapi.connectors import ftp as connector\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.utilities.logs import log\n\nCONNECTOR = \"ftp\"\nCONNECTOR_AVAILABLE = Connector.check_availability(CONNECTOR)\n\n\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be not available\"\n)\ndef test_no_ftp() -> None:\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance()\n\n    log.warning(\"Skipping {} tests: service not available\", CONNECTOR)\n    return None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be available\"\n)\ndef test_ftp(app: Flask, faker: Faker) -> None:\n    log.info(\"Executing {} tests\", CONNECTOR)\n\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance(host=\"invalidhostname\", port=\"123\")\n\n    obj = connector.get_instance()\n    assert obj is not None\n    assert obj.is_connected()\n\n    obj.disconnect()\n    assert not obj.is_connected()\n\n    # a second disconnect should not raise any error\n    obj.disconnect()\n\n    # Create new connector with short expiration time\n    obj = connector.get_instance(expiration=2, verification=1)\n    obj_id = id(obj)\n\n    # Connector is expected to be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # The connection should have been checked and should be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # Connection should have been expired and a new connector been created\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) != obj_id\n\n    assert obj.is_connected()\n    obj.disconnect()\n    assert not obj.is_connected()\n\n    # ... close connection again ... nothing should happen\n    obj.disconnect()\n\n    with connector.get_instance() as obj:\n        assert obj is not None\n\n        # The FTP folder is empty => only . and .. are returned\n        assert len(list(obj.connection.mlsd())) == 2\n\n        # Upload a random content file on the FTP\n        tmp_content = faker.pystr()\n        ftp_filename = faker.file_name()\n        tmp_path = tempfile.NamedTemporaryFile().name\n\n        with open(tmp_path, \"w+\") as temporary_write_file:\n            temporary_write_file.write(tmp_content)\n\n        with open(tmp_path, \"rb\") as temporary_read_file:\n            # or storbinary for binary mode\n            obj.connection.storlines(f\"STOR {ftp_filename}\", temporary_read_file)\n\n        assert len(list(obj.connection.mlsd())) == 3\n\n        # Download the file and verify it matches\n        download_file: Path = Path(tempfile.NamedTemporaryFile().name)\n\n        with open(download_file, \"w\") as download_handle:\n            # Command for Downloading the file \"RETR filename\"\n            # or retrbinary for binary mode\n            obj.connection.retrlines(f\"RETR {ftp_filename}\", download_handle.write)\n\n        with open(download_file) as download_handle:\n            downloaded_content = download_handle.read()\n            assert downloaded_content == tmp_content\n\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: 0\"):\n        connector.get_instance(retries=0, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: -1\"):\n        connector.get_instance(retries=-1, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry wait value: -1\"):\n        connector.get_instance(retries=1, retry_wait=-1)\n    obj = connector.get_instance(retries=1, retry_wait=0)\n    assert obj is not None\n\n    MOCKED_RETURN = connector.get_instance()\n    # Clean the cache\n    Connector.disconnect_all()\n    WAIT = 1\n    with patch.object(Connector, \"initialize_connection\") as mock:\n        start = time.time()\n        mock.side_effect = [\n            ServiceUnavailable(\"first\"),\n            ServiceUnavailable(\"second\"),\n            MOCKED_RETURN,\n        ]\n        obj = connector.get_instance(retries=10, retry_wait=WAIT)\n\n        assert mock.call_count == 3\n        assert obj == MOCKED_RETURN\n        end = time.time()\n\n        assert end - start > WAIT\n", "test_connector_neo4j.py": "import time\nfrom datetime import datetime\nfrom unittest.mock import patch\n\nimport dateutil.parser\nimport pytest\nimport pytz\nfrom faker import Faker\nfrom flask import Flask\nfrom neo4j.exceptions import CypherSyntaxError\n\nfrom restapi.connectors import Connector\nfrom restapi.connectors import neo4j as connector\nfrom restapi.connectors.neo4j.parser import DataDump, NodeDump, RelationDump\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.services.authentication import BaseAuthentication\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\nCONNECTOR = \"neo4j\"\nCONNECTOR_AVAILABLE = Connector.check_availability(CONNECTOR)\n\n\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be not available\"\n)\ndef test_no_neo4j() -> None:\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance()\n\n    log.warning(\"Skipping {} tests: service not available\", CONNECTOR)\n    return None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be available\"\n)\nclass TestNeo4j(BaseTests):\n    def test_endpoint(self, client: FlaskClient) -> None:\n        r = client.get(f\"{API_URI}/tests/neo4j/1\")\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/tests/neo4j/2\")\n        assert r.status_code == 400\n\n        r = client.get(f\"{API_URI}/tests/neo4j/3\")\n        assert r.status_code == 200\n        data = self.get_content(r)\n        assert isinstance(data, dict)\n        data[\"created\"] = dateutil.parser.parse(data[\"created\"])\n        data[\"modified1\"] = dateutil.parser.parse(data[\"modified1\"])\n        data[\"modified2\"] = dateutil.parser.parse(data[\"modified2\"])\n        assert data[\"created\"] < data[\"modified1\"]\n        assert data[\"modified1\"] < data[\"modified2\"]\n\n    @staticmethod\n    def test_connector(app: Flask, faker: Faker) -> None:\n        obj = connector.get_instance()\n        assert obj is not None\n\n        with pytest.raises(AttributeError, match=r\"Model InvalidModel not found\"):\n            obj.InvalidModel\n\n        for row in obj.cypher(\"MATCH (u: User) RETURN u limit 1\"):\n            u = obj.User.inflate(row[0])\n            assert u.email is not None\n            break\n\n        v = faker.random_letters(24)\n        # Create a fake token and verify that is linked to nobody\n        t = obj.Token(\n            jti=v,\n            token=v,\n            token_type=BaseAuthentication.FULL_TOKEN,\n            creation=datetime.now(pytz.utc),\n        ).save()\n        assert t.emitted_for.single() is None\n        t.delete()\n\n        with pytest.raises(CypherSyntaxError, match=r\"Failed to execute Cypher Query\"):\n            obj.cypher(\"MATCH (n) RETURN n with a syntax error\")\n        # Query information are removed from the CypherSyntaxError exception\n\n        assert obj.sanitize_input(\"x\") == \"x\"\n        assert obj.sanitize_input(\"x \") == \"x\"\n        assert obj.sanitize_input(\" x\") == \"x\"\n        assert obj.sanitize_input(\"*x\") == \"x\"\n        assert obj.sanitize_input(\"x*\") == \"x\"\n        assert obj.sanitize_input(\"x~\") == \"x\"\n        assert obj.sanitize_input(\"~x\") == \"x\"\n        assert obj.sanitize_input(\"x'\") == \"x\\\\'\"\n        assert obj.sanitize_input(\"   *~~**x~~**  \") == \"x\"\n        assert obj.sanitize_input(\" x x \") == \"x x\"\n\n        assert obj.fuzzy_tokenize('\"x y\"') == '\"x y\"'\n        assert obj.fuzzy_tokenize(\"x AND y\") == \"x~1 AND y~1\"\n        assert obj.fuzzy_tokenize(\"x + y\") == \"x~1 + y~1\"\n        assert obj.fuzzy_tokenize(\"AND OR + NOT !\") == \"AND OR + NOT !\"\n\n        obj.disconnect()\n\n        # a second disconnect should not raise any error\n        obj.disconnect()\n\n        # Create new connector with short expiration time\n        obj = connector.get_instance(expiration=2, verification=1)\n        obj_id = id(obj)\n\n        # Connector is expected to be still valid\n        obj = connector.get_instance(expiration=2, verification=1)\n        assert id(obj) == obj_id\n\n        time.sleep(1)\n\n        # The connection should have been checked and should be still valid\n        obj = connector.get_instance(expiration=2, verification=1)\n        assert id(obj) == obj_id\n\n        time.sleep(1)\n\n        # Connection should have been expired and a new connector been created\n        obj = connector.get_instance(expiration=2, verification=1)\n        assert id(obj) != obj_id\n\n        assert obj.is_connected()\n        obj.disconnect()\n        assert not obj.is_connected()\n\n        # ... close connection again ... nothing should happen\n        obj.disconnect()\n\n        with connector.get_instance() as obj:\n            assert obj is not None\n\n        with pytest.raises(ServiceUnavailable):\n            connector.get_instance(host=\"invalidhostname\", port=\"123\")\n\n        with pytest.raises(ServiceUnavailable):\n            connector.get_instance(user=\"invaliduser\")\n\n        with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: 0\"):\n            connector.get_instance(retries=0, retry_wait=0)\n        with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: -1\"):\n            connector.get_instance(retries=-1, retry_wait=0)\n        with pytest.raises(ServiceUnavailable, match=r\"Invalid retry wait value: -1\"):\n            connector.get_instance(retries=1, retry_wait=-1)\n        obj = connector.get_instance(retries=1, retry_wait=0)\n        assert obj is not None\n\n        MOCKED_RETURN = connector.get_instance()\n        # Clean the cache\n        Connector.disconnect_all()\n        WAIT = 1\n        with patch.object(Connector, \"initialize_connection\") as mock:\n            start = time.time()\n            mock.side_effect = [\n                ServiceUnavailable(\"first\"),\n                ServiceUnavailable(\"second\"),\n                MOCKED_RETURN,\n            ]\n            obj = connector.get_instance(retries=10, retry_wait=WAIT)\n\n            assert mock.call_count == 3\n            assert obj == MOCKED_RETURN\n            end = time.time()\n\n            assert end - start > WAIT\n\n    @staticmethod\n    def test_parser() -> None:\n        with pytest.raises(ValueError):\n            # missing :type\n            node1 = NodeDump(\"TestNode1\", fields=[\"f1\"])\n\n        node1 = NodeDump(\"TestNode1\", fields=[\"f1:string\", \"f2:int\", \"f3:float\"])\n\n        node2 = NodeDump(\"TestNode2\", fields=[\"f1:string\", \"f2:int\", \"f3:float\"])\n\n        with pytest.raises(ValueError):\n            rel = RelationDump(\n                \"TestNode1\",\n                \"MY_REL\",\n                \"TestNode2\",\n                fields=[\"f1\", \"f1\", \"custom:string\"],\n            )\n\n        rel = RelationDump(\n            \"TestNode1\",\n            \"MY_REL\",\n            \"TestNode2\",\n            fields=[\"f1\", \"f1\", \"custom:string\"],\n            ignore_indexes=True,\n        )\n\n        obj = connector.get_instance()\n\n        obj.cypher(\"CREATE INDEX testnode_index_name1 FOR (n:TestNode1) ON (n.f1)\")\n        obj.cypher(\"CREATE INDEX testnode_index_name2 FOR (n:TestNode2) ON (n.f1)\")\n\n        rel = RelationDump(\n            \"TestNode1\",\n            \"MY_REL\",\n            \"TestNode2\",\n            fields=[\"f1\", \"f1\", \"custom:string\"],\n        )\n\n        # To be verified the correct type assignment\n        node1.dump(\"test-string\", 10, 20.30)\n        # This is a duplicate, should be ignored\n        node1.dump(\"test-string\", 10, 20.30)\n        node1.dump(\"test-string-bis\", 11, 22.33)\n        node2.dump(\"test-string2\", 12, 24.36)\n\n        rel.dump(\"test-string\", \"test-string2\", \"custom\")\n        rel.dump(\"test-string-bis\", \"test-string2\", \"custom\")\n\n        with pytest.raises(ValueError):\n            node1.dump(None, 10, 20.30)\n\n        with pytest.raises(ValueError):\n            node1.dump(\"only-one\")\n\n        with pytest.raises(ValueError):\n            node1.dump(\"only-two\", 2)\n\n        with pytest.raises(ValueError):\n            node1.dump(\"too-many\", 2, 2.2, 2.22)\n\n        with pytest.raises(ValueError):\n            rel.dump(\"test-string\", \"test-string2\")\n\n        with pytest.raises(ValueError):\n            rel.dump(\"test-string\", \"test-string2\", \"custom1\", \"custom2\")\n\n        # test the errors if a wrong number of fields is given\n\n        # What happens with a dump of wrong keys?\n        # Nothing, but will be ignored and nothing will be created...\n        rel.dump(\"does-not-exist\", \"test-string2\", \"custom\")\n\n        node1.store()\n        node2.store()\n        rel.store()\n\n        data = obj.cypher(\"MATCH (n: TestNode1) RETURN n\")\n        assert isinstance(data[0][0][\"f1\"], str)\n        assert isinstance(data[0][0][\"f2\"], int)\n        assert isinstance(data[0][0][\"f3\"], float)\n        assert len(data) == 2\n        f1 = data[0][0][\"f1\"]\n        f2 = data[0][0][\"f2\"]\n        f3 = data[0][0][\"f3\"]\n        assert f1 == \"test-string\" or f1 == \"test-string-bis\"\n        assert f2 == 10 or f2 == 11\n        assert f3 == 20.30 or f3 == 22.33\n        f1 = data[1][0][\"f1\"]\n        f2 = data[1][0][\"f2\"]\n        f3 = data[1][0][\"f3\"]\n        assert f1 == \"test-string\" or f1 == \"test-string-bis\"\n        assert f2 == 10 or f2 == 11\n        assert f3 == 20.30 or f3 == 22.33\n\n        data = obj.cypher(\"MATCH (n: TestNode2) RETURN n\")\n        assert len(data) == 1\n\n        data = obj.cypher(\"MATCH (n)-[r:MY_REL]->(m) RETURN r\")\n        assert len(data) == 2\n        assert data[0][0][\"custom\"] == \"custom\"\n\n        DataDump.switch_label(\"TestNode2\", \"TestNode3\")\n\n        data = obj.cypher(\"MATCH (n: TestNode2) RETURN n\")\n        assert len(data) == 0\n\n        data = obj.cypher(\"MATCH (n: TestNode3) RETURN n\")\n        assert len(data) == 1\n\n        DataDump.delete_relationships(\"TestNode1\", \"MY_REL\", \"TestNode3\", limit=1)\n\n        data = obj.cypher(\"MATCH (n)-[r:MY_REL]->(m) RETURN r\")\n        assert len(data) == 0\n\n        data = obj.cypher(\"MATCH (n: TestNode1) RETURN n\")\n        assert len(data) == 2\n\n        DataDump.delete_nodes(\"TestNode1\", limit=1)\n        data = obj.cypher(\"MATCH (n: TestNode1) RETURN n\")\n        assert len(data) == 0\n\n        DataDump.delete_nodes(\"TestNode3\")\n        data = obj.cypher(\"MATCH (n: TestNode3) RETURN n\")\n        assert len(data) == 0\n\n        # TestNode2 does not exist... no errors should be raised\n        DataDump.switch_label(\"TestNode2\", \"TestNode3\")\n\n        # Test DETACH DELETE\n\n        node1 = NodeDump(\"T1\", fields=[\"f1:string\"])\n        node2 = NodeDump(\"T2\", fields=[\"f1:string\"])\n        rel = RelationDump(\"T1\", \"R1\", \"T2\", fields=[\"f1\", \"f1\"], ignore_indexes=True)\n\n        node1.dump(\"a\")\n        node2.dump(\"b\")\n        rel.dump(\"a\", \"b\")\n\n        node1.store()\n        node2.store()\n        rel.store()\n\n        data = obj.cypher(\"MATCH (n: T1) RETURN n\")\n        assert len(data) == 1\n        data = obj.cypher(\"MATCH (n: T2) RETURN n\")\n        assert len(data) == 1\n        data = obj.cypher(\"MATCH (n)-[r:R1]->(m) RETURN r\")\n        assert len(data) == 1\n\n        # Due to detach delete this will delete both T1 and R1\n        # Of course T2 will not be deleted\n        DataDump.delete_nodes(\"T1\")\n\n        data = obj.cypher(\"MATCH (n: T1) RETURN n\")\n        assert len(data) == 0\n        data = obj.cypher(\"MATCH (n: T2) RETURN n\")\n        assert len(data) == 1\n        data = obj.cypher(\"MATCH (n)-[r:R1]->(m) RETURN r\")\n        assert len(data) == 0\n\n        DataDump.delete_nodes(\"T2\")\n        data = obj.cypher(\"MATCH (n: T2) RETURN n\")\n        assert len(data) == 0\n\n        # len(cache) == .count\n        assert node1.count == 1\n        assert len(node1.cache) == 1\n        assert node1.filepath.exists()\n\n        # len(cache) == .count\n        assert node2.count == 1\n        assert len(node2.cache) == 1\n        assert node2.filepath.exists()\n\n        # Flush the cache, keep the files\n        # The .count still stores the total amount, but cache is empty\n        node1.flush_cache()\n        assert node1.count == 1\n        assert len(node1.cache) == 0\n        assert node1.filepath.exists()\n\n        # Flush the cache AND the files\n        node2.clean()\n        # The .count still stores the total amount, but cache is empty\n        assert node2.count == 1\n        assert len(node2.cache) == 0\n        assert not node2.filepath.exists()\n", "test_connector_rabbit.py": "import time\nfrom unittest.mock import patch\n\nimport pytest\nfrom faker import Faker\nfrom flask import Flask\n\nfrom restapi.connectors import Connector\nfrom restapi.connectors import rabbitmq as connector\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.utilities.logs import log\n\nCONNECTOR = \"rabbitmq\"\nCONNECTOR_AVAILABLE = Connector.check_availability(CONNECTOR)\n\n\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be not available\"\n)\ndef test_no_rabbit() -> None:\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance()\n\n    log.warning(\"Skipping {} tests: service not available\", CONNECTOR)\n    return None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be available\"\n)\ndef test_rabbit(app: Flask, faker: Faker) -> None:\n    log.info(\"Executing {} tests\", CONNECTOR)\n\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance(host=\"invalidhostname\", port=\"123\")\n\n    obj = connector.get_instance()\n    assert obj is not None\n\n    exchange = faker.pystr()\n    # This is useful for local tests, on CI the exchange never exists\n    if obj.exchange_exists(exchange):  # pragma: no cover\n        obj.delete_exchange(exchange)\n\n    queue = faker.pystr()\n    # This is useful for local tests, on CI the queue never exists\n    if obj.queue_exists(queue):  # pragma: no cover\n        obj.delete_queue(queue)\n\n    assert not obj.queue_exists(queue)\n    assert not obj.send(b\"test\", routing_key=queue)\n    assert not obj.send_json(\"test\", routing_key=queue)\n    obj.create_queue(queue)\n    assert obj.queue_exists(queue)\n    obj.create_queue(queue)\n\n    # Now send works because queue exists\n    assert obj.send(b\"test\", routing_key=queue)\n    assert obj.send_json(\"test\", routing_key=queue)\n\n    assert not obj.exchange_exists(exchange)\n    assert obj.get_bindings(exchange) is None\n    # This send does not work because exchange does not exist\n    assert not obj.send(b\"test\", routing_key=queue, exchange=exchange)\n    assert not obj.send_json(\"test\", routing_key=queue, exchange=exchange)\n\n    obj.create_exchange(exchange)\n    assert obj.exchange_exists(exchange)\n    obj.create_exchange(exchange)\n\n    # Now the exchange exists, but the queue is not bound\n    bindings = obj.get_bindings(exchange)\n    assert isinstance(bindings, list)\n    assert len(bindings) == 0\n    assert not obj.send(b\"test\", routing_key=queue, exchange=exchange)\n    assert not obj.send_json(\"test\", routing_key=queue, exchange=exchange)\n\n    obj.queue_bind(queue, exchange, queue)\n    bindings = obj.get_bindings(exchange)\n    assert bindings is not None\n    assert len(bindings) == 1\n    assert bindings[0][\"exchange\"] == exchange\n    assert bindings[0][\"routing_key\"] == queue\n    assert bindings[0][\"queue\"] == queue\n\n    assert obj.send(b\"test\", routing_key=queue, exchange=exchange)\n    assert obj.send_json(\"test\", routing_key=queue, exchange=exchange)\n\n    obj.queue_unbind(queue, exchange, queue)\n    bindings = obj.get_bindings(exchange)\n    assert isinstance(bindings, list)\n    assert len(bindings) == 0\n\n    assert not obj.send(b\"test\", routing_key=queue, exchange=exchange)\n    assert not obj.send_json(\"test\", routing_key=queue, exchange=exchange)\n\n    obj.queue_bind(queue, exchange, queue)\n    bindings = obj.get_bindings(exchange)\n    assert bindings is not None\n    assert len(bindings) == 1\n    assert bindings[0][\"exchange\"] == exchange\n    assert bindings[0][\"routing_key\"] == queue\n    assert bindings[0][\"queue\"] == queue\n\n    if obj.channel:\n        obj.channel.close()\n\n    # Channel is automatically opened, if found closed\n    assert obj.send(b\"test\", queue)\n\n    obj.delete_exchange(exchange)\n    assert not obj.send(b\"test\", routing_key=queue, exchange=exchange)\n    assert not obj.send_json(\"test\", routing_key=queue, exchange=exchange)\n\n    assert obj.send(b\"test\", routing_key=queue)\n    assert obj.send_json(\"test\", routing_key=queue)\n\n    obj.delete_queue(queue)\n\n    assert not obj.send(b\"test\", routing_key=queue)\n    assert not obj.send_json(\"test\", routing_key=queue)\n\n    obj.disconnect()\n\n    # a second disconnect should not raise any error\n    obj.disconnect()\n\n    assert obj.get_hostname(\"rabbit.dockerized.io\") == \"localhost\"\n    assert obj.get_hostname(\"anything.dockerized.io\") == \"localhost\"\n    assert obj.get_hostname(\"any.external.url\") == \"any.external.url\"\n    assert obj.get_hostname(\"1.1.1.1\") == \"1.1.1.1\"\n    assert obj.get_hostname(\"test\") == \"test\"\n    # Create new connector with short expiration time\n    obj = connector.get_instance(expiration=2, verification=1)\n    obj_id = id(obj)\n\n    # Connector is expected to be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # The connection should have been checked and should be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # Connection should have been expired and a new connector been created\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) != obj_id\n\n    assert obj.is_connected()\n    obj.disconnect()\n    assert not obj.is_connected()\n\n    # ... close connection again ... nothing should happen\n    obj.disconnect()\n\n    with connector.get_instance() as obj:\n        assert obj is not None\n\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: 0\"):\n        connector.get_instance(retries=0, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: -1\"):\n        connector.get_instance(retries=-1, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry wait value: -1\"):\n        connector.get_instance(retries=1, retry_wait=-1)\n    obj = connector.get_instance(retries=1, retry_wait=0)\n    assert obj is not None\n\n    MOCKED_RETURN = connector.get_instance()\n    # Clean the cache\n    Connector.disconnect_all()\n    WAIT = 1\n    with patch.object(Connector, \"initialize_connection\") as mock:\n        start = time.time()\n        mock.side_effect = [\n            ServiceUnavailable(\"first\"),\n            ServiceUnavailable(\"second\"),\n            MOCKED_RETURN,\n        ]\n        obj = connector.get_instance(retries=10, retry_wait=WAIT)\n\n        assert mock.call_count == 3\n        assert obj == MOCKED_RETURN\n        end = time.time()\n\n        assert end - start > WAIT\n", "test_connector_redis.py": "import time\nfrom unittest.mock import patch\n\nimport pytest\nfrom flask import Flask\n\nfrom restapi.connectors import Connector\nfrom restapi.connectors import redis as connector\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.utilities.logs import log\n\nCONNECTOR = \"redis\"\nCONNECTOR_AVAILABLE = Connector.check_availability(CONNECTOR)\n\n\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be not available\"\n)\ndef test_no_redis() -> None:\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance()\n\n    log.warning(\"Skipping {} tests: service not available\", CONNECTOR)\n    return None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be available\"\n)\ndef test_redis(app: Flask) -> None:\n    log.info(\"Executing {} tests\", CONNECTOR)\n\n    obj = connector.get_instance(host=\"invalidhostname\", port=\"123\")\n    assert obj is not None\n    assert not obj.is_connected()\n\n    obj = connector.get_instance()\n    assert obj is not None\n    assert obj.is_connected()\n\n    obj.disconnect()\n    # assert not oj.is_connected()\n\n    # a second disconnect should not raise any error\n    obj.disconnect()\n\n    # Create new connector with short expiration time\n    obj = connector.get_instance(expiration=2, verification=1)\n    obj_id = id(obj)\n\n    # Connector is expected to be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # The connection should have been checked and should be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # Connection should have been expired and a new connector been created\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) != obj_id\n\n    assert obj.is_connected()\n    obj.disconnect()\n    # assert not oj.is_connected()\n\n    # ... close connection again ... nothing should happen\n    obj.disconnect()\n\n    with connector.get_instance() as obj:\n        assert obj is not None\n\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: 0\"):\n        connector.get_instance(retries=0, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: -1\"):\n        connector.get_instance(retries=-1, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry wait value: -1\"):\n        connector.get_instance(retries=1, retry_wait=-1)\n    obj = connector.get_instance(retries=1, retry_wait=0)\n    assert obj is not None\n\n    MOCKED_RETURN = connector.get_instance()\n    # Clean the cache\n    Connector.disconnect_all()\n    WAIT = 1\n    with patch.object(Connector, \"initialize_connection\") as mock:\n        start = time.time()\n        mock.side_effect = [\n            ServiceUnavailable(\"first\"),\n            ServiceUnavailable(\"second\"),\n            MOCKED_RETURN,\n        ]\n        obj = connector.get_instance(retries=10, retry_wait=WAIT)\n\n        assert mock.call_count == 3\n        assert obj == MOCKED_RETURN\n        end = time.time()\n\n        assert end - start > WAIT\n", "test_connector_smtp.py": "import time\nfrom unittest.mock import patch\n\nimport pytest\nfrom faker import Faker\nfrom flask import Flask\n\nfrom restapi.connectors import Connector\nfrom restapi.connectors import smtp as connector\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.tests import BaseTests\nfrom restapi.utilities.logs import log\n\nCONNECTOR = \"smtp\"\nCONNECTOR_AVAILABLE = Connector.check_availability(CONNECTOR)\n\n\n# mailmock is always enabled during core tests\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be not available\"\n)\ndef test_no_smtp() -> None:  # pragma: no cover\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance()\n\n    log.warning(\"Skipping {} tests: service not available\", CONNECTOR)\n    return None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be available\"\n)\ndef test_smtp(app: Flask, faker: Faker) -> None:\n    obj = connector.get_instance()\n    assert obj is not None\n    assert obj.smtp is not None\n\n    obj = connector.get_instance(port=\"465\")\n    assert obj is not None\n    assert obj.smtp is not None\n\n    obj = connector.get_instance(port=\"587\")\n    assert obj is not None\n    assert obj.smtp is not None\n\n    assert obj.send(\"body\", \"subject\")\n    assert obj.send(\"body\", \"subject\", \"to_addr\")\n    assert obj.send(\"body\", \"subject\", \"to_addr\", \"from_addr\")\n\n    obj = connector.get_instance()\n\n    mail = BaseTests.read_mock_email()\n    body = mail.get(\"body\")\n    headers = mail.get(\"headers\")\n    assert body is not None\n    assert headers is not None\n    # Subject: is a key in the MIMEText\n    assert \"Subject: subject\" in headers\n    assert mail.get(\"from\") == \"from_addr\"\n    assert mail.get(\"cc\") == [\"to_addr\"]\n    assert mail.get(\"bcc\") is None\n\n    assert obj.send(\"body\", \"subject\", \"to_addr\", \"from_addr\", cc=\"test1\", bcc=\"test2\")\n\n    mail = BaseTests.read_mock_email()\n    body = mail.get(\"body\")\n    headers = mail.get(\"headers\")\n    assert body is not None\n    assert headers is not None\n    # Subject: is a key in the MIMEText\n    assert \"Subject: subject\" in headers\n    assert mail.get(\"from\") == \"from_addr\"\n    # format is [to, [cc...], [bcc...]]\n    assert mail.get(\"cc\") == [\"to_addr\", [\"test1\"], [\"test2\"]]\n\n    assert obj.send(\n        \"body\",\n        \"subject\",\n        \"to_addr\",\n        \"from_addr\",\n        cc=[\"test1\", \"test2\"],\n        bcc=[\"test3\", \"test4\"],\n    )\n\n    mail = BaseTests.read_mock_email()\n    body = mail.get(\"body\")\n    headers = mail.get(\"headers\")\n    assert body is not None\n    assert headers is not None\n    # Subject: is a key in the MIMEText\n    assert \"Subject: subject\" in headers\n    assert mail.get(\"from\") == \"from_addr\"\n    # format is [to, [cc...], [bcc...]]\n    assert mail.get(\"cc\") == [\"to_addr\", \"test1\", \"test2\", \"test3\", \"test4\"]\n\n    # This is a special from_address, used to raise SMTPException\n    assert not obj.send(\"body\", \"subject\", \"to_addr\", \"invalid1\")\n    # This is a special from_address, used to raise Exception\n    obj = connector.get_instance()\n    assert not obj.send(\"body\", \"subject\", \"to_addr\", \"invalid2\")\n    # This is NOT a special from_address\n    obj = connector.get_instance()\n    assert obj.send(\"body\", \"subject\", \"to_addr\", \"invalid3\")\n\n    # Test that cc and bcc with wrong types are ignored\n    assert obj.send(\n        \"body\",\n        \"subject\",\n        \"to_addr\",\n        \"from_addr\",\n        cc=10,  # type: ignore\n        bcc=20,  # type: ignore\n    )\n\n    mail = BaseTests.read_mock_email()\n    body = mail.get(\"body\")\n    headers = mail.get(\"headers\")\n    assert body is not None\n    assert headers is not None\n    # Subject: is a key in the MIMEText\n    assert \"Subject: subject\" in headers\n    # cc and bcc with wrong type (int in this case!) are ignored\n    assert mail.get(\"from\") == \"from_addr\"\n    # format is [to, [cc...], [bcc...]]\n    assert mail.get(\"cc\") == [\"to_addr\"]\n\n    with connector.get_instance() as obj:\n        assert obj is not None\n        assert obj.smtp is not None\n    # assert obj.smtp is None\n\n    with connector.get_instance(noreply=\"\", admin=\"\") as obj:\n        assert not obj.send(\"body\", \"subject\")\n        assert not obj.send(\"body\", \"subject\", \"to_addr\")\n        assert obj.send(\"body\", \"subject\", \"to_addr\", \"from_addr\")\n\n    obj = connector.get_instance()\n    assert obj.is_connected()\n    obj.disconnect()\n\n    # a second disconnect should not raise any error\n    obj.disconnect()\n\n    assert not obj.is_connected()\n\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: 0\"):\n        connector.get_instance(retries=0, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: -1\"):\n        connector.get_instance(retries=-1, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry wait value: -1\"):\n        connector.get_instance(retries=1, retry_wait=-1)\n    obj = connector.get_instance(retries=1, retry_wait=0)\n    assert obj is not None\n\n    MOCKED_RETURN = connector.get_instance()\n    # Clean the cache\n    Connector.disconnect_all()\n    WAIT = 1\n    with patch.object(Connector, \"initialize_connection\") as mock:\n        start = time.time()\n        mock.side_effect = [\n            ServiceUnavailable(\"first\"),\n            ServiceUnavailable(\"second\"),\n            MOCKED_RETURN,\n        ]\n        obj = connector.get_instance(retries=10, retry_wait=WAIT)\n\n        assert mock.call_count == 3\n        assert obj == MOCKED_RETURN\n        end = time.time()\n\n        assert end - start > WAIT\n", "test_connector_sqlalchemy.py": "import time\nfrom unittest.mock import patch\n\nimport pytest\nfrom flask import Flask\n\nfrom restapi.connectors import Connector\nfrom restapi.connectors import sqlalchemy as connector\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.utilities.logs import log\n\nCONNECTOR = \"sqlalchemy\"\nCONNECTOR_AVAILABLE = Connector.check_availability(CONNECTOR)\n\n\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be not available\"\n)\ndef test_no_sqlalchemy() -> None:\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance()\n\n    log.warning(\"Skipping {} tests: service not available\", CONNECTOR)\n    return None\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=f\"This test needs {CONNECTOR} to be available\"\n)\ndef test_sqlalchemy(app: Flask) -> None:\n    log.info(\"Executing {} tests\", CONNECTOR)\n\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance(host=\"invalidhostname\", port=\"123\")\n\n    with pytest.raises(ServiceUnavailable):\n        connector.get_instance(user=\"invaliduser\")\n\n    obj = connector.get_instance()\n    assert obj is not None\n\n    with pytest.raises(AttributeError, match=r\"Model InvalidModel not found\"):\n        obj.InvalidModel\n\n    obj.disconnect()\n\n    # a second disconnect should not raise any error\n    obj.disconnect()\n\n    # Create new connector with short expiration time\n    obj = connector.get_instance(expiration=2, verification=1)\n    obj_id = id(obj)\n    obj_db_id = id(obj.db)\n\n    # Connector is expected to be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    # The connection should have been checked and should be still valid\n    obj = connector.get_instance(expiration=2, verification=1)\n    assert id(obj) == obj_id\n\n    time.sleep(1)\n\n    obj = connector.get_instance(expiration=2, verification=1)\n    # With alchemy the connection object remains the same...\n    assert id(obj) != obj_id\n    assert id(obj.db) == obj_db_id\n\n    assert obj.is_connected()\n    obj.disconnect()\n    assert not obj.is_connected()\n\n    # ... close connection again ... nothing should happen\n    obj.disconnect()\n\n    # sqlalchemy connector does not support with context\n    # with connector.get_instance() as obj:\n    #     assert obj is not None\n\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: 0\"):\n        connector.get_instance(retries=0, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry value: -1\"):\n        connector.get_instance(retries=-1, retry_wait=0)\n    with pytest.raises(ServiceUnavailable, match=r\"Invalid retry wait value: -1\"):\n        connector.get_instance(retries=1, retry_wait=-1)\n    obj = connector.get_instance(retries=1, retry_wait=0)\n    assert obj is not None\n\n    MOCKED_RETURN = connector.get_instance()\n    # Clean the cache\n    Connector.disconnect_all()\n    WAIT = 1\n    with patch.object(Connector, \"initialize_connection\") as mock:\n        start = time.time()\n        mock.side_effect = [\n            ServiceUnavailable(\"first\"),\n            ServiceUnavailable(\"second\"),\n            MOCKED_RETURN,\n        ]\n        obj = connector.get_instance(retries=10, retry_wait=WAIT)\n\n        assert mock.call_count == 3\n        assert obj == MOCKED_RETURN\n        end = time.time()\n\n        assert end - start > WAIT\n", "test_endpoints_admin_groups.py": "import orjson\nimport pytest\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication, Role\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import Events, log\n\n\ndef get_random_group_name(faker: Faker) -> str:\n    # faker.company alone is not always enough and some\n    # \"Group already exists with shortname\" occasionally occur during tests\n    return f\"{faker.company()}-{faker.pyint(2, 100)}\"\n\n\nclass TestApp(BaseTests):\n    def test_admin_groups(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/groups tests\")\n            return\n\n        auth = Connector.get_authentication_instance()\n        staff_role_enabled = Role.STAFF.value in [r.name for r in auth.get_roles()]\n        for role in (\n            Role.ADMIN,\n            Role.STAFF,\n        ):\n            if not staff_role_enabled:  # pragma: no cover\n                log.warning(\n                    \"Skipping tests of admin/groups endpoints, role Staff not enabled\"\n                )\n                continue\n            else:\n                log.warning(\"Testing admin/groups endpoints as {}\", role)\n\n            if role == Role.ADMIN:\n                user_email = BaseAuthentication.default_user\n                user_password = BaseAuthentication.default_password\n            elif role == Role.STAFF:\n                _, user_data = self.create_user(client, roles=[Role.STAFF])\n                user_email = user_data.get(\"email\")\n                user_password = user_data.get(\"password\")\n\n            headers, _ = self.do_login(client, user_email, user_password)\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n\n            schema = self.get_dynamic_input_schema(client, \"admin/groups\", headers)\n            data = self.buildData(schema)\n\n            # Event 1: create\n            r = client.post(f\"{API_URI}/admin/groups\", json=data, headers=headers)\n            assert r.status_code == 200\n            uuid = self.get_content(r)\n            assert isinstance(uuid, str)\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            assert events[0].event == Events.create.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"Group\"\n            assert events[0].url == \"/api/admin/groups\"\n            assert \"fullname\" in events[0].payload\n            assert \"shortname\" in events[0].payload\n\n            # Save it for the following tests\n            event_target_id = events[0].target_id\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            assert len(groups) > 0\n\n            assert \"uuid\" in groups[0]\n            assert \"shortname\" in groups[0]\n            assert \"fullname\" in groups[0]\n            assert \"members\" in groups[0]\n            assert len(groups[0][\"members\"]) > 0\n            assert \"coordinators\" in groups[0]\n\n            fullname = None\n            for g in groups:\n                if g.get(\"uuid\") == uuid:\n                    fullname = g.get(\"fullname\")\n                    break\n            else:  # pragma: no cover\n                pytest.fail(\"Group not found\")\n\n            assert fullname is not None\n\n            newdata = {\n                \"shortname\": get_random_group_name(faker),\n                \"fullname\": get_random_group_name(faker),\n            }\n\n            # Test the differences between post and put schema\n            post_schema = {s[\"key\"]: s for s in schema}\n\n            tmp_schema = self.get_dynamic_input_schema(\n                client, f\"admin/groups/{uuid}\", headers, method=\"put\"\n            )\n            put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n            assert \"shortname\" in post_schema\n            assert post_schema[\"shortname\"][\"required\"]\n            assert \"shortname\" in put_schema\n            assert put_schema[\"shortname\"][\"required\"]\n\n            assert \"fullname\" in post_schema\n            assert post_schema[\"fullname\"][\"required\"]\n            assert \"fullname\" in put_schema\n            assert put_schema[\"fullname\"][\"required\"]\n\n            # Event 2: modify\n            r = client.put(\n                f\"{API_URI}/admin/groups/{uuid}\", json=newdata, headers=headers\n            )\n            assert r.status_code == 204\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            # Group modified (same target_id as above)\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"Group\"\n            assert events[0].target_id == event_target_id\n            assert events[0].url == f\"/api/admin/groups/{event_target_id}\"\n            assert \"fullname\" in events[0].payload\n            assert \"shortname\" in events[0].payload\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            for g in groups:\n                if g.get(\"uuid\") == uuid:\n                    assert g.get(\"fullname\") == newdata.get(\"fullname\")\n                    assert g.get(\"fullname\") != data.get(\"fullname\")\n                    assert g.get(\"fullname\") != fullname\n\n            r = client.put(f\"{API_URI}/admin/groups/xyz\", json=data, headers=headers)\n            assert r.status_code == 404\n\n            # members = auth.get_group_members(group)\n            # with pytest.raises(\n            #     Forbidden,\n            #     match=rf\"Cannot delete this group, it is assigned to {len(members)} user(s)\",\n            # ):\n\n            # Event 3: delete\n            r = client.delete(f\"{API_URI}/admin/groups/{uuid}\", headers=headers)\n            assert r.status_code == 204\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            # Group is deleted (same target_id as above)\n            assert events[0].event == Events.delete.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"Group\"\n            assert events[0].target_id == event_target_id\n            assert events[0].url == f\"/api/admin/groups/{event_target_id}\"\n            assert len(events[0].payload) == 0\n\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            for g in groups:\n                if g.get(\"uuid\") == uuid:  # pragma: no cover\n                    pytest.fail(\"Group not deleted!\")\n\n            r = client.delete(f\"{API_URI}/admin/groups/xyz\", headers=headers)\n            assert r.status_code == 404\n\n            # Create a group and assign it to the main user\n            # Profile and AdminUsers will react to this change\n            # Very important: admin_groups must be tested before admin_users and profile\n\n            r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, dict)\n            user_uuid = content.get(\"uuid\")\n\n            data = {\n                \"fullname\": \"Default group\",\n                \"shortname\": get_random_group_name(faker),\n            }\n\n            # Event 4: create\n            new_group_uuid, _ = self.create_group(client, data=data)\n\n            events = self.get_last_events(1, filters={\"target_type\": \"Group\"})\n            # A new group is created\n            assert events[0].event == Events.create.value\n            # Created via admin utility\n            assert events[0].user == BaseAuthentication.default_user\n            assert events[0].target_type == \"Group\"\n            assert events[0].target_id != event_target_id\n            assert events[0].url == \"/api/admin/groups\"\n            assert \"fullname\" in events[0].payload\n            assert \"shortname\" in events[0].payload\n            # Save it for the following tests\n            event_group_uuid = events[0].target_id\n\n            data = {\n                \"group\": new_group_uuid,\n                # very important, otherwise the default user will lose its role\n                # adding coordinator to enforce the role and use it for additional tests\n                \"roles\": orjson.dumps([role, \"group_coordinator\"]).decode(\"UTF8\"),\n            }\n\n            # a new login is required due to the use of create_group utility\n            headers, _ = self.do_login(client, user_email, user_password)\n\n            # Event 5: modify\n            r = client.put(\n                f\"{API_URI}/admin/users/{user_uuid}\", json=data, headers=headers\n            )\n            assert r.status_code == 204\n\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            # User modified, payload contains the created group\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == user_uuid\n            assert events[0].url == f\"/api/admin/users/{user_uuid}\"\n            assert \"fullname\" not in events[0].payload\n            assert \"shortname\" not in events[0].payload\n            assert \"group\" in events[0].payload\n            assert events[0].payload[\"group\"] == event_group_uuid\n\n            # Event 6: verify the assigned group\n            r = client.get(f\"{API_URI}/admin/users/{user_uuid}\", headers=headers)\n            assert r.status_code == 200\n            users_list = self.get_content(r)\n            assert isinstance(users_list, dict)\n            assert len(users_list) > 0\n            assert \"group\" in users_list\n            assert \"uuid\" in users_list[\"group\"]\n            assert \"fullname\" in users_list[\"group\"]\n            assert \"shortname\" in users_list[\"group\"]\n            assert users_list[\"group\"][\"uuid\"] == new_group_uuid\n\n            # Verify coordinators:\n            r = client.get(f\"{API_URI}/admin/groups\", headers=headers)\n            assert r.status_code == 200\n            groups = self.get_content(r)\n            assert isinstance(groups, list)\n            assert len(groups) > 0\n\n            # Extract all coordinators:\n            coordinators: set[str] = set()\n            for group in groups:\n                for coordinator in group[\"coordinators\"]:\n                    coordinators.add(coordinator[\"email\"])\n\n            assert user_email in coordinators\n\n            if role == Role.ADMIN:\n                assert BaseAuthentication.default_user in coordinators\n            else:\n                assert BaseAuthentication.default_user not in coordinators\n", "test_endpoints_admin_logins.py": "import pytest\nfrom faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_admin_stats(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/logins tests\")\n            return\n\n        r = client.get(f\"{API_URI}/admin/logins\")\n        assert r.status_code == 401\n\n        random_username = faker.ascii_email()\n        self.do_login(client, random_username, faker.pystr(), status_code=401)\n\n        headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/admin/logins\", headers=headers)\n        assert r.status_code == 200\n        logins = self.get_content(r)\n        assert isinstance(logins, list)\n        assert len(logins) > 0\n        assert \"username\" in logins[0]\n        assert \"date\" in logins[0]\n        assert \"IP\" in logins[0]\n        assert \"location\" in logins[0]\n        assert \"failed\" in logins[0]\n        assert \"flushed\" in logins[0]\n\n        for login in logins:\n            if login[\"username\"] == BaseAuthentication.default_user:\n                break\n        else:  # pragma: no cover\n            pytest.fail(\"Default user not found in logins table\")\n\n        for login in logins:\n            if login[\"username\"] == random_username:\n                assert login[\"failed\"] is True\n                assert login[\"flushed\"] is False\n                break\n        else:  # pragma: no cover\n            pytest.fail(\"Random user not found in logins table\")\n", "test_endpoints_admin_stats.py": "from datetime import datetime\n\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_admin_stats(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/stats tests\")\n            return\n\n        r = client.get(f\"{API_URI}/admin/stats\")\n        assert r.status_code == 401\n\n        headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/admin/stats\", headers=headers)\n        assert r.status_code == 200\n        stats = self.get_content(r)\n        assert isinstance(stats, dict)\n\n        # ### BOOT TIME ###\n        assert \"system\" in stats\n        assert \"boot_time\" in stats[\"system\"]\n        d = datetime.strptime(stats[\"system\"][\"boot_time\"], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n        assert d < datetime.now()\n\n        # ### CPU ###\n        assert \"cpu\" in stats\n\n        assert \"count\" in stats[\"cpu\"]\n        assert stats[\"cpu\"][\"count\"] > 0\n\n        assert \"idle\" in stats[\"cpu\"]\n        assert stats[\"cpu\"][\"idle\"] >= 0\n        assert stats[\"cpu\"][\"idle\"] <= 100\n\n        assert \"load_percentage\" in stats[\"cpu\"]\n        assert float(stats[\"cpu\"][\"load_percentage\"]) >= 0\n        # Originally it was <= 100, but sometimes the GHA VMs are overloaded\n        # and the cpu usage is greater than 100%\n        assert float(stats[\"cpu\"][\"load_percentage\"]) <= 150\n\n        assert \"stolen\" in stats[\"cpu\"]\n        assert stats[\"cpu\"][\"stolen\"] >= 0\n        assert stats[\"cpu\"][\"stolen\"] <= 100\n\n        assert \"system\" in stats[\"cpu\"]\n        assert stats[\"cpu\"][\"system\"] >= 0\n        assert stats[\"cpu\"][\"system\"] <= 100\n\n        assert \"user\" in stats[\"cpu\"]\n        assert stats[\"cpu\"][\"user\"] >= 0\n        assert stats[\"cpu\"][\"user\"] <= 100\n\n        assert \"wait\" in stats[\"cpu\"]\n        assert stats[\"cpu\"][\"wait\"] >= 0\n        assert stats[\"cpu\"][\"wait\"] <= 100\n\n        # ### DISK ###\n        assert \"disk\" in stats\n\n        assert \"total_disk_space\" in stats[\"disk\"]\n        assert \"free_disk_space\" in stats[\"disk\"]\n        assert \"used_disk_space\" in stats[\"disk\"]\n        assert \"occupacy\" in stats[\"disk\"]\n\n        stats[\"disk\"][\"total_disk_space\"] = float(stats[\"disk\"][\"total_disk_space\"])\n        stats[\"disk\"][\"free_disk_space\"] = float(stats[\"disk\"][\"free_disk_space\"])\n        stats[\"disk\"][\"used_disk_space\"] = float(stats[\"disk\"][\"used_disk_space\"])\n        stats[\"disk\"][\"occupacy\"] = float(stats[\"disk\"][\"occupacy\"])\n\n        assert stats[\"disk\"][\"total_disk_space\"] > 0\n\n        assert stats[\"disk\"][\"free_disk_space\"] >= 0\n        assert stats[\"disk\"][\"free_disk_space\"] < stats[\"disk\"][\"total_disk_space\"]\n\n        assert stats[\"disk\"][\"used_disk_space\"] >= 0\n        assert stats[\"disk\"][\"used_disk_space\"] < stats[\"disk\"][\"total_disk_space\"]\n\n        s = stats[\"disk\"][\"free_disk_space\"] + stats[\"disk\"][\"used_disk_space\"]\n        assert abs(stats[\"disk\"][\"total_disk_space\"] - s) < 0.5\n\n        assert stats[\"disk\"][\"occupacy\"] >= 0\n        assert stats[\"disk\"][\"occupacy\"] <= 100\n\n        p = stats[\"disk\"][\"used_disk_space\"] / stats[\"disk\"][\"total_disk_space\"]\n        assert abs(stats[\"disk\"][\"occupacy\"] - round(100 * p, 2)) < 0.5\n\n        # ### IO ###\n        assert \"io\" in stats\n\n        assert \"blocks_received\" in stats[\"io\"]\n        assert stats[\"io\"][\"blocks_received\"] >= 0\n\n        assert \"blocks_sent\" in stats[\"io\"]\n        assert stats[\"io\"][\"blocks_sent\"] >= 0\n\n        # ### NETWORK ###\n        assert \"network_latency\" in stats\n\n        assert \"min\" in stats[\"network_latency\"]\n        assert \"avg\" in stats[\"network_latency\"]\n        assert \"max\" in stats[\"network_latency\"]\n\n        stats[\"network_latency\"][\"min\"] = float(stats[\"network_latency\"][\"min\"])\n        stats[\"network_latency\"][\"avg\"] = float(stats[\"network_latency\"][\"avg\"])\n        stats[\"network_latency\"][\"max\"] = float(stats[\"network_latency\"][\"max\"])\n\n        assert stats[\"network_latency\"][\"min\"] >= 0\n        assert stats[\"network_latency\"][\"min\"] <= stats[\"network_latency\"][\"avg\"]\n        assert stats[\"network_latency\"][\"min\"] <= stats[\"network_latency\"][\"max\"]\n\n        assert stats[\"network_latency\"][\"avg\"] >= 0\n        assert stats[\"network_latency\"][\"avg\"] >= stats[\"network_latency\"][\"min\"]\n        assert stats[\"network_latency\"][\"avg\"] <= stats[\"network_latency\"][\"max\"]\n\n        assert stats[\"network_latency\"][\"max\"] >= 0\n        assert stats[\"network_latency\"][\"max\"] >= stats[\"network_latency\"][\"min\"]\n        assert stats[\"network_latency\"][\"max\"] >= stats[\"network_latency\"][\"avg\"]\n\n        # ### PROCS ###\n        assert \"procs\" in stats\n\n        assert \"uninterruptible_sleep\" in stats[\"procs\"]\n        assert stats[\"procs\"][\"uninterruptible_sleep\"] >= 0\n\n        assert \"waiting_for_run\" in stats[\"procs\"]\n        assert stats[\"procs\"][\"waiting_for_run\"] >= 0\n\n        # ### RAM ###\n        assert \"ram\" in stats\n\n        assert \"total\" in stats[\"ram\"]\n        assert stats[\"ram\"][\"total\"] >= 0\n\n        assert \"used\" in stats[\"ram\"]\n        assert stats[\"ram\"][\"used\"] >= 0\n        assert stats[\"ram\"][\"used\"] <= stats[\"ram\"][\"total\"]\n\n        assert \"active\" in stats[\"ram\"]\n        assert stats[\"ram\"][\"active\"] >= 0\n        assert stats[\"ram\"][\"active\"] <= stats[\"ram\"][\"total\"]\n\n        assert \"buffer\" in stats[\"ram\"]\n        assert stats[\"ram\"][\"buffer\"] >= 0\n        assert stats[\"ram\"][\"buffer\"] <= stats[\"ram\"][\"total\"]\n\n        assert \"cache\" in stats[\"ram\"]\n        assert stats[\"ram\"][\"cache\"] >= 0\n        assert stats[\"ram\"][\"cache\"] <= stats[\"ram\"][\"total\"]\n\n        assert \"free\" in stats[\"ram\"]\n        assert stats[\"ram\"][\"free\"] >= 0\n        assert stats[\"ram\"][\"free\"] <= stats[\"ram\"][\"total\"]\n\n        assert \"inactive\" in stats[\"ram\"]\n        assert stats[\"ram\"][\"inactive\"] >= 0\n        assert stats[\"ram\"][\"inactive\"] <= stats[\"ram\"][\"total\"]\n\n        # ### SWAP ###\n        assert \"swap\" in stats\n\n        assert \"total\" in stats[\"swap\"]\n        assert stats[\"swap\"][\"total\"] >= 0\n\n        assert \"free\" in stats[\"swap\"]\n        assert stats[\"swap\"][\"free\"] >= 0\n        assert stats[\"swap\"][\"free\"] <= stats[\"swap\"][\"total\"]\n\n        assert \"used\" in stats[\"swap\"]\n        assert stats[\"swap\"][\"used\"] >= 0\n        assert stats[\"swap\"][\"used\"] <= stats[\"swap\"][\"total\"]\n\n        assert \"from_disk\" in stats[\"swap\"]\n        assert stats[\"swap\"][\"from_disk\"] >= 0\n\n        assert \"to_disk\" in stats[\"swap\"]\n        assert stats[\"swap\"][\"to_disk\"] >= 0\n", "test_endpoints_admin_users.py": "import orjson\nfrom faker import Faker\nfrom flask import escape\n\nfrom restapi.config import get_project_configuration\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication, Role\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import OBSCURE_VALUE, Events, log\n\n\nclass TestApp(BaseTests):\n    def test_admin_users(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/users tests\")\n            return\n\n        project_tile = get_project_configuration(\"project.title\", default=\"YourProject\")\n\n        auth = Connector.get_authentication_instance()\n        staff_role_enabled = Role.STAFF.value in [r.name for r in auth.get_roles()]\n\n        for role in (\n            Role.ADMIN,\n            Role.STAFF,\n        ):\n            if not staff_role_enabled:  # pragma: no cover\n                log.warning(\n                    \"Skipping tests of admin/users endpoints, role Staff not enabled\"\n                )\n                continue\n            else:\n                log.warning(\"Testing admin/users endpoints as {}\", role)\n\n            if role == Role.ADMIN:\n                user_email = BaseAuthentication.default_user\n                user_password = BaseAuthentication.default_password\n            elif role == Role.STAFF:\n                _, user_data = self.create_user(client, roles=[Role.STAFF])\n                user_email = user_data.get(\"email\")\n                user_password = user_data.get(\"password\")\n\n            headers, _ = self.do_login(client, user_email, user_password)\n            r = client.get(f\"{API_URI}/admin/users\", headers=headers)\n            assert r.status_code == 200\n\n            schema = self.get_dynamic_input_schema(client, \"admin/users\", headers)\n            data = self.buildData(schema)\n\n            data[\"email_notification\"] = True\n            data[\"is_active\"] = True\n            data[\"expiration\"] = None\n\n            # Event 1: create\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers)\n            assert r.status_code == 200\n            uuid = self.get_content(r)\n            assert isinstance(uuid, str)\n\n            # A new User is created\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.create.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].url == \"/api/admin/users\"\n            assert \"name\" in events[0].payload\n            assert \"surname\" in events[0].payload\n            assert \"email\" in events[0].payload\n\n            # Save it for the following tests\n            event_target_id1 = events[0].target_id\n\n            mail = self.read_mock_email()\n            body = mail.get(\"body\", \"\")\n\n            # Subject: is a key in the MIMEText\n            assert body is not None\n            assert mail.get(\"headers\") is not None\n            assert f\"Subject: {project_tile}: New credentials\" in mail.get(\n                \"headers\", \"\"\n            )\n            assert data.get(\"email\", \"MISSING\").lower() in body\n            assert (\n                data.get(\"password\", \"MISSING\") in body\n                or escape(str(data.get(\"password\"))) in body\n            )\n\n            # Test the differences between post and put schema\n            post_schema = {s[\"key\"]: s for s in schema}\n\n            tmp_schema = self.get_dynamic_input_schema(\n                client, f\"admin/users/{uuid}\", headers, method=\"put\"\n            )\n            put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n            assert \"email\" in post_schema\n            assert post_schema[\"email\"][\"required\"]\n            assert \"email\" not in put_schema\n\n            assert \"name\" in post_schema\n            assert post_schema[\"name\"][\"required\"]\n            assert \"name\" in put_schema\n            assert not put_schema[\"name\"][\"required\"]\n\n            assert \"surname\" in post_schema\n            assert post_schema[\"surname\"][\"required\"]\n            assert \"surname\" in put_schema\n            assert not put_schema[\"surname\"][\"required\"]\n\n            assert \"password\" in post_schema\n            assert post_schema[\"password\"][\"required\"]\n            assert \"password\" in put_schema\n            assert not put_schema[\"password\"][\"required\"]\n\n            assert \"group\" in post_schema\n            assert post_schema[\"group\"][\"required\"]\n            assert \"group\" in put_schema\n            assert not put_schema[\"group\"][\"required\"]\n\n            # Event 2: read\n            r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n            assert r.status_code == 200\n            users_list = self.get_content(r)\n            assert isinstance(users_list, dict)\n            assert len(users_list) > 0\n            # email is saved lowercase\n            assert users_list.get(\"email\") == data.get(\"email\", \"MISSING\").lower()\n\n            # Access to the user\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.access.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id1\n            assert events[0].url == f\"/api/admin/users/{event_target_id1}\"\n            assert len(events[0].payload) == 0\n\n            # Check duplicates\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers)\n            assert r.status_code == 409\n            assert (\n                self.get_content(r)\n                == f\"A User already exists with email: {data['email']}\"\n            )\n\n            data[\"email\"] = BaseAuthentication.default_user\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers)\n            assert r.status_code == 409\n            assert (\n                self.get_content(r)\n                == f\"A User already exists with email: {BaseAuthentication.default_user}\"\n            )\n\n            # Create another user\n            data2 = self.buildData(schema)\n            data2[\"email_notification\"] = True\n            data2[\"is_active\"] = True\n            data2[\"expiration\"] = None\n\n            # Event 3: create\n            r = client.post(f\"{API_URI}/admin/users\", json=data2, headers=headers)\n            assert r.status_code == 200\n            uuid2 = self.get_content(r)\n            assert isinstance(uuid2, str)\n\n            # Another User is created\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.create.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id != event_target_id1\n            assert events[0].url == \"/api/admin/users\"\n            assert \"name\" in events[0].payload\n            assert \"surname\" in events[0].payload\n            assert \"email\" in events[0].payload\n\n            # Save it for the following tests\n            event_target_id2 = events[0].target_id\n\n            mail = self.read_mock_email()\n            body = mail.get(\"body\", \"\")\n            # Subject: is a key in the MIMEText\n            assert body is not None\n            assert mail.get(\"headers\") is not None\n            assert f\"Subject: {project_tile}: New credentials\" in mail.get(\n                \"headers\", \"\"\n            )\n            assert data2.get(\"email\", \"MISSING\").lower() in body\n            pwd = data2.get(\"password\", \"MISSING\")\n            assert pwd in body or escape(str(pwd)) in body\n\n            # send and invalid user_id\n            r = client.put(\n                f\"{API_URI}/admin/users/invalid\",\n                json={\"name\": faker.name()},\n                headers=headers,\n            )\n            assert r.status_code == 404\n\n            # Event 4: modify\n            r = client.put(\n                f\"{API_URI}/admin/users/{uuid}\",\n                json={\"name\": faker.name()},\n                headers=headers,\n            )\n            assert r.status_code == 204\n\n            # User 1 modified (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id1\n            assert events[0].url == f\"/api/admin/users/{event_target_id1}\"\n            assert \"name\" in events[0].payload\n            assert \"surname\" not in events[0].payload\n            assert \"email\" not in events[0].payload\n            assert \"password\" not in events[0].payload\n\n            # email cannot be modified\n            new_data = {\"email\": data.get(\"email\")}\n            r = client.put(\n                f\"{API_URI}/admin/users/{uuid2}\", json=new_data, headers=headers\n            )\n            # from webargs >= 6 this endpoint no longer return a 204 but a 400\n            # because email is an unknown field\n            # assert r.status_code == 204\n            assert r.status_code == 400\n\n            # Event 5: read\n            r = client.get(f\"{API_URI}/admin/users/{uuid2}\", headers=headers)\n            assert r.status_code == 200\n            users_list = self.get_content(r)\n            assert isinstance(users_list, dict)\n            assert len(users_list) > 0\n            # email is not modified -> still equal to data2, not data1\n            assert users_list.get(\"email\") != data.get(\"email\", \"MISSING\").lower()\n            assert users_list.get(\"email\") == data2.get(\"email\", \"MISSING\").lower()\n\n            # Access to user 2\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.access.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id2\n            assert events[0].url == f\"/api/admin/users/{event_target_id2}\"\n            assert len(events[0].payload) == 0\n\n            r = client.delete(f\"{API_URI}/admin/users/invalid\", headers=headers)\n            assert r.status_code == 404\n\n            # Event 6: delete\n            r = client.delete(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n            assert r.status_code == 204\n\n            # User 1 is deleted (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.delete.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id1\n            assert events[0].url == f\"/api/admin/users/{event_target_id1}\"\n            assert len(events[0].payload) == 0\n\n            r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n            assert r.status_code == 404\n\n            # change password of user2\n            # Event 7: modify\n            newpwd = faker.password(strong=True)\n            data = {\"password\": newpwd, \"email_notification\": True}\n            r = client.put(f\"{API_URI}/admin/users/{uuid2}\", json=data, headers=headers)\n            assert r.status_code == 204\n\n            # User 2 modified (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id2\n            assert events[0].url == f\"/api/admin/users/{event_target_id2}\"\n            assert \"name\" not in events[0].payload\n            assert \"surname\" not in events[0].payload\n            assert \"email\" not in events[0].payload\n            assert \"password\" in events[0].payload\n            assert \"email_notification\" in events[0].payload\n            # Verify that the password is obfuscated in the log:\n            assert events[0].payload[\"password\"] == OBSCURE_VALUE\n\n            mail = self.read_mock_email()\n            # Subject: is a key in the MIMEText\n            assert mail.get(\"body\", \"\") is not None\n            assert mail.get(\"headers\", \"\") is not None\n            assert f\"Subject: {project_tile}: Password changed\" in mail.get(\n                \"headers\", \"\"\n            )\n            assert data2.get(\"email\", \"MISSING\").lower() in mail.get(\"body\", \"\")\n            assert newpwd in mail.get(\"body\", \"\") or escape(newpwd) in mail.get(\n                \"body\", \"\"\n            )\n\n            # login with a newly created user\n            headers2, _ = self.do_login(client, data2.get(\"email\"), newpwd)\n\n            # normal users cannot access to this endpoint\n            r = client.get(f\"{API_URI}/admin/users\", headers=headers2)\n            assert r.status_code == 401\n\n            r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers2)\n            assert r.status_code == 401\n\n            r = client.post(f\"{API_URI}/admin/users\", json=data, headers=headers2)\n            assert r.status_code == 401\n\n            r = client.put(\n                f\"{API_URI}/admin/users/{uuid}\",\n                json={\"name\": faker.name()},\n                headers=headers2,\n            )\n            assert r.status_code == 401\n\n            r = client.delete(f\"{API_URI}/admin/users/{uuid}\", headers=headers2)\n            assert r.status_code == 401\n\n            # Users are not authorized to /admin/tokens\n            # These two tests should be moved in test_endpoints_tokens.py\n            r = client.get(f\"{API_URI}/admin/tokens\", headers=headers2)\n            assert r.status_code == 401\n            r = client.delete(f\"{API_URI}/admin/tokens/xyz\", headers=headers2)\n            assert r.status_code == 401\n\n            # let's delete the second user\n            # Event 8: delete\n            r = client.delete(f\"{API_URI}/admin/users/{uuid2}\", headers=headers)\n            assert r.status_code == 204\n\n            # User 2 is deleted (same target_id as above)\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.delete.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id == event_target_id2\n            assert events[0].url == f\"/api/admin/users/{event_target_id2}\"\n            assert len(events[0].payload) == 0\n\n            # Restore the default password (changed due to FORCE_FIRST_PASSWORD_CHANGE)\n            # or MAX_PASSWORD_VALIDITY errors\n            r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, dict)\n            uuid = str(content.get(\"uuid\"))\n\n            data = {\n                \"password\": user_password,\n                # very important, otherwise the default user will lose its role\n                \"roles\": orjson.dumps([role]).decode(\"UTF8\"),\n            }\n            # Event 9: modify\n            r = client.put(f\"{API_URI}/admin/users/{uuid}\", json=data, headers=headers)\n            assert r.status_code == 204\n\n            # Default user is modified\n            events = self.get_last_events(1, filters={\"target_type\": \"User\"})\n            assert events[0].event == Events.modify.value\n            assert events[0].user == user_email\n            assert events[0].target_type == \"User\"\n            assert events[0].target_id != event_target_id1\n            assert events[0].target_id != event_target_id2\n            assert events[0].url != f\"/api/admin/users/{event_target_id1}\"\n            assert events[0].url != f\"/api/admin/users/{event_target_id2}\"\n            assert \"name\" not in events[0].payload\n            assert \"surname\" not in events[0].payload\n            assert \"email\" not in events[0].payload\n            assert \"password\" in events[0].payload\n            assert \"roles\" in events[0].payload\n            assert \"email_notification\" not in events[0].payload\n            # Verify that the password is obfuscated in the log:\n            assert events[0].payload[\"password\"] == OBSCURE_VALUE\n\n            r = client.get(f\"{AUTH_URI}/logout\", headers=headers)\n            assert r.status_code == 204\n\n    def test_staff_restrictions(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin/users tests\")\n            return\n\n        auth = Connector.get_authentication_instance()\n        staff_role_enabled = Role.STAFF.value in [r.name for r in auth.get_roles()]\n\n        if not staff_role_enabled:  # pragma: no cover\n            log.warning(\n                \"Skipping tests of admin/users restrictions, role Staff not enabled\"\n            )\n            return\n\n        staff_uuid, staff_data = self.create_user(client, roles=[Role.STAFF])\n        staff_email = staff_data.get(\"email\")\n        staff_password = staff_data.get(\"password\")\n        staff_headers, _ = self.do_login(client, staff_email, staff_password)\n\n        user_uuid, _ = self.create_user(client, roles=[Role.USER])\n\n        admin_headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{AUTH_URI}/profile\", headers=admin_headers)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        admin_uuid = content.get(\"uuid\")\n\n        # Staff users are not allowed to retrieve Admins' data\n        r = client.get(f\"{API_URI}/admin/users/{user_uuid}\", headers=admin_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{staff_uuid}\", headers=admin_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{admin_uuid}\", headers=admin_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{user_uuid}\", headers=staff_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{staff_uuid}\", headers=staff_headers)\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/admin/users/{admin_uuid}\", headers=staff_headers)\n        assert r.status_code == 404\n        content = self.get_content(r)\n        assert content == \"This user cannot be found or you are not authorized\"\n\n        # Staff users are not allowed to edit Admins\n        r = client.put(\n            f\"{API_URI}/admin/users/{admin_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.STAFF]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 404\n        content = self.get_content(r)\n        assert content == \"This user cannot be found or you are not authorized\"\n\n        r = client.put(\n            f\"{API_URI}/admin/users/{staff_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.STAFF]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 204\n\n        r = client.put(\n            f\"{API_URI}/admin/users/{user_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.USER]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 204\n\n        # Admin role is not allowed for Staff users\n        tmp_schema = self.get_dynamic_input_schema(client, \"admin/users\", admin_headers)\n        post_schema = {s[\"key\"]: s for s in tmp_schema}\n        assert \"roles\" in post_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" in post_schema[\"roles\"][\"options\"]\n\n        tmp_schema = self.get_dynamic_input_schema(\n            client, f\"admin/users/{user_uuid}\", admin_headers, method=\"put\"\n        )\n        put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n        assert \"roles\" in put_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" in post_schema[\"roles\"][\"options\"]\n\n        tmp_schema = self.get_dynamic_input_schema(client, \"admin/users\", staff_headers)\n        post_schema = {s[\"key\"]: s for s in tmp_schema}\n        assert \"roles\" in post_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" not in post_schema[\"roles\"][\"options\"]\n\n        tmp_schema = self.get_dynamic_input_schema(\n            client, f\"admin/users/{user_uuid}\", staff_headers, method=\"put\"\n        )\n        put_schema = {s[\"key\"]: s for s in tmp_schema}\n\n        assert \"roles\" in put_schema\n        assert \"options\" in post_schema[\"roles\"]\n        assert \"normal_user\" in post_schema[\"roles\"][\"options\"]\n        assert \"admin_root\" not in post_schema[\"roles\"][\"options\"]\n\n        # Staff can't send role admin on put\n        r = client.put(\n            f\"{API_URI}/admin/users/{user_uuid}\",\n            json={\n                \"name\": faker.name(),\n                \"roles\": orjson.dumps([Role.ADMIN]).decode(\"UTF8\"),\n            },\n            headers=staff_headers,\n        )\n        assert r.status_code == 400\n\n        # Staff can't send role admin on post\n        schema = self.get_dynamic_input_schema(client, \"admin/users\", staff_headers)\n        data = self.buildData(schema)\n\n        data[\"email_notification\"] = True\n        data[\"is_active\"] = True\n        data[\"expiration\"] = None\n        data[\"roles\"] = orjson.dumps([Role.ADMIN]).decode(\"UTF8\")\n\n        r = client.post(f\"{API_URI}/admin/users\", json=data, headers=staff_headers)\n        assert r.status_code == 400\n\n        # Admin users are filtered out when asked from a Staff user\n        r = client.get(f\"{API_URI}/admin/users\", headers=admin_headers)\n        assert r.status_code == 200\n        users_list = self.get_content(r)\n        assert isinstance(users_list, list)\n        assert len(users_list) > 0\n        email_list = [u.get(\"email\") for u in users_list]\n        assert staff_email in email_list\n        assert BaseAuthentication.default_user in email_list\n\n        r = client.get(f\"{API_URI}/admin/users\", headers=staff_headers)\n        assert r.status_code == 200\n        users_list = self.get_content(r)\n        assert isinstance(users_list, list)\n        assert len(users_list) > 0\n        email_list = [u.get(\"email\") for u in users_list]\n        assert staff_email in email_list\n        assert BaseAuthentication.default_user not in email_list\n\n        # Staff users are not allowed to delete Admins\n        r = client.delete(f\"{API_URI}/admin/users/{admin_uuid}\", headers=staff_headers)\n        assert r.status_code == 404\n        content = self.get_content(r)\n        assert content == \"This user cannot be found or you are not authorized\"\n\n        r = client.delete(f\"{API_URI}/admin/users/{user_uuid}\", headers=staff_headers)\n        assert r.status_code == 204\n", "test_endpoints_authentication.py": "from restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication, Role\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_no_auth(self, client: FlaskClient) -> None:\n        r = client.get(f\"{API_URI}/tests/noauth\")\n        assert r.status_code == 200\n        assert self.get_content(r) == \"OK\"\n\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            headers, _ = self.do_login(client, None, None)\n\n            # Tokens are ignored\n            r = client.get(f\"{API_URI}/tests/noauth\", headers=headers)\n            assert r.status_code == 200\n            assert self.get_content(r) == \"OK\"\n\n        # Tokens are ignored even if invalid\n        r = client.get(\n            f\"{API_URI}/tests/noauth\", headers={\"Authorization\": \"Bearer invalid\"}\n        )\n        assert r.status_code == 200\n        assert self.get_content(r) == \"OK\"\n\n    def test_auth(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping authentication tests\")\n            return\n\n        r = client.get(f\"{API_URI}/tests/authentication\")\n        assert r.status_code == 401\n\n        r = client.get(\n            f\"{API_URI}/tests/authentication\",\n            headers={\"Authorization\": \"Bearer invalid\"},\n        )\n        assert r.status_code == 401\n\n        headers, token = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/tests/authentication\", headers=headers)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == BaseAuthentication.default_user\n\n        # Token type is case insensitive.\n        r = client.get(\n            f\"{API_URI}/tests/authentication\",\n            headers={\"Authorization\": f\"bearer {token}\"},\n        )\n        assert r.status_code == 200\n        r = client.get(\n            f\"{API_URI}/tests/authentication\",\n            headers={\"Authorization\": f\"BEARER {token}\"},\n        )\n        assert r.status_code == 200\n        r = client.get(\n            f\"{API_URI}/tests/authentication\",\n            headers={\"Authorization\": f\"BeArEr {token}\"},\n        )\n        assert r.status_code == 200\n\n        if not Env.get_bool(\"ALLOW_ACCESS_TOKEN_PARAMETER\"):\n            # access token parameter is not allowed by default\n            r = client.get(\n                f\"{API_URI}/tests/authentication\", query_string={\"access_token\": token}\n            )\n            assert r.status_code == 401\n\n    def test_optional_auth(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping authentication tests\")\n            return\n\n        # Optional authentication can accept missing tokens\n        r = client.get(f\"{API_URI}/tests/optionalauthentication\")\n        assert r.status_code == 204\n\n        headers, token = self.do_login(client, None, None)\n\n        # Or valid tokens\n        r = client.get(f\"{API_URI}/tests/optionalauthentication\", headers=headers)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == BaseAuthentication.default_user\n\n        # But not invalid tokens, i.e. if presented the tokens is always validated\n        r = client.get(\n            f\"{API_URI}/tests/authentication\",\n            headers={\"Authorization\": \"Bearer invalid\"},\n        )\n        assert r.status_code == 401\n\n        if not Env.get_bool(\"ALLOW_ACCESS_TOKEN_PARAMETER\"):\n            # access token parameter is not allowed by default\n            r = client.get(\n                f\"{API_URI}/tests/optionalauthentication\",\n                query_string={\"access_token\": token},\n            )\n            # query token is ignored but the endpoint accepts missing tokens\n            assert r.status_code == 204\n\n            r = client.get(\n                f\"{API_URI}/tests/optionalauthentication\",\n                query_string={\"access_token\": \"invalid\"},\n            )\n            # invalid tokens should be rejected, but query token is ignored\n            assert r.status_code == 204\n\n    def test_access_token_parameter(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping authentication tests\")\n            return\n\n        r = client.get(f\"{API_URI}/tests/queryauthentication\")\n        assert r.status_code == 401\n\n        r = client.get(\n            f\"{API_URI}/tests/queryauthentication\",\n            headers={\"Authorization\": \"Bearer invalid\"},\n        )\n        assert r.status_code == 401\n\n        headers, token = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/tests/queryauthentication\", headers=headers)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == BaseAuthentication.default_user\n\n        r = client.get(\n            f\"{API_URI}/tests/queryauthentication\", query_string={\"access_token\": token}\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == BaseAuthentication.default_user\n\n        r = client.get(\n            f\"{API_URI}/tests/queryauthentication\",\n            query_string={\"access_token\": \"invalid\"},\n        )\n        assert r.status_code == 401\n\n    def test_optional_access_token_parameter(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping authentication tests\")\n            return\n\n        # Optional authentication can accept missing tokens\n        r = client.get(f\"{API_URI}/tests/optionalqueryauthentication\")\n        assert r.status_code == 204\n\n        headers, token = self.do_login(client, None, None)\n\n        # Or valid tokens\n        r = client.get(f\"{API_URI}/tests/optionalqueryauthentication\", headers=headers)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == BaseAuthentication.default_user\n\n        # But not invalid tokens, i.e. if presented the tokens is always validated\n        r = client.get(\n            f\"{API_URI}/tests/optionalqueryauthentication\",\n            headers={\"Authorization\": \"Bearer invalid\"},\n        )\n        assert r.status_code == 401\n\n        r = client.get(\n            f\"{API_URI}/tests/optionalqueryauthentication\",\n            query_string={\"access_token\": token},\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == BaseAuthentication.default_user\n\n        r = client.get(\n            f\"{API_URI}/tests/optionalqueryauthentication\",\n            query_string={\"access_token\": \"invalid\"},\n        )\n        # invalid tokens should be rejected, but query token is ignored\n        assert r.status_code == 401\n\n    def test_authentication_with_multiple_roles(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping authentication tests\")\n            return\n\n        r = client.get(f\"{API_URI}/tests/manyrolesauthentication\")\n        assert r.status_code == 401\n\n        r = client.get(f\"{API_URI}/tests/unknownroleauthentication\")\n        assert r.status_code == 401\n\n        admin_headers, _ = self.do_login(client, None, None)\n\n        r = client.get(\n            f\"{API_URI}/tests/manyrolesauthentication\", headers=admin_headers\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == BaseAuthentication.default_user\n\n        r = client.get(\n            f\"{API_URI}/tests/unknownroleauthentication\", headers=admin_headers\n        )\n        assert r.status_code == 401\n\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\"):\n            uuid, data = self.create_user(client, roles=[Role.USER])\n            user_header, _ = self.do_login(\n                client, data.get(\"email\"), data.get(\"password\")\n            )\n\n            r = client.get(\n                f\"{API_URI}/tests/manyrolesauthentication\", headers=user_header\n            )\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, dict)\n            assert len(content) == 1\n            assert \"email\" in content\n            assert content[\"email\"] == data.get(\"email\")\n\n            r = client.get(\n                f\"{API_URI}/tests/unknownroleauthentication\", headers=user_header\n            )\n            assert r.status_code == 401\n\n            self.delete_user(client, uuid)\n\n    def test_authentication_with_auth_callback(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping authentication tests\")\n            return\n\n        auth = Connector.get_authentication_instance()\n        user = auth.get_user(username=BaseAuthentication.default_user)\n\n        assert user is not None\n\n        VALID = f\"/tests/preloadcallback/{user.uuid}\"\n        INVALID = \"/tests/preloadcallback/12345678-90ab-cdef-1234-567890abcdef\"\n        admin_headers, _ = self.do_login(client, None, None)\n\n        # Verify both endpoint ...\n\n        r = client.get(\n            f\"{API_URI}{VALID}\", query_string={\"test\": True}, headers=admin_headers\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert len(content) == 1\n        assert \"email\" in content\n        assert content[\"email\"] == user.email\n\n        r = client.get(\n            f\"{API_URI}{INVALID}\", query_string={\"test\": True}, headers=admin_headers\n        )\n        assert r.status_code == 401\n\n        # and get_schema!\n\n        r = client.get(\n            f\"{API_URI}{VALID}\",\n            query_string={\"get_schema\": True},\n            headers=admin_headers,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 1\n        assert content[0][\"key\"] == \"test\"\n        assert content[0][\"type\"] == \"boolean\"\n\n        r = client.get(\n            f\"{API_URI}{INVALID}\",\n            query_string={\"get_schema\": True},\n            headers=admin_headers,\n        )\n        assert r.status_code == 401\n", "test_endpoints_authorizations.py": "import re\nfrom typing import Optional\n\nimport pytest\n\nfrom restapi.config import ABS_RESTAPI_PATH\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.rest.loader import EndpointsLoader\nfrom restapi.services.authentication import Role\nfrom restapi.tests import SERVER_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp1(BaseTests):\n    @staticmethod\n    def get_path(method: str, path: str) -> str:\n        method = method.upper()\n        path = re.sub(r\"\\{[a-zA-Z0-9_]+\\}\", \"VARIABLE\", path)\n        path = re.sub(r\"\\<[a-zA-Z0-9_]+\\>\", \"VARIABLE\", path)\n        return f\"{method} {path}\"\n\n    # This utility returns a list of _core_ paths with the form:\n    # METHOD /path, e.g.\n    # GET /api/admin/users\n    # POST /api/admin/users\n    def get_paths(self, client: FlaskClient) -> list[str]:\n        loader = EndpointsLoader()\n        loader.load_endpoints_folder(ABS_RESTAPI_PATH)\n\n        paths: list[str] = []\n        for endpoint_class in loader.endpoints:\n            for method, path in endpoint_class.methods.items():\n                if path.startswith(\"/api/tests/\"):\n                    continue\n\n                paths.append(self.get_path(method, path))\n\n        return paths\n\n    # Test a single endpoint, remove the path from the list and return the new list\n    # Once tested all paths, the list should be empty\n    def check_endpoint(\n        self,\n        client: FlaskClient,\n        method: str,\n        endpoint: str,\n        headers: Optional[dict[str, str]],\n        expected_authorized: bool,\n        paths: list[str],\n    ) -> list[str]:\n        assert method in (\n            \"GET\",\n            \"POST\",\n            \"PUT\",\n            \"PATCH\",\n            \"DELETE\",\n        )\n\n        path = self.get_path(method, endpoint)\n\n        assert path in paths\n\n        # SERVER_URI because api and auth are already included in endpoint\n        full_endpoint = f\"{SERVER_URI}/{endpoint}\"\n\n        if method == \"GET\":\n            r = client.get(full_endpoint, headers=headers)\n        elif method == \"POST\":\n            r = client.post(full_endpoint, headers=headers)\n        elif method == \"PUT\":\n            r = client.put(full_endpoint, headers=headers)\n        elif method == \"PATCH\":\n            r = client.patch(full_endpoint, headers=headers)\n        elif method == \"DELETE\":\n            r = client.delete(full_endpoint, headers=headers)\n        else:  # pragma: no cover\n            pytest.fail(\"Unknown method\")\n\n        if expected_authorized:\n            assert r.status_code != 401\n        else:\n            assert r.status_code != 400\n\n        paths.remove(path)\n        return paths\n\n    def test_admin(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping admin authorizations tests\")\n            return\n\n        # List of all paths to be tested. After each test a path will be removed.\n        # At the end the list is expected to be empty\n        paths = self.get_paths(client)\n\n        uuid, data = self.create_user(client, roles=[Role.ADMIN])\n        headers, _ = self.do_login(client, data.get(\"email\"), data.get(\"password\"))\n\n        # These are public\n        paths = self.check_endpoint(client, \"GET\", \"/api/status\", headers, True, paths)\n        paths = self.check_endpoint(client, \"GET\", \"/api/specs\", headers, True, paths)\n        paths = self.check_endpoint(client, \"POST\", \"/auth/login\", headers, True, paths)\n        if Env.get_int(\"AUTH_MAX_LOGIN_ATTEMPTS\") > 0:\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/login/unlock/<token>\", headers, True, paths\n            )\n        if Env.get_bool(\"ALLOW_REGISTRATION\"):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile/activate\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/profile/activate/<token>\", headers, True, paths\n            )\n\n        if Env.get_bool(\"ALLOW_PASSWORD_RESET\") and Connector.check_availability(\n            \"smtp\"\n        ):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/reset\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/reset/<token>\", headers, True, paths\n            )\n\n        # These are allowed to each user\n        paths = self.check_endpoint(client, \"GET\", \"/auth/status\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PATCH\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(client, \"GET\", \"/auth/tokens\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/auth/tokens/<token>\", headers, True, paths\n        )\n\n        # These are allowed to coordinators\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/group/users\", headers, False, paths\n        )\n\n        # These are allowed to staff\n        # ... none\n\n        # These are allowed to admins\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users/<user_id>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/users\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/users/<user_id>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/users/<user_id>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/groups\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/groups\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/groups/<group_id>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/groups/<group_id>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/logins\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/tokens\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/tokens/<token>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/stats\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/mail\", headers, True, paths\n        )\n\n        # logout MUST be the last one or the token will be invalidated!! :-)\n        paths = self.check_endpoint(client, \"GET\", \"/auth/logout\", headers, True, paths)\n\n        assert paths == []\n\n        self.delete_user(client, uuid)\n\n    def test_staff(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping staff authorizations tests\")\n            return\n\n        auth = Connector.get_authentication_instance()\n        auth.get_roles()\n\n        if Role.STAFF.value not in [\n            r.name for r in auth.get_roles()\n        ]:  # pragma: no cover\n            log.warning(\"Skipping authorization tests on role Staff (not enabled)\")\n            return\n\n        # List of all paths to be tested. After each test a path will be removed.\n        # At the end the list is expected to be empty\n        paths = self.get_paths(client)\n\n        uuid, data = self.create_user(client, roles=[Role.STAFF])\n        headers, _ = self.do_login(client, data.get(\"email\"), data.get(\"password\"))\n\n        # These are public\n        paths = self.check_endpoint(client, \"GET\", \"/api/status\", headers, True, paths)\n        paths = self.check_endpoint(client, \"GET\", \"/api/specs\", headers, True, paths)\n        paths = self.check_endpoint(client, \"POST\", \"/auth/login\", headers, True, paths)\n        if Env.get_int(\"AUTH_MAX_LOGIN_ATTEMPTS\") > 0:\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/login/unlock/<token>\", headers, True, paths\n            )\n        if Env.get_bool(\"ALLOW_REGISTRATION\"):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile/activate\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/profile/activate/<token>\", headers, True, paths\n            )\n\n        if Env.get_bool(\"ALLOW_PASSWORD_RESET\") and Connector.check_availability(\n            \"smtp\"\n        ):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/reset\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/reset/<token>\", headers, True, paths\n            )\n\n        # These are allowed to each user\n        paths = self.check_endpoint(client, \"GET\", \"/auth/status\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PATCH\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(client, \"GET\", \"/auth/tokens\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/auth/tokens/<token>\", headers, True, paths\n        )\n\n        # These are allowed to coordinators\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/group/users\", headers, False, paths\n        )\n\n        # These are allowed to staff\n        # ... none\n\n        # These are allowed to admins\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/groups\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/groups\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/groups/<group_id>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/groups/<group_id>\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/logins\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/tokens\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/tokens/<token>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/stats\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/mail\", headers, False, paths\n        )\n\n        # logout MUST be the last one or the token will be invalidated!! :-)\n        paths = self.check_endpoint(client, \"GET\", \"/auth/logout\", headers, True, paths)\n\n        assert paths == []\n\n        self.delete_user(client, uuid)\n\n    def test_coordinator(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping coordinator authorizations tests\")\n            return\n\n        # List of all paths to be tested. After each test a path will be removed.\n        # At the end the list is expected to be empty\n        paths = self.get_paths(client)\n\n        uuid, data = self.create_user(client, roles=[Role.COORDINATOR])\n        headers, _ = self.do_login(client, data.get(\"email\"), data.get(\"password\"))\n\n        # These are public\n        paths = self.check_endpoint(client, \"GET\", \"/api/status\", headers, True, paths)\n        paths = self.check_endpoint(client, \"GET\", \"/api/specs\", headers, True, paths)\n        paths = self.check_endpoint(client, \"POST\", \"/auth/login\", headers, True, paths)\n        if Env.get_int(\"AUTH_MAX_LOGIN_ATTEMPTS\") > 0:\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/login/unlock/<token>\", headers, True, paths\n            )\n        if Env.get_bool(\"ALLOW_REGISTRATION\"):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile/activate\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/profile/activate/<token>\", headers, True, paths\n            )\n\n        if Env.get_bool(\"ALLOW_PASSWORD_RESET\") and Connector.check_availability(\n            \"smtp\"\n        ):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/reset\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/reset/<token>\", headers, True, paths\n            )\n\n        # These are allowed to each user\n        paths = self.check_endpoint(client, \"GET\", \"/auth/status\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PATCH\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(client, \"GET\", \"/auth/tokens\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/auth/tokens/<token>\", headers, True, paths\n        )\n\n        # These are allowed to coordinators\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/group/users\", headers, True, paths\n        )\n\n        # These are allowed to staff\n        # ... none\n\n        # These are allowed to admins\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/groups\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/groups\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/groups/<group_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/groups/<group_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/logins\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/tokens\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/tokens/<token>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/stats\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/mail\", headers, False, paths\n        )\n\n        # logout MUST be the last one or the token will be invalidated!! :-)\n        paths = self.check_endpoint(client, \"GET\", \"/auth/logout\", headers, True, paths)\n\n        assert paths == []\n\n        self.delete_user(client, uuid)\n\n    def test_user(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping user authorizations tests\")\n            return\n\n        # List of all paths to be tested. After each test a path will be removed.\n        # At the end the list is expected to be empty\n        paths = self.get_paths(client)\n\n        uuid, data = self.create_user(client, roles=[Role.USER])\n        headers, _ = self.do_login(client, data.get(\"email\"), data.get(\"password\"))\n\n        # These are public\n        paths = self.check_endpoint(client, \"GET\", \"/api/status\", headers, True, paths)\n        paths = self.check_endpoint(client, \"GET\", \"/api/specs\", headers, True, paths)\n        paths = self.check_endpoint(client, \"POST\", \"/auth/login\", headers, True, paths)\n        if Env.get_int(\"AUTH_MAX_LOGIN_ATTEMPTS\") > 0:\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/login/unlock/<token>\", headers, True, paths\n            )\n        if Env.get_bool(\"ALLOW_REGISTRATION\"):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile/activate\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/profile/activate/<token>\", headers, True, paths\n            )\n\n        if Env.get_bool(\"ALLOW_PASSWORD_RESET\") and Connector.check_availability(\n            \"smtp\"\n        ):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/reset\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/reset/<token>\", headers, True, paths\n            )\n\n        # These are allowed to each user\n        paths = self.check_endpoint(client, \"GET\", \"/auth/status\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PATCH\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/auth/profile\", headers, True, paths\n        )\n        paths = self.check_endpoint(client, \"GET\", \"/auth/tokens\", headers, True, paths)\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/auth/tokens/<token>\", headers, True, paths\n        )\n\n        # These are allowed to coordinators\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/group/users\", headers, False, paths\n        )\n\n        # These are allowed to staff\n        # ... none\n\n        # These are allowed to admins\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/groups\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/groups\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/groups/<group_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/groups/<group_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/logins\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/tokens\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/tokens/<token>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/stats\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/mail\", headers, False, paths\n        )\n\n        # logout MUST be the last one or the token will be invalidated!! :-)\n        paths = self.check_endpoint(client, \"GET\", \"/auth/logout\", headers, True, paths)\n\n        assert paths == []\n\n        self.delete_user(client, uuid)\n\n    def test_public(self, client: FlaskClient) -> None:\n        # List of all paths to be tested. After each test a path will be removed.\n        # At the end the list is expected to be empty\n        paths = self.get_paths(client)\n        headers = None\n        # These are public\n        paths = self.check_endpoint(client, \"GET\", \"/api/status\", headers, True, paths)\n        paths = self.check_endpoint(client, \"GET\", \"/api/specs\", headers, True, paths)\n\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            assert paths == []\n\n            log.warning(\"Skipping other public authorizations tests\")\n            return\n\n        paths = self.check_endpoint(client, \"POST\", \"/auth/login\", headers, True, paths)\n\n        if Env.get_int(\"AUTH_MAX_LOGIN_ATTEMPTS\") > 0:\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/login/unlock/<token>\", headers, True, paths\n            )\n        if Env.get_bool(\"ALLOW_REGISTRATION\"):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/profile/activate\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/profile/activate/<token>\", headers, True, paths\n            )\n\n        if Env.get_bool(\"ALLOW_PASSWORD_RESET\") and Connector.check_availability(\n            \"smtp\"\n        ):\n            paths = self.check_endpoint(\n                client, \"POST\", \"/auth/reset\", headers, True, paths\n            )\n            paths = self.check_endpoint(\n                client, \"PUT\", \"/auth/reset/<token>\", headers, True, paths\n            )\n\n        # These are allowed to each user\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/status\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/profile\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PATCH\", \"/auth/profile\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/auth/profile\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/tokens\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/auth/tokens/<token>\", headers, False, paths\n        )\n\n        # These are allowed to coordinators\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/group/users\", headers, False, paths\n        )\n\n        # These are allowed to staff\n        # ... none\n\n        # These are allowed to admins\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/users\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/users/<user_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/groups\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/groups\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"PUT\", \"/api/admin/groups/<group_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/groups/<group_id>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/logins\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/tokens\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"DELETE\", \"/api/admin/tokens/<token>\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"GET\", \"/api/admin/stats\", headers, False, paths\n        )\n        paths = self.check_endpoint(\n            client, \"POST\", \"/api/admin/mail\", headers, False, paths\n        )\n\n        # logout MUST be the last one or the token will be invalidated!! :-)\n        paths = self.check_endpoint(\n            client, \"GET\", \"/auth/logout\", headers, False, paths\n        )\n\n        assert paths == []\n", "test_endpoints_autocomplete.py": "import random\n\nimport orjson\n\nfrom restapi.tests import API_URI, SERVER_URI, BaseTests, FlaskClient\n\n\nclass TestApp(BaseTests):\n    def test_autocomplete(self, client: FlaskClient) -> None:\n        # This test verifies that buildData is always able to randomly create\n        # valid inputs for endpoints with inputs defined by marshamallow schemas\n        schema = self.get_dynamic_input_schema(client, \"tests/autocomplete\", {})\n\n        assert schema[0][\"key\"] == \"elements\"\n        assert schema[0][\"type\"] == \"string[]\"\n        assert \"autocomplete_endpoint\" in schema[0]\n        assert \"autocomplete_id_bind\" in schema[0]\n        assert \"autocomplete_label_bind\" in schema[0]\n        assert \"autocomplete_show_id\" in schema[0]\n        assert schema[0][\"autocomplete_endpoint\"] == \"/api/tests/autocomplete\"\n        assert schema[0][\"autocomplete_id_bind\"] == \"my_id\"\n        assert schema[0][\"autocomplete_label_bind\"] == \"my_label\"\n        assert schema[0][\"autocomplete_show_id\"] is True\n\n        autocomplete_endpoint = f\"{SERVER_URI}{schema[0]['autocomplete_endpoint']}\"\n\n        r = client.get(f\"{autocomplete_endpoint}/nobody\")\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 0\n\n        r = client.get(f\"{autocomplete_endpoint}/oliver\")\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) > 0\n        assert schema[0][\"autocomplete_id_bind\"] in content[0]\n        assert schema[0][\"autocomplete_label_bind\"] in content[0]\n\n        r = client.get(f\"{autocomplete_endpoint}/s the\")\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) > 0\n        assert schema[0][\"autocomplete_id_bind\"] in content[0]\n        assert schema[0][\"autocomplete_label_bind\"] in content[0]\n\n        rand = random.SystemRandom()\n\n        data = []\n        for _ in range(0, 3):\n            element = rand.choice(content)\n            data.append(element[schema[0][\"autocomplete_id_bind\"]])\n\n        # put accepts a single id provided by the autocomplete endpoint\n        r = client.put(f\"{API_URI}/tests/autocomplete\", json={\"element\": data[0]})\n        assert r.status_code == 204\n\n        # post accepts a list of ids provided by the autocomplete endpoint\n        r = client.post(\n            f\"{API_URI}/tests/autocomplete\",\n            json={\"elements\": orjson.dumps(data).decode(\"UTF8\")},\n        )\n        assert r.status_code == 204\n", "test_endpoints_caching.py": "import time\nfrom datetime import datetime\n\nimport pytest\nfrom flask import Flask\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.services.cache import Cache\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\nUUID = 0\nCOUNTER = 1\n\nCONNECTOR_AVAILABLE = Connector.check_availability(\"redis\")\n\n\n@pytest.mark.skipif(\n    CONNECTOR_AVAILABLE, reason=\"This test needs Redis to be not available\"\n)\nclass TestAppNoRedis(BaseTests):\n    def test_caching_autocleaning(self, app: Flask) -> None:\n        with pytest.raises(ServiceUnavailable):\n            Cache.get_instance(app)\n\n\n@pytest.mark.skipif(\n    not CONNECTOR_AVAILABLE, reason=\"This test needs Redis to be available\"\n)\nclass TestAppWithRedis(BaseTests):\n    def test_caching_autocleaning(self, client: FlaskClient) -> None:\n        headers, _ = self.do_login(client, None, None)\n\n        # Syncronize this test to start at the beginning of the next second and\n        # prevent the test to overlap a change of second\n        # Since the caching is rounded to the second, few milliseconds cann make the\n        # difference, for example:\n        # A first request at 00:00:00.997 is cached\n        # A second request at 00:00:01.002 is no longer cached, even if only 5 millisec\n        # elapsed because the second changed\n        # Added 0.01 just to avoid to exactly start at the beginning of the second\n        t = 1.01 - datetime.now().microsecond / 1000000.0\n        log.critical(\"Sleeping {} sec\", t)\n        time.sleep(t)\n\n        # the GET method is cached for 1 second\n\n        # First response is not cached\n        r = client.get(f\"{API_URI}/tests/cache/short\")\n        assert r.status_code == 200\n        counter1 = self.get_content(r)\n\n        # Second response is cached\n        r = client.get(f\"{API_URI}/tests/cache/short\")\n        assert r.status_code == 200\n        assert self.get_content(r) == counter1\n\n        # Third response is no longer cached\n        time.sleep(1)\n\n        r = client.get(f\"{API_URI}/tests/cache/short\")\n        assert r.status_code == 200\n        counter2 = self.get_content(r)\n        assert counter2 != counter1\n\n        # Fourth response is cached again\n        r = client.get(f\"{API_URI}/tests/cache/short\")\n        assert r.status_code == 200\n        assert self.get_content(r) == counter2\n\n        # Endpoint is unauthenticated, headers are ignored when building the cache key\n        r = client.get(f\"{API_URI}/tests/cache/short\", headers=headers)\n        assert r.status_code == 200\n        assert self.get_content(r) == counter2\n\n        # Tokens are ignored even if invalid\n        r = client.get(\n            f\"{API_URI}/tests/cache/short\", headers={\"Authorization\": \"Bearer invalid\"}\n        )\n        assert r.status_code == 200\n        assert self.get_content(r) == counter2\n\n    def test_caching_general_clearing(self, client: FlaskClient) -> None:\n        headers, _ = self.do_login(client, None, None)\n\n        # get method is cached for 200 seconds\n\n        # First response is not cached\n        r = client.get(f\"{API_URI}/tests/cache/long\")\n        assert r.status_code == 200\n        counter1 = self.get_content(r)\n\n        # Second response is cached\n        r = client.get(f\"{API_URI}/tests/cache/long\")\n        assert r.status_code == 200\n        assert self.get_content(r) == counter1\n\n        # Empty all the cache\n        Cache.clear()\n\n        # Third response is no longer cached\n        r = client.get(f\"{API_URI}/tests/cache/long\")\n        assert r.status_code == 200\n        counter2 = self.get_content(r)\n        assert counter2 != counter1\n\n        # Response is still cached\n        r = client.get(f\"{API_URI}/tests/cache/long\")\n        assert r.status_code == 200\n        assert self.get_content(r) == counter2\n\n        # Empty the endpoint cache\n        client.delete(f\"{API_URI}/tests/cache/long\")\n\n        # Second response is no longer cached\n        r = client.get(f\"{API_URI}/tests/cache/long\")\n        assert r.status_code == 200\n        counter3 = self.get_content(r)\n        assert counter3 != counter2\n\n        # Response is still cached\n        r = client.get(f\"{API_URI}/tests/cache/long\")\n        assert r.status_code == 200\n        assert self.get_content(r) == counter3\n\n        # Endpoint is unauthenticated, headers are ignored when building the cache key\n        r = client.get(f\"{API_URI}/tests/cache/long\", headers=headers)\n        assert r.status_code == 200\n        assert self.get_content(r) == counter3\n\n        # Tokens are ignored even if invalid\n        r = client.get(\n            f\"{API_URI}/tests/cache/long\", headers={\"Authorization\": \"Bearer invalid\"}\n        )\n        assert r.status_code == 200\n        assert self.get_content(r) == counter3\n\n    def test_cached_authenticated_endpoint(self, client: FlaskClient) -> None:\n        headers1, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/tests/cache/auth\", headers=headers1)\n        assert r.status_code == 200\n        resp1 = self.get_content(r)\n        assert isinstance(resp1, list)\n        # counter is 1 because this is the first request to this endpoint\n        assert resp1[COUNTER] == 1\n\n        r = client.get(f\"{API_URI}/tests/cache/auth\", headers=headers1)\n        assert r.status_code == 200\n        resp2 = self.get_content(r)\n        assert isinstance(resp2, list)\n        assert resp2[UUID] == resp1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert resp2[COUNTER] == 1\n\n        r = client.get(\n            f\"{API_URI}/tests/cache/auth\", headers={\"Authorization\": \"Bearer invalid\"}\n        )\n        assert r.status_code == 401\n\n        # Wrong token does not affected the cache\n        r = client.get(f\"{API_URI}/tests/cache/auth\", headers=headers1)\n        assert r.status_code == 200\n        resp2bis = self.get_content(r)\n        assert isinstance(resp2bis, list)\n        assert resp2bis[UUID] == resp1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert resp2bis[COUNTER] == 1\n\n        headers2, _ = self.do_login(client, None, None)\n        # Same user but different token, the cache should not be used\n        r = client.get(f\"{API_URI}/tests/cache/auth\", headers=headers2)\n        assert r.status_code == 200\n        resp3 = self.get_content(r)\n        assert isinstance(resp3, list)\n        assert resp3[UUID] == resp1[UUID]\n        assert resp3[UUID] == resp2[UUID]\n        assert resp3[COUNTER] == 2\n\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\"):\n            # Create a new user on the fly to test the cached endpoint\n            uuid, data = self.create_user(client)\n            headers3, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n\n            # Another user, the response must change\n            r = client.get(f\"{API_URI}/tests/cache/auth\", headers=headers3)\n            assert r.status_code == 200\n            resp4 = self.get_content(r)\n            assert isinstance(resp4, list)\n            assert resp4[UUID] == uuid\n            assert resp4[UUID] != resp1[UUID]\n            assert resp4[UUID] != resp2[UUID]\n            assert resp4[UUID] != resp3[UUID]\n            # The counter changed, because the response is not replied from the cache\n            assert resp4[COUNTER] == 3\n\n            # Same token, response must be cached\n            r = client.get(f\"{API_URI}/tests/cache/auth\", headers=headers3)\n            assert r.status_code == 200\n            resp5 = self.get_content(r)\n            assert isinstance(resp5, list)\n            assert resp5[UUID] == uuid\n            assert resp5[UUID] == resp4[UUID]\n            # Same counter as above, because the response is replied from the cache\n            assert resp5[COUNTER] == 3\n\n            self.delete_user(client, uuid)\n\n    def test_cached_semiauthenticated_endpoint(self, client: FlaskClient) -> None:\n        r = client.get(f\"{API_URI}/tests/cache/optionalauth\")\n        assert r.status_code == 200\n        nonauthenticated1 = self.get_content(r)\n        assert isinstance(nonauthenticated1, list)\n        assert nonauthenticated1[UUID] == \"N/A\"\n        # counter is 1 because this is the first request to this endpoint\n        assert nonauthenticated1[COUNTER] == 1\n\n        r = client.get(f\"{API_URI}/tests/cache/optionalauth\")\n        assert r.status_code == 200\n        nonauthenticated2 = self.get_content(r)\n        assert isinstance(nonauthenticated2, list)\n        assert nonauthenticated2[UUID] == \"N/A\"\n        # Same counter as above, because the response is replied from the cache\n        assert nonauthenticated2[COUNTER] == 1\n\n        headers, _ = self.do_login(client, None, None)\n        r = client.get(f\"{API_URI}/tests/cache/optionalauth\", headers=headers)\n        assert r.status_code == 200\n        authenticated1 = self.get_content(r)\n        assert isinstance(authenticated1, list)\n        assert authenticated1[UUID] != \"N/A\"\n        # The counter changed, because the response is not replied from the cache\n        assert authenticated1[COUNTER] == 2\n\n        # Token cached => cache should be used\n        r = client.get(f\"{API_URI}/tests/cache/optionalauth\", headers=headers)\n        assert r.status_code == 200\n        authenticated2 = self.get_content(r)\n        assert isinstance(authenticated2, list)\n        assert authenticated2[UUID] == authenticated1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert authenticated2[COUNTER] == 2\n\n        # New token => no cache\n        headers, _ = self.do_login(client, None, None)\n        r = client.get(f\"{API_URI}/tests/cache/optionalauth\", headers=headers)\n        assert r.status_code == 200\n        authenticated2 = self.get_content(r)\n        assert isinstance(authenticated2, list)\n        assert authenticated2[UUID] == authenticated1[UUID]\n        # Counter changed\n        assert authenticated2[COUNTER] == 3\n\n        r = client.get(\n            f\"{API_URI}/tests/cache/optionalauth\",\n            headers={\"Authorization\": \"Bearer invalid\"},\n        )\n        assert r.status_code == 401\n\n    def test_cached_authenticated_param_endpoint(self, client: FlaskClient) -> None:\n        headers1, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/tests/cache/paramauth\", headers=headers1)\n        assert r.status_code == 200\n        resp1 = self.get_content(r)\n        assert isinstance(resp1, list)\n        # counter is 1 because this is the first request to this endpoint\n        assert resp1[COUNTER] == 1\n\n        r = client.get(f\"{API_URI}/tests/cache/paramauth\", headers=headers1)\n        assert r.status_code == 200\n        resp2 = self.get_content(r)\n        assert isinstance(resp2, list)\n        assert resp2[UUID] == resp1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert resp2[COUNTER] == resp1[COUNTER]\n        assert resp2[COUNTER] == 1\n\n        headers2, token2 = self.do_login(client, None, None)\n        # Test by using access_token parameter instead of Headers\n        r = client.get(\n            f\"{API_URI}/tests/cache/paramauth\", query_string={\"access_token\": token2}\n        )\n        assert r.status_code == 200\n        resp3 = self.get_content(r)\n        assert isinstance(resp3, list)\n        # This is the same user, uuid is unchanged\n        assert resp3[UUID] == resp1[UUID]\n        # but counter changed, because the response is not replied from the cache\n        assert resp3[COUNTER] != resp1[COUNTER]\n        assert resp3[COUNTER] == 2\n\n        r = client.get(\n            f\"{API_URI}/tests/cache/paramauth\", query_string={\"access_token\": token2}\n        )\n        assert r.status_code == 200\n        resp4 = self.get_content(r)\n        assert isinstance(resp4, list)\n        assert resp4[UUID] == resp1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert resp4[COUNTER] == resp3[COUNTER]\n        assert resp4[COUNTER] == 2\n\n        # Cache is stored starting from the access_token parameter,\n        # but the token is the same also if provided as header\n        r = client.get(f\"{API_URI}/tests/cache/paramauth\", headers=headers2)\n        assert r.status_code == 200\n        resp5 = self.get_content(r)\n        assert isinstance(resp5, list)\n        assert resp5[UUID] == resp1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert resp5[COUNTER] == resp3[COUNTER]\n        assert resp5[COUNTER] == 2\n\n    def test_cached_semiauthenticated_param_endpoint(self, client: FlaskClient) -> None:\n        r = client.get(f\"{API_URI}/tests/cache/optionalparamauth\")\n        assert r.status_code == 200\n        nonauthenticated1 = self.get_content(r)\n        assert isinstance(nonauthenticated1, list)\n        assert nonauthenticated1[UUID] == \"N/A\"\n        # counter is 1 because this is the first request to this endpoint\n        assert nonauthenticated1[COUNTER] == 1\n\n        r = client.get(f\"{API_URI}/tests/cache/optionalparamauth\")\n        assert r.status_code == 200\n        nonauthenticated2 = self.get_content(r)\n        assert isinstance(nonauthenticated2, list)\n        assert nonauthenticated2[UUID] == \"N/A\"\n        # Same counter as above, because the response is replied from the cache\n        assert nonauthenticated2[COUNTER] == 1\n\n        headers1, token1 = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/tests/cache/optionalparamauth\", headers=headers1)\n        assert r.status_code == 200\n        authenticated1 = self.get_content(r)\n        assert isinstance(authenticated1, list)\n        assert authenticated1[UUID] != \"N/A\"\n        # The counter changed, because the response is not replied from the cache\n        assert authenticated1[COUNTER] == 2\n\n        r = client.get(f\"{API_URI}/tests/cache/optionalparamauth\", headers=headers1)\n        assert r.status_code == 200\n        authenticated2 = self.get_content(r)\n        assert isinstance(authenticated2, list)\n        assert authenticated2[UUID] != \"N/A\"\n        assert authenticated2[UUID] == authenticated1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert authenticated2[COUNTER] == 2\n\n        # Response is reply from the cache even if the token is provided as query param\n        r = client.get(\n            f\"{API_URI}/tests/cache/optionalparamauth\",\n            query_string={\"access_token\": token1},\n        )\n        assert r.status_code == 200\n        authenticated3 = self.get_content(r)\n        assert isinstance(authenticated3, list)\n        assert authenticated3[UUID] != \"N/A\"\n        assert authenticated3[UUID] == authenticated1[UUID]\n        # Same counter as above, because the response is replied from the cache\n        assert authenticated3[COUNTER] == 2\n\n        # Let's test another token => new cache key.\n        # This time access_token and then headers\n\n        headers2, token2 = self.do_login(client, None, None)\n        r = client.get(\n            f\"{API_URI}/tests/cache/optionalparamauth\",\n            query_string={\"access_token\": token2},\n        )\n        assert r.status_code == 200\n        authenticated4 = self.get_content(r)\n        assert isinstance(authenticated4, list)\n        assert authenticated4[UUID] != \"N/A\"\n        # Different token, but the user is the same\n        assert authenticated4[UUID] == authenticated1[UUID]\n        # Counter increased\n        assert authenticated4[COUNTER] == 3\n\n        r = client.get(\n            f\"{API_URI}/tests/cache/optionalparamauth\",\n            query_string={\"access_token\": token2},\n        )\n        assert r.status_code == 200\n        authenticated5 = self.get_content(r)\n        assert isinstance(authenticated5, list)\n        assert authenticated5[UUID] != \"N/A\"\n        # Different token, but the user is the same\n        assert authenticated5[UUID] == authenticated1[UUID]\n        # Counter increased\n        assert authenticated5[COUNTER] == authenticated4[COUNTER]\n        assert authenticated5[COUNTER] == 3\n\n        r = client.get(f\"{API_URI}/tests/cache/optionalparamauth\", headers=headers2)\n        assert r.status_code == 200\n        authenticated6 = self.get_content(r)\n        assert isinstance(authenticated6, list)\n        assert authenticated6[UUID] != \"N/A\"\n        # Different token, but the user is the same\n        assert authenticated6[UUID] == authenticated1[UUID]\n        # Counter increased\n        assert authenticated6[COUNTER] == authenticated4[COUNTER]\n        assert authenticated6[COUNTER] == 3\n", "test_endpoints_db_exceptions.py": "from faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import DEFAULT_GROUP_NAME\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_database_exceptions(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping dabase exceptions tests\")\n            return\n\n        # This is a special value. The endpoint will try to create a group without\n        # shortname. A BadRequest is expected because the database should refuse the\n        # entry due to the missing property\n        r = client.post(f\"{API_URI}/tests/database/400\")\n        assert r.status_code == 400\n        # This is the message of a DatabaseMissingRequiredProperty\n        assert self.get_content(r) == \"Missing property shortname required by Group\"\n\n        auth = Connector.get_authentication_instance()\n        default_group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert default_group is not None\n\n        # the /tests/database endpoint will change the default group fullname\n        # as a side effect to the test the database_transaction decorator\n        default_fullname = default_group.fullname\n\n        random_name = faker.pystr()\n\n        # This will create a new group with short/full name == random_name\n\n        r = client.post(f\"{API_URI}/tests/database/{random_name}\")\n        assert r.status_code == 200\n\n        default_group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert default_group is not None\n\n        # As a side effect the fullname of defaut_group is changed...\n        assert default_group.fullname != default_fullname\n\n        # ... and this is the new name\n        new_fullname = default_group.fullname\n\n        # This will try to create again a group with short/full name == random_name\n        # but this will fail due to unique keys\n        r = client.post(f\"{API_URI}/tests/database/{random_name}\")\n        assert r.status_code == 409\n        # This is the message of a DatabaseDuplicatedEntry\n        assert (\n            self.get_content(r)\n            == f\"A Group already exists with shortname: {random_name}\"\n        )\n        # The default group will not change again because the\n        # database_transaction decorator will undo the change\n        default_group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert default_group is not None\n\n        assert default_group.fullname == new_fullname\n", "test_endpoints_depends_on.py": "from restapi.connectors import Connector\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\n\n\nclass TestApp(BaseTests):\n    def test_depends_on(self, client: FlaskClient) -> None:\n        if Connector.check_availability(\"neo4j\"):\n            r = client.get(f\"{API_URI}/tests/depends_on/neo4j\")\n            assert r.status_code == 200\n\n            r = client.get(f\"{API_URI}/tests/depends_on_not/neo4j\")\n            assert r.status_code == 404\n\n        else:\n            r = client.get(f\"{API_URI}/tests/depends_on/neo4j\")\n            assert r.status_code == 404\n\n            r = client.get(f\"{API_URI}/tests/depends_on_not/neo4j\")\n            assert r.status_code == 200\n", "test_endpoints_encoding.py": "import gzip\nfrom io import BytesIO\n\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\n\n\nclass TestApp(BaseTests):\n    def test_encoding(self, client: FlaskClient) -> None:\n        \"\"\"Test that the flask server is running and reachable\"\"\"\n\n        # Check success\n        alive_message = \"Server is alive\"\n\n        # Verify default is not HTML\n        r = client.get(f\"{API_URI}/status\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert response == alive_message\n\n        # Check HTML response if agent/request is text/html\n        headers = {\"Accept\": \"text/html\"}\n        r = client.get(f\"{API_URI}/status\", headers=headers)\n        assert r.status_code == 200\n        output = r.data.decode(\"utf-8\")\n        assert output != alive_message\n        assert alive_message in output\n        assert \"<html\" in output\n        assert \"<body>\" in output\n\n        # HTML response are only enabled for few endpoints\n        r = client.get(f\"{API_URI}/tests/gzip/1\", headers=headers)\n        assert r.status_code == 200\n        output = r.data.decode(\"utf-8\")\n        assert \"<html\" not in output\n\n        # Verify gzip encoding\n        headers = {\"Accept-Encoding\": \"gzip\"}\n        r = client.get(f\"{API_URI}/status\", headers=headers)\n        assert r.status_code == 200\n        # gzip compression is not enabled for small contents\n        assert r.headers.get(\"Content-Encoding\") != \"gzip\"\n\n        r = client.get(f\"{API_URI}/tests/gzip/0\", headers=headers)\n        assert r.status_code == 416\n        # gzip compression is not enabled for error responses\n        assert r.headers.get(\"Content-Encoding\") != \"gzip\"\n\n        r = client.get(f\"{API_URI}/tests/gzip/1\", headers=headers)\n        assert r.status_code == 200\n        # gzip compression is not enabled for small contents\n        assert r.headers.get(\"Content-Encoding\") != \"gzip\"\n\n        # This will return a long string of 1000 aaaaaaaaaaaaaaaaaaaa\n        r = client.get(f\"{API_URI}/tests/gzip/1000\", headers=headers)\n        assert r.status_code == 200\n        # A string with len 1000 is about 1 kb, still too small to enable gzip encoding\n        assert r.headers.get(\"Content-Encoding\") != \"gzip\"\n\n        # This will return a long string of 2000 aaaaaaaaaaaaaaa\n        r = client.get(f\"{API_URI}/tests/gzip/2000\")\n        assert r.status_code == 200\n        assert r.headers.get(\"Content-Encoding\") != \"gzip\"\n        uncompressed_output = r.data.decode(\"utf-8\")\n        assert r.headers.get(\"Content-Length\") == str(len(uncompressed_output))\n\n        # This will return a long gzipped string of 2000 aaaaaaaaaaaaaaa\n        r = client.get(f\"{API_URI}/tests/gzip/2000\", headers=headers)\n        assert r.status_code == 200\n        assert r.headers.get(\"Content-Encoding\") == \"gzip\"\n        gzipped_output = r.data\n\n        assert r.headers.get(\"Content-Length\") == str(len(gzipped_output))\n\n        assert len(gzipped_output) < len(uncompressed_output)\n\n        content = gzip.GzipFile(fileobj=BytesIO(gzipped_output)).read()\n\n        assert len(content) == len(uncompressed_output)\n        assert content.decode(\"utf-8\") == uncompressed_output\n", "test_endpoints_group_users.py": "from faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.services.authentication import Role\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_group_users(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping group/users tests\")\n            return\n\n        # Create group 1 with 1 Coordinator and 1 User\n        group1_uuid, _ = self.create_group(client)\n        _, user1_data = self.create_user(\n            client, roles=[Role.COORDINATOR], data={\"group\": group1_uuid}\n        )\n        _, user2_data = self.create_user(\n            client, roles=[Role.USER], data={\"group\": group1_uuid}\n        )\n\n        # Create group 2 with only 1 Coordinator\n        group2_uuid, _ = self.create_group(client)\n\n        _, user3_data = self.create_user(\n            client, roles=[Role.COORDINATOR], data={\"group\": group2_uuid}\n        )\n\n        # Verify POST / PUT and DELETE are not enabled\n        headers, _ = self.do_login(client, user1_data[\"email\"], user1_data[\"password\"])\n\n        r = client.post(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.put(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.delete(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.put(f\"{API_URI}/group/users/{group1_uuid}\", headers=headers)\n        assert r.status_code == 404\n\n        r = client.delete(f\"{API_URI}/group/users/{group1_uuid}\", headers=headers)\n        assert r.status_code == 404\n\n        # Verify GET response\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n\n        assert response is not None\n        assert len(response) == 2\n        assert \"email\" in response[0]\n        assert \"name\" in response[0]\n        assert \"surname\" in response[0]\n        assert \"roles\" in response[0]\n        assert \"password\" not in response[0]\n        assert \"uuid\" not in response[0]\n        assert \"group\" not in response[0]\n        assert \"belongs_to\" not in response[0]\n        assert \"first_login\" not in response[0]\n        assert \"last_login\" not in response[0]\n        assert \"last_password_change\" not in response[0]\n        assert \"is_active\" not in response[0]\n        assert \"privacy_accepted\" not in response[0]\n        assert \"expiration\" not in response[0]\n\n        email1 = response[0][\"email\"]\n        email2 = response[1][\"email\"]\n\n        assert email1 == user1_data[\"email\"] or email2 == user1_data[\"email\"]\n        assert email1 == user2_data[\"email\"] or email2 == user2_data[\"email\"]\n        assert email1 != user3_data[\"email\"] and email2 != user3_data[\"email\"]\n\n        # Verify GET response with the other group\n\n        headers, _ = self.do_login(client, user3_data[\"email\"], user3_data[\"password\"])\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n\n        assert response is not None\n        assert len(response) == 1\n        assert \"email\" in response[0]\n        assert \"name\" in response[0]\n        assert \"surname\" in response[0]\n        assert \"roles\" in response[0]\n        assert \"password\" not in response[0]\n        assert \"uuid\" not in response[0]\n        assert \"group\" not in response[0]\n        assert \"belongs_to\" not in response[0]\n        assert \"first_login\" not in response[0]\n        assert \"last_login\" not in response[0]\n        assert \"last_password_change\" not in response[0]\n        assert \"is_active\" not in response[0]\n        assert \"privacy_accepted\" not in response[0]\n        assert \"expiration\" not in response[0]\n\n        assert response[0][\"email\"] == user3_data[\"email\"]\n        assert response[0][\"email\"] != user1_data[\"email\"]\n        assert response[0][\"email\"] != user2_data[\"email\"]\n\n        # Add an admin to group1\n        _, user4_data = self.create_user(\n            client, roles=[Role.ADMIN, Role.COORDINATOR], data={\"group\": group1_uuid}\n        )\n\n        # Verify as Admin AND Coordinator (Expected: all members, including admins)\n        headers, _ = self.do_login(client, user4_data[\"email\"], user4_data[\"password\"])\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        members = {r[\"email\"] for r in response}\n        assert len(members) == 3\n\n        assert user1_data[\"email\"] in members\n        assert user2_data[\"email\"] in members\n        assert user3_data[\"email\"] not in members\n        assert user4_data[\"email\"] in members\n\n        # Verify as Coordinator only (Expected: admins to be filtered out)\n        headers, _ = self.do_login(client, user1_data[\"email\"], user1_data[\"password\"])\n\n        r = client.get(f\"{API_URI}/group/users\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        members = {r[\"email\"] for r in response}\n\n        assert len(members) == 2\n\n        assert user1_data[\"email\"] in members\n        assert user2_data[\"email\"] in members\n        assert user3_data[\"email\"] not in members\n        assert user4_data[\"email\"] not in members\n", "test_endpoints_inputs.py": "import orjson\nimport pytest\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\n\n\nclass TestApp(BaseTests):\n    def test_inputs(self, client: FlaskClient) -> None:\n        # This test verifies that buildData is always able to randomly create\n        # valid inputs for endpoints with inputs defined by marshamallow schemas\n        schema = self.get_dynamic_input_schema(client, \"tests/inputs\", {})\n        # Expected number of fields\n        assert len(schema) == 14\n        for field in schema:\n            # Always in the schema\n            assert \"key\" in field\n            assert \"type\" in field\n            assert \"label\" in field\n            assert \"description\" in field\n            assert \"required\" in field\n\n            # Other optional keys\n            # - default\n            # - min\n            # - max\n            # - options\n            # - schema in case of nested fields\n\n        field = schema[0]\n        assert len(field) == 6  # 5 mandatory fields + min\n        assert field[\"key\"] == \"mystr\"\n        assert field[\"type\"] == \"string\"\n        # This is the default case: both label and description are not explicitly set\n        # if key is lower-cased the corrisponding label will be titled\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"min\" in field\n        assert field[\"min\"] == 4\n        assert \"max\" not in field\n\n        field = schema[1]\n        assert len(field) == 5  # 5 mandatory fields, min and max not set\n        assert field[\"key\"] == \"MYDATE\"\n        assert field[\"type\"] == \"date\"\n        # Here the key is not lower cased and the label is not explicitly set\n        # So the label will exactly match the key (without additiona of .title)\n        assert field[\"label\"] == field[\"key\"]\n        assert field[\"label\"] != field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n\n        field = schema[2]\n        assert len(field) == 7  # 5 mandatory fields + min + max\n        assert field[\"key\"] == \"MYDATETIME\"\n        assert field[\"type\"] == \"datetime\"\n        # Here the key is not lower cased and the label is not explicitly set\n        # So the label will exactly match the key (without additiona of .title)\n        assert field[\"label\"] == field[\"key\"]\n        assert field[\"label\"] != field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"min\" in field\n        assert \"max\" in field\n\n        field = schema[3]\n        assert len(field) == 7  # 5 mandatory fields + min + max\n        assert field[\"key\"] == \"myint_exclusive\"\n        assert field[\"type\"] == \"int\"\n        # Here an explicit label is defined but not a description, so is == to the label\n        assert field[\"label\"] != field[\"key\"]\n        assert field[\"label\"] != field[\"key\"].title()\n        assert field[\"label\"] == \"Int exclusive field\"\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"min\" in field\n        assert field[\"min\"] == 2\n        assert \"max\" in field\n        assert field[\"max\"] == 9\n\n        field = schema[4]\n        assert len(field) == 7  # 5 mandatory fields + min + max\n        assert field[\"key\"] == \"myint_inclusive\"\n        assert field[\"type\"] == \"int\"\n        # Here both label and description are explicitly set\n        assert field[\"label\"] != field[\"key\"]\n        assert field[\"label\"] != field[\"key\"].title()\n        assert field[\"label\"] == \"Int inclusive field\"\n        assert field[\"description\"] != field[\"label\"]\n        assert field[\"description\"] == \"This field accepts values in a defined range\"\n        assert field[\"required\"]\n        assert \"min\" in field\n        assert field[\"min\"] == 1\n        assert \"max\" in field\n        assert field[\"max\"] == 10\n\n        field = schema[5]\n        assert len(field) == 6  # 5 mandatory fields + options\n        assert field[\"key\"] == \"myselect\"\n        assert field[\"type\"] == \"string\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"options\" in field\n        assert isinstance(field[\"options\"], dict)\n        assert len(field[\"options\"]) == 2\n        assert \"a\" in field[\"options\"]\n        assert \"b\" in field[\"options\"]\n        # The field defines labels and keys for all options\n        assert field[\"options\"][\"a\"] == \"A\"\n        assert field[\"options\"][\"b\"] == \"B\"\n\n        field = schema[6]\n        assert len(field) == 6  # 5 mandatory fields + options\n        assert field[\"key\"] == \"myselect2\"\n        assert field[\"type\"] == \"string\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"options\" in field\n        assert isinstance(field[\"options\"], dict)\n        assert len(field[\"options\"]) == 2\n        assert \"a\" in field[\"options\"]\n        assert \"b\" in field[\"options\"]\n        # The field wrongly defines labels, so are defaulted to keys\n        assert field[\"options\"][\"a\"] == \"a\"\n        assert field[\"options\"][\"b\"] == \"b\"\n\n        field = schema[7]\n        assert len(field) == 6  # 5 mandatory fields + max\n        assert field[\"key\"] == \"mymaxstr\"\n        assert field[\"type\"] == \"string\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"min\" not in field\n        assert \"max\" in field\n        assert field[\"max\"] == 7\n\n        field = schema[8]\n        assert len(field) == 7  # 5 mandatory fields + min + max\n        assert field[\"key\"] == \"myequalstr\"\n        assert field[\"type\"] == \"string\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"min\" in field\n        assert \"max\" in field\n        assert field[\"min\"] == 6\n        assert field[\"max\"] == 6\n\n        field = schema[9]\n        assert len(field) == 6  # 5 mandatory fields + schema\n        assert field[\"key\"] == \"mynested\"\n        assert field[\"type\"] == \"nested\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"schema\" in field\n\n        field = schema[10]\n        assert len(field) == 6  # 5 mandatory fields + schema\n        assert field[\"key\"] == \"mynullablenested\"\n        assert field[\"type\"] == \"nested\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n        assert \"schema\" in field\n\n        field = schema[11]\n        assert len(field) == 5  # 5 mandatory fields\n        assert field[\"key\"] == \"mylist\"\n        assert field[\"type\"] == \"string[]\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n\n        field = schema[12]\n        assert len(field) == 5  # 5 mandatory fields\n        assert field[\"key\"] == \"mylist2\"\n        # The list is defined as List(CustomInt) and CustomInt is resolved as int\n        assert field[\"type\"] == \"int[]\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n\n        field = schema[13]\n        assert len(field) == 5  # 5 mandatory fields\n        assert field[\"key\"] == \"mylist3\"\n        # The type is key[] ... should be something more explicative like FieldName[]\n        # assert field[\"type\"] == \"CustomGenericField[]\"\n        assert field[\"type\"] == \"mylist3[]\"\n        assert field[\"label\"] == field[\"key\"].title()\n        assert field[\"description\"] == field[\"label\"]\n        assert field[\"required\"]\n\n        data = self.buildData(schema)\n\n        # mylist3 is a list of custom field, buildData can't automatically set a value\n        assert \"mylist3\" not in data\n        data[\"mylist3\"] = orjson.dumps([\"mycustominputvalue\"]).decode(\"UTF8\")\n\n        r = client.post(f\"{API_URI}/tests/inputs\", json=data)\n        assert r.status_code == 204\n\n        # This is to verify that access_token, if provided is excluded from parameters\n        # And do not raise any ValidationError for unknown input\n\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            _, token = self.do_login(client, None, None)\n            data[\"access_token\"] = token\n            r = client.post(f\"{API_URI}/tests/inputs\", json=data)\n            assert r.status_code == 204\n\n        # This is to verify that unknown inputs raise a ValidationError\n        data[\"unknown\"] = \"input\"\n        r = client.post(f\"{API_URI}/tests/inputs\", json=data)\n        assert r.status_code == 400\n\n    @pytest.mark.skipif(\n        not Connector.check_availability(\"neo4j\"),\n        reason=\"This test needs neo4j to be available\",\n    )\n    def test_neo4j_inputs(self, client: FlaskClient) -> None:\n        headers, _ = self.do_login(client, None, None)\n        schema = self.get_dynamic_input_schema(client, \"tests/neo4jinputs\", headers)\n        assert len(schema) == 1\n\n        field = schema[0]\n        assert field[\"key\"] == \"choice\"\n        # This is because the Neo4jChoice field is not completed for deserialization\n        # It is should be automatically translated into a select, with options by\n        # including a validation OneOf\n        assert \"options\" not in field\n\n        r = client.post(\n            f\"{API_URI}/tests/neo4jinputs\", json={\"choice\": \"A\"}, headers=headers\n        )\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"choice\" in response\n        assert \"key\" in response[\"choice\"]\n        assert \"description\" in response[\"choice\"]\n        assert response[\"choice\"][\"key\"] == \"A\"\n        assert response[\"choice\"][\"description\"] == \"AAA\"\n\n        assert \"relationship_count\" in response\n        assert isinstance(response[\"relationship_count\"], int)\n        assert response[\"relationship_count\"] > 0\n\n        assert \"relationship_single\" in response\n        assert isinstance(response[\"relationship_single\"], dict)\n        assert \"uuid\" in response[\"relationship_single\"]\n\n        assert \"relationship_many\" in response\n        assert isinstance(response[\"relationship_many\"], list)\n        assert len(response[\"relationship_many\"]) > 0\n        assert isinstance(response[\"relationship_many\"][0], dict)\n        assert \"token_type\" in response[\"relationship_many\"][0]\n\n        r = client.post(\n            f\"{API_URI}/tests/neo4jinputs\", json={\"choice\": \"B\"}, headers=headers\n        )\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"choice\" in response\n        assert \"key\" in response[\"choice\"]\n        assert \"description\" in response[\"choice\"]\n        assert response[\"choice\"][\"key\"] == \"B\"\n        assert response[\"choice\"][\"description\"] == \"BBB\"\n\n        r = client.post(\n            f\"{API_URI}/tests/neo4jinputs\", json={\"choice\": \"C\"}, headers=headers\n        )\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"choice\" in response\n        assert \"key\" in response[\"choice\"]\n        assert \"description\" in response[\"choice\"]\n        assert response[\"choice\"][\"key\"] == \"C\"\n        assert response[\"choice\"][\"description\"] == \"CCC\"\n\n        r = client.post(\n            f\"{API_URI}/tests/neo4jinputs\", json={\"choice\": \"D\"}, headers=headers\n        )\n        # This should fail, but Neo4jChoice are not validated as input\n        # assert r.status_code == 400\n        # Since validation is not implemented, D is accepted But since it is\n        # not included in the choice, the description will simply match the key\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"choice\" in response\n        assert \"key\" in response[\"choice\"]\n        assert \"description\" in response[\"choice\"]\n        assert response[\"choice\"][\"key\"] == \"D\"\n        assert response[\"choice\"][\"description\"] == \"D\"\n", "test_endpoints_login_ban.py": "import time\n\nimport pytest\nfrom faker import Faker\n\nfrom restapi.config import PRODUCTION, get_project_configuration\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication\nfrom restapi.tests import AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import OBSCURE_VALUE, Events, log\n\nmax_login_attempts = BaseAuthentication.MAX_LOGIN_ATTEMPTS\nban_duration = BaseAuthentication.FAILED_LOGINS_EXPIRATION.seconds\n\nBAN_MESSAGE = (\n    \"Sorry, this account is temporarily blocked \"\n    + \"due to the number of failed login attempts.\"\n)\n\n\nif not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n    log.warning(\"Skipping login ban tests\")\n\nelif max_login_attempts == 0:\n\n    class TestApp1(BaseTests):\n        def test_01_login_ban_not_enabled(self, client: FlaskClient) -> None:\n            uuid, data = self.create_user(client)\n            # Login attempts are not registered, let's try to fail the login many times\n            for _ in range(0, 10):\n                self.do_login(client, data[\"email\"], \"wrong\", status_code=401)\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].payload[\"username\"] == data[\"email\"]\n            assert events[0].url == \"/auth/login\"\n\n            # and verify that login is still allowed\n            headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n            assert headers is not None\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.login.value\n            assert events[0].user == data[\"email\"]\n            assert events[0].url == \"/auth/login\"\n\n            # Furthermore the login/unlock endpoint is now enabled\n            r = client.post(f\"{AUTH_URI}/login/unlock/token\")\n            assert r.status_code == 404\n\n            # Goodbye temporary user\n            self.delete_user(client, uuid)\n\nelse:\n    # This test executes a sleep(ban_duration)... this assert is to prevent to\n    # block the tests due to a too-long ban duration\n    assert ban_duration < 60\n\n    class TestApp2(BaseTests):\n        def verify_credentials_ban_notification(self) -> str:\n            # Verify email sent to notify credentials block,\n            # + extract and return the unlock url\n            mail = self.read_mock_email()\n            body = mail.get(\"body\", \"\")\n            project_tile = get_project_configuration(\n                \"project.title\", default=\"YourProject\"\n            )\n\n            assert body is not None\n            assert mail.get(\"headers\", \"\") is not None\n            title = \"Your credentials have been blocked\"\n            assert f\"Subject: {project_tile}: {title}\" in mail.get(\"headers\", \"\")\n            # Body can't be asserted if can be changed at project level...\n            # assert \"this email is to inform you that your credentials have been \"\n            # \"temporarily due to the number of failed login attempts\" in body\n            # assert \"inspect the list below to detect any unwanted login\" in body\n            # assert \"Your credentials will be automatically unlocked in\" in body\n\n            token = self.get_token_from_body(body)\n            assert token is not None\n            return token\n\n        def test_01_failed_login_ban(self, client: FlaskClient) -> None:\n            if not Env.get_bool(\"MAIN_LOGIN_ENABLE\"):  # pragma: no cover\n                log.warning(\"Skipping admin/users tests\")\n                return\n\n            uuid, data = self.create_user(client)\n\n            self.delete_mock_email()\n\n            for _ in range(0, max_login_attempts):\n                self.do_login(client, data[\"email\"], \"wrong\", status_code=401)\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].payload[\"username\"] == data[\"email\"]\n            assert events[0].url == \"/auth/login\"\n\n            self.verify_credentials_ban_notification()\n\n            # This should fail\n            headers, _ = self.do_login(\n                client, data[\"email\"], data[\"password\"], status_code=403\n            )\n            assert headers is None\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.refused_login.value\n            assert events[0].payload[\"username\"] == data[\"email\"]\n            assert (\n                events[0].payload[\"motivation\"]\n                == \"account blocked due to too many failed logins\"\n            )\n            assert events[0].url == \"/auth/login\"\n\n            reset_data = {\"reset_email\": data[\"email\"]}\n            r = client.post(f\"{AUTH_URI}/reset\", json=reset_data)\n            assert r.status_code == 403\n            assert self.get_content(r) == BAN_MESSAGE\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.refused_login.value\n            assert events[0].payload[\"username\"] == data[\"email\"]\n            assert (\n                events[0].payload[\"motivation\"]\n                == \"account blocked due to too many failed logins\"\n            )\n            assert events[0].url == \"/auth/reset\"\n\n            time.sleep(ban_duration)\n\n            headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n            assert headers is not None\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.login.value\n            assert events[0].user == data[\"email\"]\n            assert events[0].url == \"/auth/login\"\n\n            # Verify that already emitted tokens are not blocked\n            # 1) Block again the account\n            for _ in range(0, max_login_attempts):\n                self.do_login(client, data[\"email\"], \"wrong\", status_code=401)\n\n            # 2) Verify that the account is blocked\n            self.do_login(client, data[\"email\"], data[\"password\"], status_code=403)\n\n            # 3) Verify that the previously emitted token is still valid\n            r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n            assert r.status_code == 200\n\n            # Goodbye temporary user\n            self.delete_user(client, uuid)\n\n        def test_02_unlock_token(self, client: FlaskClient) -> None:\n            if not Env.get_bool(\"MAIN_LOGIN_ENABLE\"):  # pragma: no cover\n                log.warning(\"Skipping admin/users tests\")\n                return\n\n            uuid, data = self.create_user(client)\n\n            self.delete_mock_email()\n\n            for _ in range(0, max_login_attempts):\n                self.do_login(client, data[\"email\"], \"wrong\", status_code=401)\n\n            token = self.verify_credentials_ban_notification()\n\n            # This should fail\n            headers, _ = self.do_login(\n                client, data[\"email\"], data[\"password\"], status_code=403\n            )\n            assert headers is None\n\n            auth = Connector.get_authentication_instance()\n            logins = auth.get_logins(data[\"email\"])\n            login = logins[-1]\n            assert login.username == data[\"email\"]\n            assert login.failed\n            assert not login.flushed\n\n            logins = auth.get_logins(data[\"email\"], only_unflushed=True)\n            assert len(logins) > 0\n\n            # Check if token is valid\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 200\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.login_unlock.value\n            assert events[0].user == data[\"email\"]\n            assert events[0].target_type == \"User\"\n            assert events[0].url == f\"/auth/login/unlock/{token}\"\n\n            logins = auth.get_logins(data[\"email\"])\n            login = logins[-1]\n            assert login.username == data[\"email\"]\n            assert login.failed\n            assert login.flushed\n\n            logins = auth.get_logins(data[\"email\"], only_unflushed=True)\n            assert len(logins) == 0\n\n            # Now credentials are unlock again :-)\n            headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n            assert headers is not None\n\n            # Unlock token can be used twice\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n\n            # Verify that unlock tokens can't be used if the user is already unlocked\n            for _ in range(0, max_login_attempts):\n                self.do_login(client, data[\"email\"], \"wrong\", status_code=401)\n\n            token = self.verify_credentials_ban_notification()\n\n            # This should fail\n            headers, _ = self.do_login(\n                client, data[\"email\"], data[\"password\"], status_code=403\n            )\n            assert headers is None\n\n            time.sleep(ban_duration)\n\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n\n            # Verify that unlock tokens are invalidated by new tokens\n            for _ in range(0, max_login_attempts):\n                self.do_login(client, data[\"email\"], \"wrong\", status_code=401)\n\n            first_token = self.verify_credentials_ban_notification()\n\n            # This should fail\n            headers, _ = self.do_login(\n                client, data[\"email\"], data[\"password\"], status_code=403\n            )\n            assert headers is None\n\n            time.sleep(ban_duration)\n\n            for _ in range(0, max_login_attempts):\n                self.do_login(client, data[\"email\"], \"wrong\", status_code=401)\n\n            second_token = self.verify_credentials_ban_notification()\n\n            assert first_token != second_token\n\n            r = client.post(f\"{AUTH_URI}/login/unlock/{first_token}\")\n            assert r.status_code == 400\n\n            r = client.post(f\"{AUTH_URI}/login/unlock/{second_token}\")\n            assert r.status_code == 200\n\n            # Test invalid tokens\n\n            # Token created for another user\n            token = self.get_crafted_token(\"u\")\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n            c = self.get_content(r)\n            assert c == \"Invalid unlock token\"\n\n            # Token created with a wrong algorithm\n            token = self.get_crafted_token(\"u\", wrong_algorithm=True)\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n            c = self.get_content(r)\n            assert c == \"Invalid unlock token\"\n\n            # Token created with a wrong secret\n            token = self.get_crafted_token(\"u\", wrong_secret=True)\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n            c = self.get_content(r)\n            assert c == \"Invalid unlock token\"\n\n            # Token created for another user\n            headers, _ = self.do_login(client, None, None)\n            r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n            assert r.status_code == 200\n            response = self.get_content(r)\n            assert isinstance(response, dict)\n            uuid = str(response.get(\"uuid\"))\n\n            token = self.get_crafted_token(\"x\", user_id=uuid)\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n            c = self.get_content(r)\n            assert c == \"Invalid unlock token\"\n\n            # token created for the correct user, but from outside the system!!\n            token = self.get_crafted_token(\"u\", user_id=uuid)\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n            c = self.get_content(r)\n            assert c == \"Invalid unlock token\"\n\n            # Immature token\n            token = self.get_crafted_token(\"u\", user_id=uuid, immature=True)\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n            c = self.get_content(r)\n            assert c == \"Invalid unlock token\"\n\n            # Expired token\n            token = self.get_crafted_token(\"u\", user_id=uuid, expired=True)\n            r = client.post(f\"{AUTH_URI}/login/unlock/{token}\")\n            assert r.status_code == 400\n            c = self.get_content(r)\n            assert c == \"Invalid unlock token: this request is expired\"\n\n        def test_03_registration_and_login_ban(\n            self, client: FlaskClient, faker: Faker\n        ) -> None:\n            if Env.get_bool(\"ALLOW_REGISTRATION\"):\n                registration_data = {}\n                registration_data[\"email\"] = faker.ascii_email()\n                registration_data[\"name\"] = faker.first_name()\n                registration_data[\"surname\"] = faker.last_name()\n                registration_data[\"password\"] = faker.password(strong=True)\n                registration_data[\"password_confirm\"] = registration_data[\"password\"]\n                r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n                # now the user is created but INACTIVE, activation endpoint is needed\n                assert r.status_code == 200\n                registration_message = \"We are sending an email to your email address \"\n                registration_message += \"where you will find the link to activate \"\n                registration_message += \"your account\"\n                assert self.get_content(r) == registration_message\n\n                # Registration endpoint send 2 mail: the first is the activation link,\n                # the second (last) is the admin notification\n                mail = self.read_mock_email(previous=True)\n                body = mail.get(\"body\")\n                assert body is not None\n                assert mail.get(\"headers\") is not None\n                # Subject: is a key in the MIMEText\n                proto = \"https\" if PRODUCTION else \"http\"\n                assert f\"{proto}://localhost/public/register/\" in body\n\n                token = self.get_token_from_body(body)\n                assert token is not None\n\n                # 403 because the account is not activated\n                self.do_login(\n                    client,\n                    registration_data[\"email\"],\n                    registration_data[\"password\"],\n                    status_code=403,\n                )\n\n                events = self.get_last_events(1)\n                assert events[0].event == Events.refused_login.value\n                assert events[0].payload[\"username\"] == registration_data[\"email\"]\n                assert events[0].payload[\"motivation\"] == \"account not active\"\n                assert events[0].url == \"/auth/login\"\n\n                self.delete_mock_email()\n\n                for _ in range(0, max_login_attempts):\n                    # Event if non activated if password is wrong the status is 401\n                    self.do_login(\n                        client,\n                        registration_data[\"email\"],\n                        \"wrong\",\n                        status_code=401,\n                    )\n\n                events = self.get_last_events(1)\n                assert events[0].event == Events.failed_login.value\n                assert events[0].payload[\"username\"] == registration_data[\"email\"]\n                assert events[0].url == \"/auth/login\"\n\n                self.verify_credentials_ban_notification()\n\n                # After max_login_attempts the account is not blocked\n\n                # profile activation forbidden due to blocked acount\n                r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n                assert r.status_code == 403\n                assert self.get_content(r) == BAN_MESSAGE\n\n                events = self.get_last_events(1)\n                assert events[0].event == Events.refused_login.value\n                assert events[0].payload[\"username\"] == registration_data[\"email\"]\n                assert (\n                    events[0].payload[\"motivation\"]\n                    == \"account blocked due to too many failed logins\"\n                )\n                assert events[0].url == f\"/auth/profile/activate/{token}\"\n\n                # request activation forbidden due to blocked acount\n                r = client.post(\n                    f\"{AUTH_URI}/profile/activate\",\n                    json={\"username\": registration_data[\"email\"]},\n                )\n                assert r.status_code == 403\n                assert self.get_content(r) == BAN_MESSAGE\n\n                events = self.get_last_events(1)\n                assert events[0].event == Events.refused_login.value\n                assert events[0].payload[\"username\"] == registration_data[\"email\"]\n                assert (\n                    events[0].payload[\"motivation\"]\n                    == \"account blocked due to too many failed logins\"\n                )\n                assert events[0].url == \"/auth/profile/activate\"\n\n                time.sleep(ban_duration)\n\n                r = client.post(\n                    f\"{AUTH_URI}/profile/activate\",\n                    json={\"username\": registration_data[\"email\"]},\n                )\n                assert r.status_code == 200\n\n        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n\n            def test_04_totp_and_login_ban(self, client: FlaskClient) -> None:\n                uuid, data = self.create_user(client)\n\n                # Verify that login still works (TOTP will be automatically added)\n                headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n                assert headers is not None\n\n                # Verify that TOTP is required\n                headers, _ = self.do_login(\n                    client, data[\"email\"], data[\"password\"], status_code=403\n                )\n                assert headers is None\n\n                # Verify that wrong totp are refused\n                headers, _ = self.do_login(\n                    client,\n                    data[\"email\"],\n                    data[\"password\"],\n                    data={\"totp_code\": \"000000\"},\n                    status_code=401,\n                )\n                assert headers is not None\n\n                # Verify that correct totp are accepted\n                headers, _ = self.do_login(\n                    client,\n                    data[\"email\"],\n                    data[\"password\"],\n                    data={\"totp_code\": self.generate_totp(data[\"email\"])},\n                )\n                assert headers is not None\n\n                # Verify login ban due to wrong TOTPs\n\n                self.delete_mock_email()\n\n                for _ in range(0, max_login_attempts):\n                    self.do_login(\n                        client,\n                        data[\"email\"],\n                        data[\"password\"],\n                        data={\"totp_code\": \"000000\"},\n                        status_code=401,\n                    )\n\n                events = self.get_last_events(1)\n                assert events[0].event == Events.failed_login.value\n                assert \"username\" not in events[0].payload\n                assert \"totp\" in events[0].payload\n                assert events[0].payload[\"totp\"] == OBSCURE_VALUE\n                assert events[0].url == \"/auth/login\"\n\n                self.verify_credentials_ban_notification()\n\n                # Now the login is blocked\n                headers, _ = self.do_login(\n                    client, data[\"email\"], data[\"password\"], status_code=403\n                )\n                assert headers is None\n\n                events = self.get_last_events(1)\n                assert events[0].event == Events.refused_login.value\n                assert events[0].payload[\"username\"] == data[\"email\"]\n                assert (\n                    events[0].payload[\"motivation\"]\n                    == \"account blocked due to too many failed logins\"\n                )\n                assert events[0].url == \"/auth/login\"\n\n                time.sleep(ban_duration)\n\n                # Now the login works again\n                headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n                assert headers is not None\n\n                events = self.get_last_events(1)\n                assert events[0].event == Events.login.value\n                assert events[0].user == data[\"email\"]\n                assert events[0].url == \"/auth/login\"\n\n                # Goodbye temporary user\n                self.delete_user(client, uuid)\n\n        def test_05_no_notification_email_for_wrong_usernames(\n            self, client: FlaskClient, faker: Faker\n        ) -> None:\n            if not Env.get_bool(\"MAIN_LOGIN_ENABLE\"):  # pragma: no cover\n                log.warning(\"Skipping admin/users tests\")\n                return\n\n            uuid, data = self.create_user(client)\n\n            self.delete_mock_email()\n\n            # Just to verify that email is deleted\n            with pytest.raises(FileNotFoundError):\n                self.read_mock_email()\n\n            email = faker.ascii_email()\n            # Wrong credentials with a non existing email\n            # -> No notification will be sent\n            for _ in range(0, max_login_attempts):\n                self.do_login(client, email, data[\"password\"], status_code=401)\n\n            # Verify the ban (i.e. status 403)\n            headers, _ = self.do_login(client, email, data[\"password\"], status_code=403)\n            assert headers is None\n\n            # Verify that there are no mocked email\n            with pytest.raises(FileNotFoundError):\n                self.read_mock_email()\n\n            # Goodbye temporary user\n            self.delete_user(client, uuid)\n", "test_endpoints_login_expiration.py": "import time\nfrom datetime import datetime, timedelta\n\nimport pytz\n\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import Events, log\n\n\nclass TestApp2(BaseTests):\n    def test_01_login_expiration(self, client: FlaskClient) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping login expiration tests\")\n            return\n\n        # Let's create a new user with an expiration time of N seconds\n        expiration_time = 10\n        expiration = datetime.now(pytz.utc) + timedelta(seconds=expiration_time)\n        uuid, data = self.create_user(client, data={\"expiration\": expiration})\n\n        # The user is valid\n        valid_headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n        assert valid_headers is not None\n\n        # But after N seconds the login will be refused\n        time.sleep(expiration_time)\n\n        invalid_headers, error = self.do_login(\n            client,\n            data[\"email\"],\n            data[\"password\"],\n            status_code=403,\n        )\n        assert invalid_headers is None\n        assert error == \"Sorry, this account is expired\"\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.refused_login.value\n        assert events[0].payload[\"username\"] == data[\"email\"]\n        assert events[0].payload[\"motivation\"] == \"account expired\"\n        assert events[0].url == \"/auth/login\"\n\n        # This token was valid before the expiration, but should be no longer valid\n        # due to the short TTL set when emitted (capped to expiration time)\n        r = client.get(f\"{AUTH_URI}/status\", headers=valid_headers)\n        assert r.status_code == 401\n\n        if Env.get_bool(\"ALLOW_PASSWORD_RESET\"):\n            reset_data = {\"reset_email\": data[\"email\"]}\n            r = client.post(f\"{AUTH_URI}/reset\", json=reset_data)\n            assert r.status_code == 403\n            assert self.get_content(r) == \"Sorry, this account is expired\"\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.refused_login.value\n            assert events[0].payload[\"username\"] == data[\"email\"]\n            assert events[0].payload[\"motivation\"] == \"account expired\"\n            assert events[0].url == \"/auth/reset\"\n\n        # Let's extend the account validity for other N seconds\n        admin_headers, _ = self.do_login(client, None, None)\n        expiration = datetime.now(pytz.utc) + timedelta(seconds=expiration_time)\n        r = client.put(\n            f\"{API_URI}/admin/users/{uuid}\",\n            json={\"expiration\": expiration},\n            headers=admin_headers,\n        )\n        assert r.status_code == 204\n\n        # The user is valid again\n        valid_headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n        assert valid_headers is not None\n\n        # But after N seconds the login will be refused again\n        time.sleep(expiration_time)\n\n        invalid_headers, error = self.do_login(\n            client,\n            data[\"email\"],\n            data[\"password\"],\n            status_code=403,\n        )\n        assert invalid_headers is None\n        assert error == \"Sorry, this account is expired\"\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.refused_login.value\n        assert events[0].payload[\"username\"] == data[\"email\"]\n        assert events[0].payload[\"motivation\"] == \"account expired\"\n        assert events[0].url == \"/auth/login\"\n\n        # Test reduction of account validity\n\n        # Let's extent other N seconds\n        admin_headers, _ = self.do_login(client, None, None)\n        expiration = datetime.now(pytz.utc) + timedelta(seconds=expiration_time)\n        r = client.put(\n            f\"{API_URI}/admin/users/{uuid}\",\n            json={\"expiration\": expiration},\n            headers=admin_headers,\n        )\n        assert r.status_code == 204\n\n        # The user is valid again\n        valid_headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n        assert valid_headers is not None\n\n        # Let's set an already expired date\n        expiration = datetime.now(pytz.utc) - timedelta(seconds=expiration_time)\n        r = client.put(\n            f\"{API_URI}/admin/users/{uuid}\",\n            json={\"expiration\": expiration},\n            headers=admin_headers,\n        )\n        assert r.status_code == 204\n\n        # User is no longer valid\n        invalid_headers, error = self.do_login(\n            client,\n            data[\"email\"],\n            data[\"password\"],\n            status_code=403,\n        )\n        assert invalid_headers is None\n        assert error == \"Sorry, this account is expired\"\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.refused_login.value\n        assert events[0].payload[\"username\"] == data[\"email\"]\n        assert events[0].payload[\"motivation\"] == \"account expired\"\n        assert events[0].url == \"/auth/login\"\n\n        # This token was valid and original TTL was set >= now\n        # But when the user expiration were reduced the token was invalided\n        r = client.get(f\"{AUTH_URI}/status\", headers=valid_headers)\n        assert r.status_code == 401\n", "test_endpoints_login_profile_logout.py": "import base64\nimport time\n\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.tests import AUTH_URI, BaseAuthentication, BaseTests, FlaskClient\nfrom restapi.utilities.logs import OBSCURE_VALUE, Events, log\n\n\nclass TestApp(BaseTests):\n    def test_01_login(self, client: FlaskClient, faker: Faker) -> None:\n        \"\"\"Check that you can login and receive back your token\"\"\"\n\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping login tests\")\n            return\n\n        log.info(\"*** VERIFY CASE INSENSITIVE LOGIN\")\n        # BaseAuthentication.load_default_user()\n        # BaseAuthentication.load_roles()\n        USER = BaseAuthentication.default_user or \"just-to-prevent-None\"\n        PWD = BaseAuthentication.default_password or \"just-to-prevent-None\"\n\n        # Login by using upper case username\n        self.do_login(client, USER.upper(), PWD)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.login.value\n        assert events[0].user == USER\n        assert events[0].url == \"/auth/login\"\n\n        auth = Connector.get_authentication_instance()\n        logins = auth.get_logins(USER)\n        login = logins[-1]\n        assert login.username == USER\n\n        # Wrong credentials\n        # Off course PWD cannot be upper :D\n        self.do_login(client, USER, PWD.upper(), status_code=401)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.failed_login.value\n        assert events[0].payload[\"username\"] == USER\n        assert events[0].url == \"/auth/login\"\n\n        logins = auth.get_logins(USER)\n        login = logins[-1]\n        assert login.username == USER\n\n        log.info(\"*** VERIFY valid credentials\")\n        # Login by using normal username (no upper case)\n        headers, _ = self.do_login(client, None, None)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.login.value\n        assert events[0].user == USER\n        assert events[0].url == \"/auth/login\"\n\n        time.sleep(5)\n        # Verify MAX_PASSWORD_VALIDITY, if set\n        headers, token = self.do_login(client, None, None)\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.login.value\n        assert events[0].user == USER\n        assert events[0].url == \"/auth/login\"\n\n        self.save(\"auth_header\", headers)\n        self.save(\"auth_token\", token)\n\n        # Verify credentials\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, bool) and c\n\n        # this check verifies a BUG with neo4j causing crash of auth module\n        # when using a non-email-username to authenticate\n        log.info(\"*** VERIFY with a non-email-username\")\n\n        self.do_login(\n            client,\n            \"notanemail\",\n            \"[A-Za-z0-9]+\",\n            status_code=400,\n        )\n\n        # Check failure\n        log.info(\"*** VERIFY invalid credentials\")\n\n        random_email = faker.ascii_email()\n        self.do_login(\n            client,\n            random_email,\n            faker.password(strong=True),\n            status_code=401,\n        )\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.failed_login.value\n        assert events[0].payload[\"username\"] == random_email\n        assert events[0].url == \"/auth/login\"\n\n    def test_02_GET_profile(self, client: FlaskClient, faker: Faker) -> None:\n        \"\"\"Check if you can use your token for protected endpoints\"\"\"\n\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping profile tests\")\n            return\n\n        # Check success\n        log.info(\"*** VERIFY valid token\")\n        r = client.get(f\"{AUTH_URI}/profile\", headers=self.get(\"auth_header\"))\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        uuid = content.get(\"uuid\")\n\n        # Check failure\n        log.info(\"*** VERIFY invalid token\")\n        r = client.get(f\"{AUTH_URI}/profile\")\n        assert r.status_code == 401\n\n        # Token created for a fake user\n        token = self.get_crafted_token(\"f\")\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Token created for another user\n        token = self.get_crafted_token(\"x\")\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Token created for another user\n        token = self.get_crafted_token(\"f\", wrong_algorithm=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Token created for another user\n        token = self.get_crafted_token(\"f\", wrong_secret=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # token created for the correct user, but from outside the system!!\n        token = self.get_crafted_token(\"f\", user_id=uuid)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Immature token\n        token = self.get_crafted_token(\"f\", user_id=uuid, immature=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Expired token\n        token = self.get_crafted_token(\"f\", user_id=uuid, expired=True)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 401\n\n        # Sending malformed tokens\n        headers = {\"Authorization\": \"Bearer\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n        headers = {\"Authorization\": f\"Bearer '{faker.pystr()}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n        # Bearer realm is expected to be case insensitive\n        token = self.get(\"auth_token\")\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n\n        headers = {\"Authorization\": f\"bearer {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n\n        headers = {\"Authorization\": f\"BEARER {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 200\n\n        token = self.get(\"auth_token\")\n        headers = {\"Authorization\": f\"Bear {token}\"}\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n        USER = BaseAuthentication.default_user\n        PWD = BaseAuthentication.default_password\n        # Testing Basic Authentication (not allowed)\n        credentials = f\"{USER}:{PWD}\"\n        encoded_credentials = base64.b64encode(str.encode(credentials)).decode(\"utf-8\")\n\n        headers = {\"Authorization\": f\"Basic {encoded_credentials}\"}\n\n        r = client.post(f\"{AUTH_URI}/login\", headers=headers)\n        # Response is:\n        # {\n        #     'password': ['Missing data for required field.'],\n        #     'username': ['Missing data for required field.']\n        # }\n        assert r.status_code == 400\n\n        r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n        assert r.status_code == 401\n\n    def test_03_change_profile(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping change profile tests\")\n            return\n\n        headers, _ = self.do_login(client, None, None)\n\n        # update profile, no auth\n        r = client.put(f\"{AUTH_URI}/profile\")\n        assert r.status_code == 401\n        # update profile, no auth\n        r = client.patch(f\"{AUTH_URI}/profile\")\n        assert r.status_code == 401\n\n        # update profile, no data\n        r = client.patch(f\"{AUTH_URI}/profile\", json={}, headers=headers)\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.modify.value\n        assert events[0].user == BaseAuthentication.default_user\n        assert events[0].target_type == \"User\"\n        assert events[0].url == \"/auth/profile\"\n        # It is true in the core, but projects may introduce additional values\n        # and expand the input dictionary even if initially empty\n        # e.g. meteohub adds here the requests_expiration_days parameter\n        # assert len(events[0].payload) == 0\n\n        newname = faker.name()\n        newuuid = faker.pystr()\n\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"name\") is not None\n        assert c.get(\"name\") != newname\n        assert c.get(\"uuid\") is not None\n        assert c.get(\"uuid\") != newuuid\n\n        # update profile\n        data = {\"name\": newname, \"uuid\": newuuid}\n        r = client.patch(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        # uuid cannot be modified and will raise an unknown field\n        assert r.status_code == 400\n        data = {\"name\": newname}\n        r = client.patch(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.modify.value\n        assert events[0].user == BaseAuthentication.default_user\n        assert events[0].target_type == \"User\"\n        assert events[0].url == \"/auth/profile\"\n        # It is true in the core, but projects may introduce additional values\n        # and expand the input dictionary even if initially empty\n        # e.g. meteohub adds here the requests_expiration_days parameter\n        # assert len(events[0].payload) == 1\n        assert \"name\" in events[0].payload\n\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"name\") == newname\n        assert c.get(\"uuid\") != newuuid\n\n        # change password, no data\n        r = client.put(f\"{AUTH_URI}/profile\", json={}, headers=headers)\n        assert r.status_code == 400\n        # Sending a new_password and/or password_confirm without a password\n        newpassword = faker.password()\n        data = {\"new_password\": newpassword}\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n        data = {\"password_confirm\": newpassword}\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n        data = {\"new_password\": newpassword, \"password_confirm\": newpassword}\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data = {}\n        data[\"password\"] = faker.password(length=5)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"new_password\"] = faker.password(length=5)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"password_confirm\"] = faker.password(length=5)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"password\"] = BaseAuthentication.default_password\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        # Passwords are too short\n        data[\"password_confirm\"] = data[\"new_password\"]\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        # Trying to set new password == password... it is not permitted!\n        data[\"password_confirm\"] = data[\"password\"]\n        data[\"new_password\"] = data[\"password\"]\n\n        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n            data[\"totp_code\"] = BaseTests.generate_totp(BaseAuthentication.default_user)\n\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 409\n\n        # Change the password\n        data[\"new_password\"] = faker.password(strong=True)\n        data[\"password_confirm\"] = data[\"new_password\"]\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        # After a change password a spam of delete Token is expected\n        # Reverse the list and skip all delete tokens to find the change password event\n        events = self.get_last_events(100)\n        events.reverse()\n        for event in events:\n            if event.event == Events.delete.value:\n                assert event.target_type == \"Token\"\n                continue\n\n            assert event.event == Events.change_password.value\n            assert event.user == BaseAuthentication.default_user\n            break\n\n        # verify the new password\n        headers, _ = self.do_login(\n            client, BaseAuthentication.default_user, data[\"new_password\"]\n        )\n\n        # restore the previous password\n        data[\"password\"] = data[\"new_password\"]\n        data[\"new_password\"] = BaseAuthentication.default_password\n        data[\"password_confirm\"] = BaseAuthentication.default_password\n        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n            data[\"totp_code\"] = BaseTests.generate_totp(BaseAuthentication.default_user)\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        # After a change password a spam of delete Token is expected\n        # Reverse the list and skip all delete tokens to find the change password event\n        events = self.get_last_events(100)\n        events.reverse()\n        for event in events:\n            if event.event == Events.delete.value:\n                assert event.target_type == \"Token\"\n                continue\n\n            assert event.event == Events.change_password.value\n            assert event.user == BaseAuthentication.default_user\n            break\n\n        # verify the new password\n        headers, _ = self.do_login(\n            client, BaseAuthentication.default_user, BaseAuthentication.default_password\n        )\n\n        self.save(\"auth_header\", headers)\n\n    def test_04_logout(self, client: FlaskClient) -> None:\n        \"\"\"Check that you can logout with a valid token\"\"\"\n\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping logout tests\")\n            return\n\n        # Check success\n        log.info(\"*** VERIFY valid token\")\n        r = client.get(f\"{AUTH_URI}/logout\", headers=self.get(\"auth_header\"))\n        assert r.status_code == 204\n\n        events = self.get_last_events(2)\n\n        assert events[0].event == Events.delete.value\n        assert events[0].user == \"-\"\n        assert events[0].target_type == \"Token\"\n        assert events[0].url == \"/auth/logout\"\n\n        assert events[1].event == Events.logout.value\n        assert events[1].user == BaseAuthentication.default_user\n        assert events[1].url == \"/auth/logout\"\n\n        # Check failure\n        log.info(\"*** VERIFY invalid token\")\n        r = client.get(f\"{AUTH_URI}/logout\")\n        assert r.status_code == 401\n\n    def test_05_login_failures(self, client: FlaskClient) -> None:\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\") and Env.get_bool(\"AUTH_ENABLE\"):\n            # Create a new user on the fly to test the cached endpoint\n            _, data = self.create_user(client)\n            headers, _ = self.do_login(\n                client, data[\"email\"], data[\"password\"], test_failures=True\n            )\n            r = client.get(f\"{AUTH_URI}/logout\", headers=headers)\n            assert r.status_code == 204\n\n    def test_06_token_ip_validity(self, client: FlaskClient, faker: Faker) -> None:\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\") and Env.get_bool(\"AUTH_ENABLE\"):\n            if Env.get_int(\"AUTH_TOKEN_IP_GRACE_PERIOD\") < 10:\n                headers, _ = self.do_login(client, None, None)\n\n                r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n                assert r.status_code == 200\n\n                r = client.get(\n                    f\"{AUTH_URI}/status\",\n                    headers=headers,\n                    environ_base={\"REMOTE_ADDR\": faker.ipv4()},\n                )\n                assert r.status_code == 200\n\n                time.sleep(Env.get_int(\"AUTH_TOKEN_IP_GRACE_PERIOD\"))\n\n                r = client.get(\n                    f\"{AUTH_URI}/status\",\n                    headers=headers,\n                    environ_base={\"REMOTE_ADDR\": faker.ipv4()},\n                )\n                assert r.status_code == 401\n\n                # After the failure the token is still valid if used from the correct IP\n                r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n                assert r.status_code == 200\n\n                # Another option to provide IP is through the header passed by nginx\n                # This only works if PROXIED_CONNECTION is on\n                # (disabled by default, for security purpose)\n                if Env.get_bool(\"PROXIED_CONNECTION\"):\n                    headers[\"X-Forwarded-For\"] = faker.ipv4()  # type: ignore\n                    r = client.get(f\"{AUTH_URI}/status\", headers=headers)\n                    assert r.status_code == 401\n\n    if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n\n        def test_07_totp_failures(self, client: FlaskClient, faker: Faker) -> None:\n            uuid, data = self.create_user(client)\n\n            username = data[\"email\"]\n            password = data[\"password\"]\n            new_password = faker.password(strong=True)\n\n            invalid_totp = (\n                str(faker.pyint(min_value=0, max_value=9)),\n                str(faker.pyint(min_value=10, max_value=99)),\n                str(faker.pyint(min_value=100, max_value=999)),\n                str(faker.pyint(min_value=1000, max_value=9999)),\n                str(faker.pyint(min_value=10000, max_value=99999)),\n                str(faker.pyint(min_value=1000000, max_value=9999999)),\n                faker.pystr(6),\n            )\n            ###################################\n            # Test first password change\n            ###################################\n\n            data = {\n                \"username\": username,\n                \"password\": password,\n                \"new_password\": new_password,\n                \"password_confirm\": new_password,\n            }\n\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 403\n            resp = self.get_content(r)\n            assert isinstance(resp, dict)\n\n            assert \"actions\" in resp\n            assert \"errors\" in resp\n            assert \"FIRST LOGIN\" in resp[\"actions\"]\n            assert \"TOTP\" in resp[\"actions\"]\n            assert \"Please change your temporary password\" in resp[\"errors\"]\n            assert \"You do not provided a valid verification code\" in resp[\"errors\"]\n\n            # validate that the QR code is a valid PNG image\n            # ... not implemented\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.password_expired.value\n            assert events[0].user == username\n\n            data[\"totp_code\"] = \"000000\"\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is not valid\"\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].user == username\n            assert \"totp\" in events[0].payload\n            assert events[0].payload[\"totp\"] == OBSCURE_VALUE\n            assert events[0].url == \"/auth/login\"\n\n            for totp in invalid_totp:\n                data[\"totp_code\"] = totp\n                r = client.post(f\"{AUTH_URI}/login\", json=data)\n                assert r.status_code == 400\n                resp = self.get_content(r)\n                assert isinstance(resp, dict)\n                assert \"totp_code\" in resp\n                assert \"Invalid TOTP format\" in resp[\"totp_code\"]\n\n            data[\"totp_code\"] = self.generate_totp(username)\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 200\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.login.value\n            assert events[0].user == username\n            assert events[0].url == \"/auth/login\"\n\n            password = new_password\n\n            ###################################\n            # Test login\n            ###################################\n\n            data = {\n                \"username\": username,\n                \"password\": password,\n            }\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 403\n            resp = self.get_content(r)\n            assert isinstance(resp, dict)\n            assert \"actions\" in resp\n            assert \"errors\" in resp\n            assert \"TOTP\" in resp[\"actions\"]\n            assert \"You do not provided a valid verification code\" in resp[\"errors\"]\n\n            data[\"totp_code\"] = \"000000\"\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is not valid\"\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].user == username\n            assert \"totp\" in events[0].payload\n            assert events[0].payload[\"totp\"] == OBSCURE_VALUE\n            assert events[0].url == \"/auth/login\"\n\n            for totp in invalid_totp:\n                data[\"totp_code\"] = totp\n                r = client.post(f\"{AUTH_URI}/login\", json=data)\n                assert r.status_code == 400\n                resp = self.get_content(r)\n                assert isinstance(resp, dict)\n                assert \"totp_code\" in resp\n                assert \"Invalid TOTP format\" in resp[\"totp_code\"]\n\n            data[\"totp_code\"] = self.generate_totp(username)\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 200\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.login.value\n            assert events[0].user == username\n            assert events[0].url == \"/auth/login\"\n\n            ###################################\n            # Test password change\n            ###################################\n            new_password = faker.password(strong=True)\n            headers, _ = self.do_login(client, username, password)\n\n            data = {\n                \"password\": password,\n                \"new_password\": new_password,\n                \"password_confirm\": new_password,\n            }\n\n            r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is missing\"\n\n            data[\"totp_code\"] = \"000000\"\n            r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n            assert r.status_code == 401\n            assert self.get_content(r) == \"Verification code is not valid\"\n\n            events = self.get_last_events(1)\n            assert events[0].event == Events.failed_login.value\n            assert events[0].user == username\n            assert \"totp\" in events[0].payload\n            assert events[0].payload[\"totp\"] == OBSCURE_VALUE\n            assert events[0].url == \"/auth/profile\"\n\n            for totp in invalid_totp:\n                data[\"totp_code\"] = totp\n                r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n                assert r.status_code == 400\n                resp = self.get_content(r)\n                assert isinstance(resp, dict)\n                assert \"totp_code\" in resp\n                assert \"Invalid TOTP format\" in resp[\"totp_code\"]\n\n            data[\"totp_code\"] = self.generate_totp(username)\n            r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n            assert r.status_code == 204\n\n            # After a change password a spam of delete Token is expected\n            # Reverse the list and skip all delete tokens to find the change pwd event\n            events = self.get_last_events(100)\n            events.reverse()\n            for event in events:\n                if event.event == Events.delete.value:\n                    assert event.target_type == \"Token\"\n                    continue\n\n                assert event.event == Events.change_password.value\n                assert event.user == username\n                break\n\n            # verify the new password\n            headers, _ = self.do_login(client, username, new_password)\n\n            assert headers is not None\n\n            ###################################\n            # Goodbye temporary user\n            ###################################\n\n            self.delete_user(client, uuid)\n", "test_endpoints_outputs.py": "from restapi.tests import API_URI, BaseTests, FlaskClient\n\n\nclass TestApp(BaseTests):\n    def test_outputs(self, client: FlaskClient) -> None:\n        r = client.post(f\"{API_URI}/tests/outputs/string\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, str)\n        assert response == \"string\"\n\n        r = client.post(f\"{API_URI}/tests/outputs/whatever\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, str)\n        assert response == \"string\"\n\n        r = client.post(f\"{API_URI}/tests/outputs/list\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        assert response == [\"a\", \"b\", \"c\", \"c\"]\n\n        r = client.post(f\"{API_URI}/tests/outputs/tuple\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        # tuples are serialized as lists\n        assert isinstance(response, list)\n        assert response == [\"a\", \"b\", \"c\", \"c\"]\n\n        r = client.post(f\"{API_URI}/tests/outputs/set\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        # sets are serialized as lists\n        assert isinstance(response, list)\n        # But without duplicates :-) (and unordered...)\n        assert sorted(response) == [\"a\", \"b\", \"c\"]\n\n        r = client.post(f\"{API_URI}/tests/outputs/dict\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert response == {\"a\": 1, \"b\": 2, \"c\": 3}\n\n        r = client.post(f\"{API_URI}/tests/outputs/datetime\")\n        assert r.status_code == 200\n        response = self.get_content(r)\n        # datetimes are serialized as strings\n        assert isinstance(response, str)\n", "test_endpoints_pagination.py": "from restapi.tests import API_URI, BaseTests, FlaskClient\n\n# from restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_GET_specs(self, client: FlaskClient) -> None:\n        r = client.get(f\"{API_URI}/tests/pagination\")\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 20\n        assert content[0] == 1\n        assert content[19] == 20\n\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string={\"get_total\": True})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, int)\n        assert content == 150\n\n        # Check precedence: get_total wins\n        data = {\"get_total\": True, \"page\": 1, \"size\": 20}\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string=data)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, int)\n        assert content == 150\n\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, int)\n        assert content == 150\n\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string={\"page\": 2})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 20\n        assert content[0] == 21\n        assert content[19] == 40\n\n        data = {\"page\": 2, \"size\": 10}\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string=data)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 10\n        assert content[0] == 11\n        assert content[9] == 20\n\n        data = {\"page\": 2, \"size\": 100}\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string=data)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 50\n        assert content[0] == 101\n        assert content[49] == 150\n\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string={\"page\": 20})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 0\n\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string={\"size\": 101})\n        assert r.status_code == 400\n\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string={\"page\": -5})\n        assert r.status_code == 400\n\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string={\"size\": -5})\n        assert r.status_code == 400\n\n        data = {\"page\": -5, \"size\": -5}\n        r = client.get(f\"{API_URI}/tests/pagination\", query_string=data)\n        assert r.status_code == 400\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 20\n        assert content[0] == 1\n        assert content[19] == 20\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"get_total\": True})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, int)\n        assert content == 150\n\n        # Check precedence: get_total wins\n        data = {\"get_total\": True, \"page\": 1, \"size\": 20}\n        r = client.post(f\"{API_URI}/tests/pagination\", json=data)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, int)\n        assert content == 150\n\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, int)\n        assert content == 150\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"page\": 2})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 20\n        assert content[0] == 21\n        assert content[19] == 40\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"page\": 2, \"size\": 10})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 10\n        assert content[0] == 11\n        assert content[9] == 20\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"page\": 2, \"size\": 100})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 50\n        assert content[0] == 101\n        assert content[49] == 150\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"page\": 20})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 0\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"size\": 101})\n        assert r.status_code == 400\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"page\": -5})\n        assert r.status_code == 400\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"size\": -5})\n        assert r.status_code == 400\n\n        r = client.post(f\"{API_URI}/tests/pagination\", json={\"page\": -5, \"size\": -5})\n        assert r.status_code == 400\n\n        # Final check:\n        # get only accept query parameters\n        # post only accept body parameters\n\n        r = client.get(f\"{API_URI}/tests/pagination\", json={\"get_total\": True})\n        assert r.status_code == 200\n        content = self.get_content(r)\n        # Request get_total as body parameter but is ignored => sent a list of elements\n        assert isinstance(content, list)\n\n        # Request get_total as query parameter but is ignored => sent a list of elements\n        r = client.post(\n            f\"{API_URI}/tests/pagination\", json={}, query_string={\"get_total\": True}\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n", "test_endpoints_parameters_injection.py": "from restapi.env import Env\nfrom restapi.services.authentication import BaseAuthentication\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\n\n\nclass TestApp(BaseTests):\n    def test_parameter_injection(self, client: FlaskClient) -> None:\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            headers, _ = self.do_login(client, None, None)\n            r = client.get(f\"{API_URI}/tests/inject/myparam\", headers=headers)\n            assert r.status_code == 200\n\n            response = self.get_content(r)\n            assert isinstance(response, list)\n            assert len(response) == 3\n\n            # User is injected by the authentication decorator\n            assert response[0] == BaseAuthentication.default_user\n            # myparam is injected as url parameter\n            assert response[1] == \"myparam\"\n            # default_value is injected only because it has a... default value\n            assert response[2] == \"default_value\"\n", "test_endpoints_password_reset.py": "from faker import Faker\n\nfrom restapi.config import PRODUCTION, get_project_configuration\nfrom restapi.env import Env\nfrom restapi.tests import AUTH_URI, BaseAuthentication, BaseTests, FlaskClient\nfrom restapi.utilities.logs import Events, log\n\n\nclass TestApp(BaseTests):\n    def test_password_reset(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"ALLOW_PASSWORD_RESET\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Password reset is disabled, skipping tests\")\n            return\n\n        project_tile = get_project_configuration(\"project.title\", default=\"YourProject\")\n        proto = \"https\" if PRODUCTION else \"http\"\n\n        # Request password reset, missing information\n        r = client.post(f\"{AUTH_URI}/reset\")\n        assert r.status_code == 400\n\n        # Request password reset, missing information\n        r = client.post(f\"{AUTH_URI}/reset\", json=faker.pydict(2))\n        assert r.status_code == 400\n\n        headers, _ = self.do_login(client, None, None)\n\n        # Request password reset, wrong email\n        wrong_email = faker.ascii_email()\n        data = {\"reset_email\": wrong_email}\n        r = client.post(f\"{AUTH_URI}/reset\", json=data)\n        assert r.status_code == 403\n        msg = f\"Sorry, {wrong_email} is not recognized as a valid username\"\n        assert self.get_content(r) == msg\n\n        # Request password reset, correct email\n        data = {\"reset_email\": BaseAuthentication.default_user}\n        r = client.post(f\"{AUTH_URI}/reset\", json=data)\n        assert r.status_code == 200\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.reset_password_request.value\n        assert events[0].user == data[\"reset_email\"]\n        assert events[0].url == \"/auth/reset\"\n\n        resetmsg = \"We'll send instructions to the email provided \"\n        resetmsg += \"if it's associated with an account. \"\n        resetmsg += \"Please check your spam/junk folder.\"\n\n        assert self.get_content(r) == resetmsg\n\n        mail = self.read_mock_email()\n        body = mail.get(\"body\")\n        assert body is not None\n        assert mail.get(\"headers\") is not None\n        # Subject: is a key in the MIMEText\n        assert f\"Subject: {project_tile}: Password Reset\" in mail.get(\"headers\", \"\")\n        assert f\"{proto}://localhost/public/reset/\" in body\n\n        token = self.get_token_from_body(body)\n        assert token is not None\n\n        # Do password reset\n        r = client.put(f\"{AUTH_URI}/reset/thisisatoken\", json={})\n        # this token is not valid\n        assert r.status_code == 400\n\n        # Check if token is valid\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 204\n\n        # Token is still valid because no password still sent\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 204\n\n        # Missing information\n        data = {\n            \"new_password\": BaseAuthentication.default_password,\n        }\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json=data)\n        assert r.status_code == 400\n        assert self.get_content(r) == \"Invalid password\"\n\n        data = {\n            \"password_confirm\": BaseAuthentication.default_password,\n        }\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json=data)\n        assert r.status_code == 400\n        assert self.get_content(r) == \"Invalid password\"\n\n        # Request with old password\n        data = {\n            \"new_password\": BaseAuthentication.default_password,\n            \"password_confirm\": BaseAuthentication.default_password,\n        }\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json=data)\n        assert r.status_code == 409\n        error = \"The new password cannot match the previous password\"\n        assert self.get_content(r) == error\n\n        min_pwd_len = Env.get_int(\"AUTH_MIN_PASSWORD_LENGTH\", 9999)\n\n        # Password too short\n        data[\"new_password\"] = faker.password(min_pwd_len - 1)\n        data[\"password_confirm\"] = faker.password(min_pwd_len - 1)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json=data)\n        assert r.status_code == 400\n        data[\"password_confirm\"] = data[\"new_password\"]\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json=data)\n        assert r.status_code == 400\n\n        data[\"new_password\"] = faker.password(min_pwd_len, strong=True)\n        data[\"password_confirm\"] = faker.password(min_pwd_len, strong=True)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json=data)\n        assert r.status_code == 400\n        assert self.get_content(r) == \"New password does not match with confirmation\"\n\n        new_pwd = faker.password(min_pwd_len, strong=True)\n        data[\"new_password\"] = new_pwd\n        data[\"password_confirm\"] = new_pwd\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json=data)\n        assert r.status_code == 200\n\n        # After a change password a spam of delete Token is expected\n        # Reverse the list and skip all delete tokens to find the change password event\n        events = self.get_last_events(100)\n        events.reverse()\n        for event in events:\n            if event.event == Events.delete.value:\n                assert event.target_type == \"Token\"\n                continue\n\n            assert event.event == Events.change_password.value\n            assert event.user == BaseAuthentication.default_user\n            break\n\n        self.do_login(client, None, None, status_code=401)\n        headers, _ = self.do_login(client, None, new_pwd)\n\n        # Token is no longer valid\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token\"\n\n        # Restore the default password\n        if Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"):\n            data[\"totp_code\"] = BaseTests.generate_totp(BaseAuthentication.default_user)\n\n        data[\"password\"] = new_pwd\n        data[\"new_password\"] = BaseAuthentication.default_password\n        data[\"password_confirm\"] = data[\"new_password\"]\n        r = client.put(f\"{AUTH_URI}/profile\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        # After a change password a spam of delete Token is expected\n        # Reverse the list and skip all delete tokens to find the change password event\n        events = self.get_last_events(100)\n        events.reverse()\n        for event in events:\n            if event.event == Events.delete.value:\n                assert event.target_type == \"Token\"\n                continue\n\n            assert event.event == Events.change_password.value\n            assert event.user == BaseAuthentication.default_user\n            break\n\n        self.do_login(client, None, new_pwd, status_code=401)\n        self.do_login(client, None, None)\n\n        # Token created for another user\n        token = self.get_crafted_token(\"r\")\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token\"\n\n        # Token created for another user\n        token = self.get_crafted_token(\"r\", wrong_algorithm=True)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token\"\n\n        # Token created for another user\n        token = self.get_crafted_token(\"r\", wrong_secret=True)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token\"\n\n        headers, _ = self.do_login(client, None, None)\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        uuid = response.get(\"uuid\")\n\n        token = self.get_crafted_token(\"x\", user_id=uuid)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token\"\n\n        # token created for the correct user, but from outside the system!!\n        token = self.get_crafted_token(\"r\", user_id=uuid)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token\"\n\n        # Immature token\n        token = self.get_crafted_token(\"r\", user_id=uuid, immature=True)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token\"\n\n        # Expired token\n        token = self.get_crafted_token(\"r\", user_id=uuid, expired=True)\n        r = client.put(f\"{AUTH_URI}/reset/{token}\", json={})\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid reset token: this request is expired\"\n", "test_endpoints_registration_and_activation.py": "import pytest\nfrom faker import Faker\n\nfrom restapi.config import PRODUCTION, get_project_configuration\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseAuthentication, BaseTests, FlaskClient\nfrom restapi.utilities.logs import OBSCURE_VALUE, Events, log\n\n\nclass TestApp(BaseTests):\n    def test_registration(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"ALLOW_REGISTRATION\") or not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"User registration is disabled, skipping tests\")\n            return\n\n        project_tile = get_project_configuration(\"project.title\", default=\"YourProject\")\n        proto = \"https\" if PRODUCTION else \"http\"\n\n        # registration, empty input\n        r = client.post(f\"{AUTH_URI}/profile\")\n        assert r.status_code == 400\n\n        # registration, missing information\n        r = client.post(f\"{AUTH_URI}/profile\", json={\"x\": \"y\"})\n        assert r.status_code == 400\n\n        # Ensure name and surname longer than 3\n        name = self.get_first_name(faker)\n        surname = self.get_last_name(faker)\n        # Ensure an email not containing name and surname and longer than 3\n        email = self.get_random_email(faker, name, surname)\n\n        registration_data = {}\n        registration_data[\"password\"] = faker.password(5)\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 400\n\n        registration_data[\"email\"] = BaseAuthentication.default_user\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 400\n\n        registration_data[\"name\"] = name\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 400\n\n        registration_data[\"surname\"] = surname\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 400\n\n        registration_data[\"password_confirm\"] = faker.password(strong=True)\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 400\n\n        min_pwd_len = Env.get_int(\"AUTH_MIN_PASSWORD_LENGTH\", 9999)\n\n        registration_data[\"password\"] = faker.password(min_pwd_len - 1)\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 400\n\n        registration_data[\"password\"] = faker.password(min_pwd_len)\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = f\"This user already exists: {BaseAuthentication.default_user}\"\n        assert self.get_content(r) == m\n\n        registration_data[\"email\"] = email\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        assert self.get_content(r) == \"Your password doesn't match the confirmation\"\n\n        registration_data[\"password\"] = faker.password(min_pwd_len, low=False, up=True)\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = \"Password is too weak, missing lower case letters\"\n        assert self.get_content(r) == m\n\n        registration_data[\"password\"] = faker.password(min_pwd_len, low=True)\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = \"Password is too weak, missing upper case letters\"\n        assert self.get_content(r) == m\n\n        registration_data[\"password\"] = faker.password(min_pwd_len, low=True, up=True)\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = \"Password is too weak, missing numbers\"\n        assert self.get_content(r) == m\n\n        registration_data[\"password\"] = faker.password(\n            min_pwd_len, low=True, up=True, digits=True\n        )\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = \"Password is too weak, missing special characters\"\n        assert self.get_content(r) == m\n\n        registration_data[\"password\"] = registration_data[\"email\"].split(\"@\")[0]\n        registration_data[\"password\"] += \"DEFghi345!\"\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = \"Password is too weak, can't contain your email address\"\n        assert self.get_content(r) == m\n\n        registration_data[\"password\"] = registration_data[\"name\"] + \"LMNopq678=\"\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = \"Password is too weak, can't contain your name\"\n        assert self.get_content(r) == m\n\n        registration_data[\"password\"] = registration_data[\"surname\"] + \"LMNopq678=\"\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        assert r.status_code == 409\n        m = \"Password is too weak, can't contain your name\"\n        assert self.get_content(r) == m\n\n        registration_data[\"password\"] = faker.password(strong=True)\n        registration_data[\"password_confirm\"] = registration_data[\"password\"]\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        # now the user is created but INACTIVE, activation endpoint is needed\n        assert r.status_code == 200\n        registration_message = \"We are sending an email to your email address where \"\n        registration_message += \"you will find the link to activate your account\"\n        assert self.get_content(r) == registration_message\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.create.value\n        assert events[0].user == \"-\"\n        assert events[0].target_type == \"User\"\n        assert \"name\" in events[0].payload\n        assert \"password\" in events[0].payload\n        assert events[0].payload[\"password\"] == OBSCURE_VALUE\n\n        # Last sent email is the registration notification to the admin\n        mail = self.read_mock_email()\n        body = mail.get(\"body\")\n        assert body is not None\n        assert mail.get(\"headers\") is not None\n        # Subject: is a key in the MIMEText\n        assert f\"Subject: {project_tile}: New user registered\" in mail.get(\n            \"headers\", \"\"\n        )\n        assert registration_data[\"email\"] in body\n\n        # Previous sent email is the activation link sent to the user\n        mail = self.read_mock_email(previous=True)\n        body = mail.get(\"body\")\n        assert body is not None\n        assert mail.get(\"headers\") is not None\n        # Subject: is a key in the MIMEText\n        assert f\"Subject: {project_tile}: Account activation\" in mail.get(\"headers\", \"\")\n        assert f\"{proto}://localhost/public/register/\" in body\n\n        # This will fail because the user is not active\n        _, error = self.do_login(\n            client,\n            registration_data[\"email\"],\n            registration_data[\"password\"],\n            status_code=403,\n        )\n        assert error == \"Sorry, this account is not active\"\n\n        # Also password reset is not allowed\n        data = {\"reset_email\": registration_data[\"email\"]}\n        r = client.post(f\"{AUTH_URI}/reset\", json=data)\n        assert r.status_code == 403\n        assert self.get_content(r) == \"Sorry, this account is not active\"\n\n        events = self.get_last_events(2)\n        assert events[0].event == Events.refused_login.value\n        assert events[0].payload[\"username\"] == data[\"reset_email\"]\n        assert events[0].payload[\"motivation\"] == \"account not active\"\n\n        assert events[1].event == Events.refused_login.value\n        assert events[1].payload[\"username\"] == data[\"reset_email\"]\n        assert events[1].payload[\"motivation\"] == \"account not active\"\n\n        # Activation, missing or wrong information\n        r = client.post(f\"{AUTH_URI}/profile/activate\")\n        assert r.status_code == 400\n        r = client.post(f\"{AUTH_URI}/profile/activate\", json=faker.pydict(2))\n        assert r.status_code == 400\n        # It isn't an email\n        invalid = faker.pystr(10)\n        r = client.post(f\"{AUTH_URI}/profile/activate\", json={\"username\": invalid})\n        assert r.status_code == 400\n\n        headers, _ = self.do_login(client, None, None)\n\n        activation_message = \"We are sending an email to your email address where \"\n        activation_message += \"you will find the link to activate your account\"\n        # request activation, wrong username\n        r = client.post(\n            f\"{AUTH_URI}/profile/activate\", json={\"username\": faker.ascii_email()}\n        )\n        # return is 200, but no token will be generated and no mail will be sent\n        # but it respond with the activation msg and hides the non existence of the user\n        assert r.status_code == 200\n        assert self.get_content(r) == activation_message\n\n        events = self.get_last_events(1)\n        assert events[0].event != Events.activation.value\n        assert events[0].url == \"/auth/login\"\n\n        with pytest.raises(FileNotFoundError):\n            self.read_mock_email()\n\n        # request activation, correct username\n        r = client.post(\n            f\"{AUTH_URI}/profile/activate\",\n            json={\"username\": registration_data[\"email\"]},\n        )\n        assert r.status_code == 200\n        assert self.get_content(r) == activation_message\n\n        mail = self.read_mock_email()\n        body = mail.get(\"body\")\n        assert body is not None\n        assert mail.get(\"headers\") is not None\n        # Subject: is a key in the MIMEText\n        assert f\"Subject: {project_tile}: Account activation\" in mail.get(\"headers\", \"\")\n        assert f\"{proto}://localhost/public/register/\" in body\n\n        token = self.get_token_from_body(body)\n        assert token is not None\n\n        # profile activation\n        r = client.put(f\"{AUTH_URI}/profile/activate/thisisatoken\")\n        # this token is not valid\n        assert r.status_code == 400\n\n        # profile activation\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 200\n        assert self.get_content(r) == \"Account activated\"\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.activation.value\n        assert events[0].user == registration_data[\"email\"]\n        assert events[0].target_type == \"User\"\n        assert events[0].url == f\"/auth/profile/activate/{token}\"\n\n        # Activation token is no longer valid\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        assert self.get_content(r) == \"Invalid activation token\"\n\n        # Token created for another user\n        token = self.get_crafted_token(\"a\")\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token\"\n\n        # Token created for another user\n        token = self.get_crafted_token(\"a\", wrong_algorithm=True)\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token\"\n\n        # Token created for another user\n        token = self.get_crafted_token(\"a\", wrong_secret=True)\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token\"\n\n        headers, _ = self.do_login(client, None, None)\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        uuid = content.get(\"uuid\")\n\n        token = self.get_crafted_token(\"x\", user_id=uuid)\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token\"\n\n        # token created for the correct user, but from outside the system!!\n        token = self.get_crafted_token(\"a\", user_id=uuid)\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token\"\n\n        # Immature token\n        token = self.get_crafted_token(\"a\", user_id=uuid, immature=True)\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token\"\n\n        # Expired token\n        token = self.get_crafted_token(\"a\", user_id=uuid, expired=True)\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token: this request is expired\"\n\n        # Testing the following use case:\n        # 1 - user registration\n        # 2 - user activation using unconventional channel, e.g. by admins\n        # 3 - user tries to activate and fails because already active\n\n        registration_data[\"email\"] = faker.ascii_email()\n        r = client.post(f\"{AUTH_URI}/profile\", json=registration_data)\n        # now the user is created but INACTIVE, activation endpoint is needed\n        assert r.status_code == 200\n\n        # Registration endpoint send 2 mail: the first is the activation link,\n        # the second (last) is the admin notification\n        mail = self.read_mock_email(previous=True)\n        body = mail.get(\"body\")\n        assert body is not None\n        assert mail.get(\"headers\") is not None\n        assert f\"{proto}://localhost/public/register/\" in body\n\n        token = self.get_token_from_body(body)\n        assert token is not None\n\n        headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/admin/users\", headers=headers)\n        assert r.status_code == 200\n        users = self.get_content(r)\n        assert isinstance(users, list)\n        uuid = None\n        for u in users:\n            if u.get(\"email\") == registration_data[\"email\"]:\n                uuid = u.get(\"uuid\")\n                break\n\n        assert uuid is not None\n        r = client.put(\n            f\"{API_URI}/admin/users/{uuid}\", json={\"is_active\": True}, headers=headers\n        )\n        assert r.status_code == 204\n\n        r = client.put(f\"{AUTH_URI}/profile/activate/{token}\")\n        assert r.status_code == 400\n        c = self.get_content(r)\n        assert c == \"Invalid activation token: this request is no longer valid\"\n\n        r = client.get(f\"{API_URI}/admin/tokens\", headers=headers)\n        content = self.get_content(r)\n        assert isinstance(content, list)\n\n        for t in content:\n            if t.get(\"token\") == token:  # pragma: no cover\n                pytest.fail(\n                    \"Token not properly invalidated, still bount to user {}\", t.get(id)\n                )\n", "test_endpoints_send_mail.py": "from typing import Any\n\nimport pytest\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\n\n\n@pytest.mark.skipif(\n    not Connector.check_availability(\"smtp\") or not Env.get_bool(\"AUTH_ENABLE\"),\n    reason=\"This test needs smtp and auth to be available\",\n)\nclass TestApp(BaseTests):\n    def test_sendmail(self, client: FlaskClient, faker: Faker) -> None:\n        headers, _ = self.do_login(client, None, None)\n\n        r = client.get(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.put(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.patch(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        r = client.delete(f\"{API_URI}/admin/mail\", headers=headers)\n        assert r.status_code == 405\n\n        data: dict[str, Any] = {\"dry_run\": False}\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"subject\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"body\"] = faker.text()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"to\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"to\"] = faker.ascii_email()\n        data[\"body\"] = \"TEST EMAIL BODY\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        mail = self.read_mock_email()\n        body = mail.get(\"body\", \"\")\n        assert \"TEST EMAIL BODY\" in body\n\n        data[\"dry_run\"] = True\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 200\n\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"html_body\" in response\n        assert \"plain_body\" in response\n        assert \"subject\" in response\n        assert \"to\" in response\n        assert \"cc\" in response\n        assert \"bcc\" in response\n\n        data[\"dry_run\"] = False\n\n        data[\"body\"] = \"TEST EMAIL <b>HTML</b> BODY\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n        mail = self.read_mock_email()\n        body = mail.get(\"body\", \"\")\n        assert \"TEST EMAIL <b>HTML</b> BODY\" in body\n\n        data[\"dry_run\"] = True\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 200\n\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        assert \"html_body\" in response\n        assert \"plain_body\" in response\n        assert \"subject\" in response\n        assert \"to\" in response\n        assert \"cc\" in response\n        assert \"bcc\" in response\n\n        data[\"dry_run\"] = False\n\n        data[\"body\"] = faker.text()\n        data[\"cc\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"cc\"] = faker.ascii_email()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        data[\"cc\"] = f\"{faker.ascii_email()},{faker.pystr()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"cc\"] = f\"{faker.ascii_email()},{faker.ascii_email()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        data[\"bcc\"] = faker.pystr()\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"bcc\"] = f\"{faker.ascii_email()},{faker.pystr()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 400\n\n        data[\"bcc\"] = f\"{faker.ascii_email()},{faker.ascii_email()}\"\n        r = client.post(f\"{API_URI}/admin/mail\", json=data, headers=headers)\n        assert r.status_code == 204\n\n        mail = self.read_mock_email()\n\n        body = mail.get(\"body\", \"\")\n        email_headers = mail.get(\"headers\", \"\")\n        assert body is not None\n        assert email_headers is not None\n        # Subject: is a key in the MIMEText\n        assert f\"Subject: {data['subject']}\" in email_headers\n        ccs = mail.get(\"cc\", [])\n        assert ccs[0] == data[\"to\"]\n        assert ccs[1] == data[\"cc\"].split(\",\")[0]\n        assert ccs[2] == data[\"cc\"].split(\",\")[1]\n        assert ccs[3] == data[\"bcc\"].split(\",\")[0]\n        assert ccs[4] == data[\"bcc\"].split(\",\")[1]\n", "test_endpoints_specs.py": "from restapi.env import Env\nfrom restapi.tests import API_URI, BaseTests, FlaskClient\n\n\nclass TestApp(BaseTests):\n    def test_GET_specs(self, client: FlaskClient) -> None:\n        r = client.get(f\"{API_URI}/specs\")\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"host\" in content\n        assert \"info\" in content\n        assert \"swagger\" in content\n        assert \"schemes\" in content\n        assert \"paths\" in content\n        assert \"definitions\" in content\n        assert \"/api/admin/users\" not in content[\"paths\"]\n\n        # Not available in new spec... to be introduced?\n        assert \"basePath\" not in content\n        assert \"consumes\" not in content\n        assert \"produces\" not in content\n        # assert \"application/json\" in content[\"consumes\"]\n        # assert \"application/json\" in content[\"produces\"]\n        assert \"tags\" in content\n        # This is no longer in root definition\n        # Now it is set for each endpoint, when required\n        assert \"security\" not in content\n        # assert \"Bearer\" in content[\"security\"][0]\n\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            assert \"securityDefinitions\" in content\n            assert \"Bearer\" in content[\"securityDefinitions\"]\n        else:\n            assert \"securityDefinitions\" not in content\n\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            headers, _ = self.do_login(client, None, None)\n            r = client.get(f\"{API_URI}/specs\", headers=headers)\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, dict)\n            assert \"host\" in content\n            assert \"info\" in content\n            assert \"swagger\" in content\n            assert \"schemes\" in content\n            assert \"paths\" in content\n            assert \"definitions\" in content\n            assert \"/auth/logout\" in content[\"paths\"]\n\n            # Not available in new spec... to be introduced?\n            assert \"basePath\" not in content\n            assert \"consumes\" not in content\n            assert \"produces\" not in content\n            # assert \"application/json\" in content[\"consumes\"]\n            # assert \"application/json\" in content[\"produces\"]\n            assert \"tags\" in content\n            # This is no longer in root definition\n            # Now it is set for each endpoint, when required\n            assert \"security\" not in content\n            # assert \"Bearer\" in content[\"security\"][0]\n            assert \"securityDefinitions\" in content\n            assert \"Bearer\" in content[\"securityDefinitions\"]\n\n        # IMPORT: if authentication is enabled with content is replaced by the full spec\n        # Otherwise the if branch is not execute and the basic spec is used\n\n        # Based on the definition of InputSchema in test_inputs.py\n        assert \"/api/tests/inputs\" in content[\"paths\"]\n        assert \"post\" in content[\"paths\"][\"/api/tests/inputs\"]\n        endpoint = content[\"paths\"][\"/api/tests/inputs\"][\"post\"]\n        assert \"parameters\" in endpoint\n        assert isinstance(endpoint[\"parameters\"], list)\n        assert len(endpoint[\"parameters\"]) == 1\n        assert \"schema\" in endpoint[\"parameters\"][0]\n        assert \"$ref\" in endpoint[\"parameters\"][0][\"schema\"]\n        assert endpoint[\"parameters\"][0][\"schema\"][\"$ref\"] == \"#/definitions/Input\"\n\n        assert \"Input\" in content[\"definitions\"]\n\n        schema = content[\"definitions\"][\"Input\"]\n        assert \"properties\" in schema\n        assert \"required\" in schema\n        assert \"type\" in schema\n        assert schema[\"type\"] == \"object\"\n\n        assert \"MYDATE\" in schema[\"required\"]\n        assert \"MYDATETIME\" in schema[\"required\"]\n        assert \"myequalstr\" in schema[\"required\"]\n        assert \"myint_exclusive\" in schema[\"required\"]\n        assert \"myint_inclusive\" in schema[\"required\"]\n        assert \"mylist\" in schema[\"required\"]\n        assert \"mylist2\" in schema[\"required\"]\n        assert \"mylist3\" in schema[\"required\"]\n        assert \"mymaxstr\" in schema[\"required\"]\n        assert \"mynested\" in schema[\"required\"]\n        assert \"myselect\" in schema[\"required\"]\n        assert \"myselect2\" in schema[\"required\"]\n        assert \"mystr\" in schema[\"required\"]\n\n        properties = schema[\"properties\"]\n        f = \"MYDATE\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"string\"\n        assert \"format\" in properties[f]\n        assert properties[f][\"format\"] == \"date\"\n        # min and max not set for this example\n        assert \"x-minimum\" not in properties[f]\n        assert \"x-maximum\" not in properties[f]\n\n        f = \"MYDATETIME\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"string\"\n        assert \"format\" in properties[f]\n        assert properties[f][\"format\"] == \"date-time\"\n        assert \"x-minimum\" in properties[f]\n        assert \"x-maximum\" in properties[f]\n\n        f = \"myequalstr\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"string\"\n        assert \"minLength\" in properties[f]\n        assert properties[f][\"minLength\"] == 6\n        assert \"maxLength\" in properties[f]\n        assert properties[f][\"maxLength\"] == 6\n\n        f = \"myint_exclusive\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"integer\"\n        assert \"minimum\" in properties[f]\n        assert properties[f][\"minimum\"] == 1  # should be 2???\n        assert \"maximum\" in properties[f]\n        assert properties[f][\"maximum\"] == 10  # should be 9???\n\n        f = \"myint_inclusive\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"integer\"\n        assert \"minimum\" in properties[f]\n        assert properties[f][\"minimum\"] == 1\n        assert \"maximum\" in properties[f]\n        assert properties[f][\"maximum\"] == 10\n\n        # string[]\n        f = \"mylist\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"array\"\n        assert \"items\" in properties[f]\n        assert \"type\" in properties[f][\"items\"]\n        assert len(properties[f][\"items\"]) == 1\n        assert properties[f][\"items\"][\"type\"] == \"string\"\n\n        # int[]\n        f = \"mylist2\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"array\"\n        assert \"items\" in properties[f]\n        assert \"type\" in properties[f][\"items\"]\n        assert len(properties[f][\"items\"]) == 1\n        assert properties[f][\"items\"][\"type\"] == \"integer\"\n\n        # List of custom field\n        f = \"mylist3\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"array\"\n        assert \"items\" in properties[f]\n        # no property specified for custom fields... apispec is unable to convert it\n        assert len(properties[f][\"items\"]) == 0\n\n        f = \"mymaxstr\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"string\"\n        assert \"maxLength\" in properties[f]\n        assert properties[f][\"maxLength\"] == 7\n\n        # Normal Nested are assigned to $ref key\n        f = \"mynested\"\n        assert f in properties\n        assert \"$ref\" in properties[f]\n        assert properties[f][\"$ref\"] == \"#/definitions/Nested\"\n\n        # Nullable Nested are assigned to allOf key\n        f = \"mynullablenested\"\n        assert f in properties\n        assert \"allOf\" in properties[f]\n        assert \"$ref\" in properties[f][\"allOf\"][0]\n        assert properties[f][\"allOf\"][0][\"$ref\"] == \"#/definitions/Nested\"\n        assert \"x-nullable\" in properties[f]\n        assert properties[f][\"x-nullable\"] is True\n\n        f = \"myselect\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"string\"\n        assert \"enum\" in properties[f]\n        assert isinstance(properties[f][\"enum\"], list)\n        assert len(properties[f][\"enum\"]) == 2\n        assert properties[f][\"enum\"][0] == \"a\"\n        assert properties[f][\"enum\"][1] == \"b\"\n\n        f = \"myselect2\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"string\"\n        assert \"enum\" in properties[f]\n        assert isinstance(properties[f][\"enum\"], list)\n        assert len(properties[f][\"enum\"]) == 2\n        assert properties[f][\"enum\"][0] == \"a\"\n        assert properties[f][\"enum\"][1] == \"b\"\n\n        f = \"mystr\"\n        assert f in properties\n        assert \"type\" in properties[f]\n        assert properties[f][\"type\"] == \"string\"\n        assert \"minLength\" in properties[f]\n        assert properties[f][\"minLength\"] == 4\n", "test_endpoints_status.py": "from restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import log\n\n\nclass TestApp(BaseTests):\n    def test_GET_status(self, client: FlaskClient) -> None:\n        \"\"\"Test that the flask server is running and reachable\"\"\"\n\n        # Check success\n        alive_message = \"Server is alive\"\n\n        log.info(\"*** VERIFY if API is online\")\n        r = client.get(f\"{API_URI}/status\")\n        assert r.status_code == 200\n        output = self.get_content(r)\n        assert output == alive_message\n\n        # Check failure\n        log.info(\"*** VERIFY if invalid endpoint gives Not Found\")\n        r = client.get(API_URI)\n        assert r.status_code == 404\n\n        if Env.get_bool(\"AUTH_ENABLE\"):\n            # Check /auth/status with no token or invalid token\n            r = client.get(f\"{AUTH_URI}/status\")\n            assert r.status_code == 401\n\n            r = client.get(\n                f\"{AUTH_URI}/status\", headers={\"Authorization\": \"Bearer ABC\"}\n            )\n            assert r.status_code == 401\n        else:\n            r = client.get(f\"{AUTH_URI}/status\")\n            assert r.status_code == 404\n", "test_endpoints_tokens.py": "from faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import Events, log\n\n\nclass TestApp(BaseTests):\n    def test_tokens(self, client: FlaskClient, faker: Faker) -> None:\n        if not Env.get_bool(\"AUTH_ENABLE\"):\n            log.warning(\"Skipping tokens tests\")\n            return\n\n        last_token = None\n        last_tokens_header = None\n        token_id = None\n\n        for _ in range(3):\n            header, token = self.do_login(client, None, None)\n            last_tokens_header = header\n            last_token = token\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{AUTH_URI}/tokens\", headers=last_tokens_header)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n\n        # Probably due to password expiration:\n        # change password invalidated tokens created before\n        # => create tokens again\n        if len(content) < 3:  # pragma: no cover\n            for _ in range(3):\n                header, token = self.do_login(client, None, None)\n                last_tokens_header = header\n                last_token = token\n\n            # TEST GET ALL TOKENS\n            r = client.get(f\"{AUTH_URI}/tokens\", headers=last_tokens_header)\n            assert r.status_code == 200\n            content = self.get_content(r)\n            assert isinstance(content, list)\n            assert len(content) >= 3\n\n        # save a token to be used for further tests\n        for c in content:\n            if c[\"token\"] == last_token:\n                continue\n            token_id = c[\"id\"]\n\n        # SINGLE TOKEN IS NOT ALLOWED\n        r = client.get(f\"{AUTH_URI}/tokens/{token_id}\", headers=last_tokens_header)\n        assert r.status_code == 405\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{API_URI}/admin/tokens\")\n        assert r.status_code == 401\n\n        # TEST GET ALL TOKENS\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] > 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True, \"input_filter\": \"1\"},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] > 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True, \"input_filter\": faker.pystr()},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] == 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"get_total\": True, \"page\": 1, \"size\": 20},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 206\n        content = self.get_content(r)\n        assert isinstance(content, dict)\n        assert \"total\" in content\n        assert content[\"total\"] > 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 0, \"size\": 20},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 400\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 0},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 400\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 101},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 400\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 99999, \"size\": 20},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 2},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) <= 2\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 20, \"input_filter\": \"1\"},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) >= 1\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\"page\": 1, \"size\": 20, \"input_filter\": faker.pystr()},\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) == 0\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\n                \"page\": 1,\n                \"size\": 20,\n                \"input_filter\": \"1\",\n                \"sort_by\": \"uuid\",\n            },\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        default_sort = self.get_content(r)\n        assert isinstance(default_sort, list)\n        assert len(default_sort) >= 2\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\n                \"page\": 1,\n                \"size\": 20,\n                \"input_filter\": \"1\",\n                \"sort_by\": \"uuid\",\n                \"sort_order\": \"asc\",\n            },\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        asc_sort = self.get_content(r)\n        assert isinstance(asc_sort, list)\n        assert len(asc_sort) >= 2\n        assert default_sort[0][\"token\"] == asc_sort[0][\"token\"]\n        assert default_sort[-1][\"token\"] == asc_sort[-1][\"token\"]\n\n        r = client.get(\n            f\"{API_URI}/admin/tokens\",\n            query_string={\n                \"page\": 1,\n                \"size\": 20,\n                \"input_filter\": \"1\",\n                \"sort_by\": \"uuid\",\n                \"sort_order\": \"desc\",\n            },\n            headers=last_tokens_header,\n        )\n        assert r.status_code == 200\n        desc_sort = self.get_content(r)\n        assert isinstance(desc_sort, list)\n        # Results of desc_sort can't be compared with previous contents\n        # It may only be done if we were able to retrieve all tokens, in this case the\n        # first desc will be the last asc... But we cannot ensure to be able to always\n        # retrieve all tokens.\n        assert len(desc_sort) >= 2\n        # At least they should be different\n        # assert asc_sort[0] != desc_sort[0]\n        # assert asc_sort[-1] != desc_sort[-1]\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{API_URI}/admin/tokens\", headers=last_tokens_header)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n        assert len(content) >= 3\n\n        # DELETE INVALID TOKEN\n        r = client.delete(f\"{API_URI}/admin/tokens/xyz\", headers=last_tokens_header)\n        assert r.status_code == 404\n\n        # TEST DELETE OF A SINGLE TOKEN\n        r = client.delete(f\"{AUTH_URI}/tokens/{token_id}\", headers=last_tokens_header)\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.delete.value\n        assert events[0].target_type == \"Token\"\n        # Tokens does not have a uuid...\n        # assert events[0].target_id == token_id\n        assert events[0].user == \"-\"\n        assert events[0].url == f\"/auth/tokens/{token_id}\"\n\n        # TEST AN ALREADY DELETED TOKEN\n        r = client.delete(f\"{AUTH_URI}/tokens/{token_id}\", headers=last_tokens_header)\n        assert r.status_code == 403\n\n        # TEST INVALID DELETE OF A SINGLE TOKEN\n        r = client.delete(f\"{AUTH_URI}/tokens/0\", headers=last_tokens_header)\n        assert r.status_code == 403\n\n        # TEST TOKEN IS STILL VALID\n        r = client.get(f\"{AUTH_URI}/tokens\", headers=last_tokens_header)\n        assert r.status_code == 200\n\n        # user_header will be used as target for deletion\n        # Always enabled in core tests\n        if not Env.get_bool(\"MAIN_LOGIN_ENABLE\"):  # pragma: no cover\n            uuid = None\n            user_header, token = self.do_login(client, None, None)\n        else:\n            uuid, data = self.create_user(client)\n            user_header, token = self.do_login(client, data[\"email\"], data[\"password\"])\n\n        r = client.get(f\"{AUTH_URI}/status\", headers=user_header)\n        assert r.status_code == 200\n\n        # TEST GET ALL TOKENS\n        r = client.get(f\"{AUTH_URI}/tokens\", headers=user_header)\n        assert r.status_code == 200\n        content = self.get_content(r)\n        assert isinstance(content, list)\n\n        token_id = None\n        for c in content:\n            if c[\"token\"] == token:\n                token_id = c[\"id\"]\n                break\n\n        assert token_id is not None\n\n        last_tokens_header, _ = self.do_login(client, None, None)\n        r = client.delete(\n            f\"{API_URI}/admin/tokens/{token_id}\", headers=last_tokens_header\n        )\n        assert r.status_code == 204\n\n        events = self.get_last_events(1)\n        assert events[0].event == Events.delete.value\n        assert events[0].target_type == \"Token\"\n        # Tokens does not have a uuid...\n        # assert events[0].target_id == token_id\n        assert events[0].user == \"-\"\n        assert events[0].url == f\"/api/admin/tokens/{token_id}\"\n\n        r = client.delete(\n            f\"{API_URI}/admin/tokens/{token_id}\", headers=last_tokens_header\n        )\n        assert r.status_code == 404\n\n        r = client.get(f\"{AUTH_URI}/status\", headers=user_header)\n        assert r.status_code == 401\n\n        # Goodbye temporary user (if previously created)\n        if uuid:\n            self.delete_user(client, uuid)\n", "test_endpoints_upload_download.py": "import io\nimport os\nimport warnings\n\nfrom faker import Faker\n\nfrom restapi.config import DATA_PATH, PRODUCTION, get_backend_url\nfrom restapi.tests import API_URI, SERVER_URI, BaseTests, FlaskClient\n\n\ndef get_location_header(headers: dict[str, str], expected: str) -> str:\n    assert \"Location\" in headers\n    location = headers[\"Location\"]\n\n    if PRODUCTION:\n        assert location.startswith(\"https://\")\n\n    host = get_backend_url()\n    assert location.startswith(host)\n    location = location.replace(host, SERVER_URI)\n    assert location == expected\n    return location\n\n\nclass TestUploadAndDownload(BaseTests):\n    def test_simple_upload_and_download(\n        self, client: FlaskClient, faker: Faker\n    ) -> None:\n        warnings.filterwarnings(\n            \"ignore\", message=\"unclosed file <_io.BufferedReader name=\"\n        )\n        self.fcontent = faker.paragraph()\n        self.save(\"fcontent\", self.fcontent)\n        # as defined in test_upload.py for normal uploads\n        upload_folder = \"fixsubfolder\"\n\n        self.fname = f\"{faker.pystr()}.notallowed\"\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname),\n                # By setting force False only txt files will be allowed for upload\n                # Strange, but it is how the endpoint is configured to improve the tests\n                \"force\": False,\n            },\n        )\n        assert r.status_code == 400\n        assert self.get_content(r) == \"File extension not allowed\"\n\n        self.fname = f\"{faker.pystr()}.txt\"\n        self.save(\"fname\", self.fname)\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname),\n                # By setting force False only txt files will be allowed for upload\n                # Strange, but it is how the endpoint is configured to improve the tests\n                \"force\": False,\n            },\n        )\n        assert r.status_code == 200\n\n        destination_path = DATA_PATH.joinpath(upload_folder, self.fname)\n        assert destination_path.exists()\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname)},\n        )\n        assert r.status_code == 409\n        err = f\"File '{self.fname}' already exists, use force parameter to overwrite\"\n        assert self.get_content(r) == err\n\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(self.fcontent)), self.fname),\n                \"force\": True,\n            },\n        )\n        assert r.status_code == 200\n\n        destination_path = DATA_PATH.joinpath(upload_folder, self.fname)\n        assert destination_path.exists()\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"filename\") == self.fname\n        meta = c.get(\"meta\")\n        assert meta is not None\n        assert meta.get(\"charset\") is not None\n        assert meta.get(\"type\") is not None\n\n        self.fname = self.get(\"fname\")\n        self.fcontent = self.get(\"fcontent\")\n        # as defined in test_upload.py for normal uploads\n        upload_folder = \"fixsubfolder\"\n\n        r = client.get(f\"{API_URI}/tests/download/folder/doesnotexist\")\n        assert r.status_code == 404\n        assert self.get_content(r) == \"The requested file does not exist\"\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{self.fname}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == self.fcontent\n\n        new_content = \"new content\"\n        r = client.put(\n            f\"{API_URI}/tests/upload\",\n            data={\n                \"file\": (io.BytesIO(str.encode(new_content)), self.fname),\n                \"force\": True,\n            },\n        )\n        assert r.status_code == 200\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{self.fname}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content != self.fcontent\n        assert content == new_content\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{self.fname}\",\n            query_string={\"stream\": True},\n        )\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == new_content\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/doesnotexist\",\n            query_string={\"stream\": True},\n        )\n        assert r.status_code == 404\n\n    def test_chunked_upload_and_download(\n        self, client: FlaskClient, faker: Faker\n    ) -> None:\n        warnings.filterwarnings(\n            \"ignore\", message=\"unclosed file <_io.BufferedReader name=\"\n        )\n\n        self.fname = self.get(\"fname\")\n        self.fcontent = self.get(\"fcontent\")\n\n        # as defined in test_upload.py for chunked uploads\n        upload_folder = \"fixed\"\n\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data={\"force\": True})\n        assert r.status_code == 400\n\n        filename = \"fixed.filename.txt\"\n        data = {\n            \"force\": True,\n            \"name\": filename,\n            \"size\": \"999\",\n            \"mimeType\": \"application/zip\",\n            \"lastModified\": 1590302749209,\n        }\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 201\n        assert self.get_content(r) == \"\"\n        upload_endpoint = get_location_header(\n            r.headers, expected=f\"{API_URI}/tests/chunkedupload/{filename}\"\n        )\n\n        data[\"force\"] = False\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 409\n        assert self.get_content(r) == f\"File '{filename}' already exists\"\n\n        with io.StringIO(faker.text()) as f:\n            r = client.put(upload_endpoint, data=f)\n        assert r.status_code == 400\n        assert self.get_content(r) == \"Invalid request\"\n\n        with io.StringIO(faker.text()) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": \"!\"},\n            )\n        assert r.status_code == 400\n        assert self.get_content(r) == \"Invalid request\"\n\n        up_data = faker.pystr(min_chars=24, max_chars=48).lower()\n        STR_LEN = len(up_data)\n        with io.StringIO(up_data[0:5]) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes 0-5/{STR_LEN}\"},\n            )\n        assert r.status_code == 206\n        assert self.get_content(r) == \"partial\"\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert destination_path.exists()\n        # The file is still writeable because the upload is in progress\n        assert oct(os.stat(destination_path).st_mode & 0o777) != \"0o440\"\n\n        with io.StringIO(up_data[5:]) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes 5-{STR_LEN}/{STR_LEN}\"},\n            )\n        assert r.status_code == 200\n        c = self.get_content(r)\n        assert isinstance(c, dict)\n        assert c.get(\"filename\") is not None\n        uploaded_filename = c.get(\"filename\")\n        meta = c.get(\"meta\")\n        assert meta is not None\n        assert meta.get(\"charset\") == \"us-ascii\"\n        assert meta.get(\"type\") == \"text/plain\"\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert destination_path.exists()\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data\n\n        r = client.get(f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\")\n        assert r.status_code == 200\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": \"\"},\n        )\n        assert r.status_code == 416\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": f\"0-{STR_LEN - 1}\"},\n        )\n        assert r.status_code == 416\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": \"bytes=0-9999999999999999\"},\n        )\n        assert r.status_code == 206\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": \"bytes=0-4\"},\n        )\n        assert r.status_code == 206\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data[0:5]\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": f\"bytes=5-{STR_LEN - 1}\"},\n        )\n        assert r.status_code == 206\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data[5:]\n\n        r = client.get(\n            f\"{API_URI}/tests/download/{upload_folder}/{uploaded_filename}\",\n            headers={\"Range\": f\"bytes=0-{STR_LEN - 1}\"},\n        )\n        assert r.status_code == 206\n        content = r.data.decode(\"utf-8\")\n        assert content == up_data\n\n        # Send a new string as content file. Will be appended as prefix\n        up_data2 = faker.pystr(min_chars=24, max_chars=48)\n        STR_LEN = len(up_data2)\n        with io.StringIO(up_data2) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes */{STR_LEN}\"},\n            )\n        assert r.status_code == 503\n        assert self.get_content(r) == \"Permission denied: failed to write the file\"\n\n        # force the file to be writeable again\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        # -rw-rw----\n        destination_path.chmod(0o660)\n\n        with io.StringIO(up_data2) as f:\n            r = client.put(\n                upload_endpoint,\n                data=f,\n                headers={\"Content-Range\": f\"bytes */{STR_LEN}\"},\n            )\n\n        assert r.status_code == 200\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert destination_path.exists()\n        # File permissions are restored\n        assert oct(os.stat(destination_path).st_mode & 0o777) == \"0o440\"\n\n        # c = self.get_content(r)\n        # assert c.get('filename') is not None\n        # uploaded_filename = c.get('filename')\n        # meta = c.get('meta')\n        # assert meta is not None\n        # assert meta.get('charset') == 'us-ascii'\n        # assert meta.get('type') == 'text/plain'\n\n        # r = client.get(\n        #     f'{API_URI}/tests/download/{upload_folder}/{uploaded_filename}'\n        # )\n        # assert r.status_code == 200\n        # content = r.data.decode('utf-8')\n        # # Uhmmm... should not be up_data2 + up_data ??\n        # assert content == up_data + up_data2\n\n        data[\"force\"] = False\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 409\n        err = f\"File '{uploaded_filename}' already exists\"\n        assert self.get_content(r) == err\n\n        data[\"force\"] = True\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 201\n        assert self.get_content(r) == \"\"\n        upload_endpoint = get_location_header(\n            r.headers, expected=f\"{API_URI}/tests/chunkedupload/{filename}\"\n        )\n\n        data[\"name\"] = \"fixed.filename.notallowed\"\n        data[\"force\"] = False\n        r = client.post(f\"{API_URI}/tests/chunkedupload\", data=data)\n        assert r.status_code == 400\n        assert self.get_content(r) == \"File extension not allowed\"\n\n        # Send an upload on a file endpoint not previously initialized\n        filename = f\"{faker.pystr()}.txt\"\n        with io.StringIO(up_data2) as f:\n            r = client.put(\n                f\"{API_URI}/tests/chunkedupload/{filename}\",\n                data=f,\n                headers={\"Content-Range\": f\"bytes */{STR_LEN}\"},\n            )\n\n        assert r.status_code == 503\n        error = \"Permission denied: the destination file does not exist\"\n        assert self.get_content(r) == error\n\n        destination_path = DATA_PATH.joinpath(upload_folder, filename)\n        assert not destination_path.exists()\n", "test_endpoints_users_custom_fields.py": "import pytest\n\nfrom restapi.env import Env\nfrom restapi.tests import API_URI, AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.globals import mem\n\n\nclass TestApp(BaseTests):\n    @pytest.mark.skipif(\n        not Env.get_bool(\"AUTH_ENABLE\")\n        or not Env.get_bool(\"MAIN_LOGIN_ENABLE\")\n        or not Env.get_bool(\"ALLOW_REGISTRATION\"),\n        reason=\"This test needs authentication and registration to be available\",\n    )\n    def test_users_custom_fields(self, client: FlaskClient) -> None:\n        output_fields = mem.customizer.get_custom_output_fields(None)\n\n        profile_inputs = mem.customizer.get_custom_input_fields(\n            request=None, scope=mem.customizer.PROFILE\n        )\n        registration_inputs = mem.customizer.get_custom_input_fields(\n            request=None, scope=mem.customizer.REGISTRATION\n        )\n        admin_inputs = mem.customizer.get_custom_input_fields(\n            request=None, scope=mem.customizer.ADMIN\n        )\n        uuid, data = self.create_user(client)\n        headers, _ = self.do_login(client, data[\"email\"], data[\"password\"])\n\n        # Verify custom output fields (if defined) included in the profile response\n        r = client.get(f\"{AUTH_URI}/profile\", headers=headers)\n        assert r.status_code == 200\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n\n        for field in output_fields:\n            assert field in response\n\n        # Verify custom input fields (if defined) included in the profile input schema\n        r = client.patch(f\"{AUTH_URI}/profile\", json={\"get_schema\": 1}, headers=headers)\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        for field in profile_inputs.keys():\n            for expected in response:\n                if expected[\"key\"] == field:\n                    break\n            else:  # pragma: no cover\n                pytest.fail(f\"Input field {field} not found in profile input schema\")\n\n        # Verify custom registration fields (if defined) included in the reg. schema\n        r = client.post(f\"{AUTH_URI}/profile\", json={\"get_schema\": 1})\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        for field in registration_inputs.keys():\n            for expected in response:\n                if expected[\"key\"] == field:\n                    break\n            else:  # pragma: no cover\n                pytest.fail(\n                    f\"Input field {field} not found in registration input schema\"\n                )\n\n        headers, _ = self.do_login(client, None, None)\n        # Verify custom admin input fields (if defined) included in admin users schema\n        r = client.post(\n            f\"{API_URI}/admin/users\", json={\"get_schema\": 1}, headers=headers\n        )\n        response = self.get_content(r)\n        assert isinstance(response, list)\n        for field in admin_inputs.keys():\n            for expected in response:\n                if expected[\"key\"] == field:\n                    break\n            else:  # pragma: no cover\n                pytest.fail(\n                    f\"Input field {field} not found in admin users input schema\"\n                )\n\n        # Verify custom admin output fields (if defined) included in admin users output\n        r = client.get(f\"{API_URI}/admin/users/{uuid}\", headers=headers)\n        response = self.get_content(r)\n        assert isinstance(response, dict)\n        for field in output_fields:\n            # This will fail\n            assert field in response\n", "test_module_authentication.py": "import time\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nimport pyotp\nimport pytest\nimport pytz\nfrom faker import Faker\n\nfrom restapi.connectors import Connector\nfrom restapi.env import Env\nfrom restapi.exceptions import BadRequest, Conflict, Unauthorized\nfrom restapi.services.authentication import (\n    DEFAULT_GROUP_NAME,\n    BaseAuthentication,\n    InvalidToken,\n    Role,\n    RoleObj,\n)\nfrom restapi.tests import BaseTests, FlaskClient\n\n\ndef verify_token_is_valid(\n    auth: BaseAuthentication, token: str, ttype: Optional[str] = None\n) -> None:\n    unpacked_token = auth.verify_token(token, token_type=ttype)\n    assert unpacked_token[0]\n    assert unpacked_token[1] is not None\n    assert unpacked_token[2] is not None\n    assert unpacked_token[3] is not None\n\n\ndef verify_token_is_not_valid(\n    auth: BaseAuthentication, token: str, ttype: Optional[str] = None\n) -> None:\n    unpacked_token = auth.verify_token(token, token_type=ttype)\n    assert not unpacked_token[0]\n    assert unpacked_token[1] is None\n    assert unpacked_token[2] is None\n    assert unpacked_token[3] is None\n\n    with pytest.raises(Exception):\n        auth.verify_token(token, token_type=ttype, raiseErrors=True)\n\n\n@pytest.mark.skipif(\n    not Connector.check_availability(\"authentication\"),\n    reason=\"This test needs authentication to be available\",\n)\nclass TestApp(BaseTests):\n    def test_password_management(self, faker: Faker) -> None:\n        # Ensure name and surname longer than 3\n        name = self.get_first_name(faker)\n        surname = self.get_last_name(faker)\n        # Ensure an email not containing name and surname\n        email = self.get_random_email(faker, name, surname)\n\n        auth = Connector.get_authentication_instance()\n\n        min_pwd_len = Env.get_int(\"AUTH_MIN_PASSWORD_LENGTH\", 9999)\n\n        pwd = faker.password(min_pwd_len - 1)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"The new password cannot match the previous password\"\n\n        pwd = faker.password(min_pwd_len - 1)\n        old_pwd = faker.password(min_pwd_len)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        error = f\"Password is too short, use at least {min_pwd_len} characters\"\n        assert ret_text == error\n\n        pwd = faker.password(min_pwd_len, low=False, up=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing lower case letters\"\n\n        pwd = faker.password(min_pwd_len, low=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing upper case letters\"\n\n        pwd = faker.password(min_pwd_len, low=True, up=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing numbers\"\n\n        pwd = faker.password(min_pwd_len, low=True, up=True, digits=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert not ret_val\n        assert ret_text == \"Password is too weak, missing special characters\"\n\n        pwd = faker.password(min_pwd_len, low=True, up=True, digits=True, symbols=True)\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=pwd, old_pwd=old_pwd, email=email, name=name, surname=surname\n        )\n        assert ret_val\n        assert ret_text == \"\"\n\n        password_with_name = [\n            name,\n            surname,\n            f\"{faker.pystr()}{name}{faker.pystr()}\"\n            f\"{faker.pystr()}{surname}{faker.pystr()}\"\n            f\"{name}{faker.pyint(1, 99)}\",\n        ]\n        for p in password_with_name:\n            for pp in [p, p.lower(), p.upper(), p.title()]:\n                # This is because with \"strange characters\" it is not ensured that:\n                # str == str.upper().lower()\n                # In that case let's skip the variant that alter the characters\n                if p.lower() != pp.lower():  # pragma: no cover\n                    continue\n                # This is to prevent failures for other reasons like length of chars\n                pp += \"+ABCabc123!\"\n                val, text = auth.verify_password_strength(\n                    pwd=pp, old_pwd=old_pwd, email=email, name=name, surname=surname\n                )\n                assert not val\n                assert text == \"Password is too weak, can't contain your name\"\n\n        email_local = email.split(\"@\")[0]\n        password_with_email = [\n            email,\n            email.replace(\".\", \"\").replace(\"_\", \"\"),\n            email_local,\n            email_local.replace(\".\", \"\").replace(\"_\", \"\"),\n            f\"{faker.pystr()}{email_local}{faker.pystr()}\",\n        ]\n\n        for p in password_with_email:\n            for pp in [p, p.lower(), p.upper(), p.title()]:\n                # This is because with \"strange characters\" it is not ensured that:\n                # str == str.upper().lower()\n                # In that case let's skip the variant that alter the characters\n                if p.lower() != pp.lower():  # pragma: no cover\n                    continue\n                # This is to prevent failures for other reasons like length of chars\n                pp += \"+ABCabc123!\"\n                val, txt = auth.verify_password_strength(\n                    pwd=pp, old_pwd=old_pwd, email=email, name=name, surname=surname\n                )\n                assert not val\n                assert txt == \"Password is too weak, can't contain your email address\"\n\n        # Short names are not inspected for containing checks\n        ret_val, ret_text = auth.verify_password_strength(\n            pwd=\"Bob1234567!\", old_pwd=old_pwd, email=email, name=\"Bob\", surname=surname\n        )\n        assert ret_val\n        assert ret_text == \"\"\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        pwd = faker.password(min_pwd_len - 1)\n\n        with pytest.raises(BadRequest, match=r\"Missing new password\"):\n            # None password\n            auth.change_password(user, pwd, None, None)\n\n        with pytest.raises(BadRequest, match=r\"Missing password confirmation\"):\n            # None password confirmation\n            auth.change_password(user, pwd, pwd, None)\n\n        with pytest.raises(\n            Conflict, match=r\"Your password doesn't match the confirmation\"\n        ):\n            # wrong confirmation\n            auth.change_password(user, pwd, pwd, faker.password(strong=True))\n\n        with pytest.raises(\n            Conflict,\n            match=r\"The new password cannot match the previous password\",\n        ):\n            # Failed password strength checks\n            auth.change_password(user, pwd, pwd, pwd)\n\n        with pytest.raises(\n            Conflict,\n            match=rf\"Password is too short, use at least {min_pwd_len} characters\",\n        ):\n            # the first password parameter is only checked for new password strenght\n            # i.e. is verified password != newpassword\n            # pwd validity will be checked once completed checks on new password\n            # => a random current password is ok here\n            # Failed password strength checks\n            auth.change_password(user, faker.password(), pwd, pwd)\n\n        pwd1 = faker.password(strong=True)\n        pwd2 = faker.password(strong=True)\n\n        hash_1 = auth.get_password_hash(pwd1)\n        assert len(hash_1) > 0\n        assert hash_1 != auth.get_password_hash(pwd2)\n\n        with pytest.raises(Unauthorized, match=r\"Invalid password\"):\n            # Hashing empty password\n            auth.get_password_hash(\"\")\n\n        with pytest.raises(Unauthorized, match=r\"Invalid password\"):\n            # Hashing a None password!\n            auth.get_password_hash(None)\n\n        assert auth.verify_password(pwd1, hash_1)\n\n        assert not auth.is_bcrypt_hashed(\"test\")\n        test_hash = auth.get_password_hash(pwd1)\n        assert auth.is_bcrypt_hashed(test_hash)\n\n    @staticmethod\n    @pytest.mark.skipif(\n        not Env.get_bool(\"AUTH_SECOND_FACTOR_AUTHENTICATION\"),\n        reason=\"This test needs 2FA to be available\",\n    )\n    def test_totp_management() -> None:\n        auth = Connector.get_authentication_instance()\n\n        with pytest.raises(Unauthorized, match=r\"Verification code is missing\"):\n            # NULL totp\n            auth.verify_totp(None, None)\n\n        user = auth.get_user(username=auth.default_user)\n        secret = auth.get_totp_secret(user)\n        totp = pyotp.TOTP(secret)\n\n        # Verifiy current totp\n        assert auth.verify_totp(user, totp.now())\n\n        now = datetime.now()\n        t30s = timedelta(seconds=30)\n\n        # Verify previous and next totp(s)\n        assert auth.verify_totp(user, totp.at(now + t30s))\n        assert auth.verify_totp(user, totp.at(now - t30s))\n\n        # Verify second-previous and second-ntext totp(s)\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Future totp\n            auth.verify_totp(user, totp.at(now + t30s + t30s))\n\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Past totp\n            auth.verify_totp(user, totp.at(now - t30s - t30s))\n\n        # Extend validity window\n        auth.TOTP_VALIDITY_WINDOW = 2\n\n        # Verify again second-previous and second-ntext totp(s)\n        assert auth.verify_totp(user, totp.at(now + t30s + t30s))\n        assert auth.verify_totp(user, totp.at(now - t30s - t30s))\n\n        # Verify second-second-previous and second-second-ntext totp(s)\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Future totp\n            auth.verify_totp(user, totp.at(now + t30s + t30s + t30s))\n\n        with pytest.raises(Unauthorized, match=r\"Verification code is not valid\"):\n            # Past totp\n            auth.verify_totp(user, totp.at(now - t30s - t30s - t30s))\n\n    @staticmethod\n    def test_login_management(faker: Faker) -> None:\n        auth = Connector.get_authentication_instance()\n\n        if BaseAuthentication.default_user:\n            logins = auth.get_logins(BaseAuthentication.default_user)\n\n            assert isinstance(logins, list)\n            assert len(logins) > 0\n\n            auth.flush_failed_logins(BaseAuthentication.default_user)\n            logins = auth.get_logins(\n                BaseAuthentication.default_user, only_unflushed=True\n            )\n            assert len(logins) == 0\n\n            logins = auth.get_logins(\n                BaseAuthentication.default_user, only_unflushed=False\n            )\n            assert len(logins) > 0\n\n        logins = auth.get_logins(faker.ascii_email())\n        assert isinstance(logins, list)\n        assert len(logins) == 0\n\n        logins = auth.get_logins(faker.pystr())\n        assert isinstance(logins, list)\n        assert len(logins) == 0\n\n    def test_tokens_management(self, client: FlaskClient, faker: Faker) -> None:\n        auth = Connector.get_authentication_instance()\n\n        # Just to verify that the function works\n        verify_token_is_not_valid(auth, faker.pystr())\n        verify_token_is_not_valid(auth, faker.pystr(), auth.PWD_RESET)\n        verify_token_is_not_valid(auth, faker.pystr(), auth.ACTIVATE_ACCOUNT)\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        t1, payload1 = auth.create_temporary_token(user, auth.PWD_RESET)\n        assert isinstance(t1, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t1, auth.PWD_RESET)\n        auth.save_token(user, t1, payload1, token_type=auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1)\n        verify_token_is_not_valid(auth, t1, auth.FULL_TOKEN)\n        verify_token_is_valid(auth, t1, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1, auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, faker.ascii_email(), t1)\n\n        # Create another type of temporary token => t1 is still valid\n        t2, payload2 = auth.create_temporary_token(user, auth.ACTIVATE_ACCOUNT)\n        assert isinstance(t2, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t2, auth.ACTIVATE_ACCOUNT)\n        auth.save_token(user, t2, payload2, token_type=auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, t2)\n        verify_token_is_not_valid(auth, t2, auth.FULL_TOKEN)\n        verify_token_is_not_valid(auth, t2, auth.PWD_RESET)\n        verify_token_is_valid(auth, t2, auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, faker.ascii_email(), t2)\n\n        EXPIRATION = 3\n        # Create another token PWD_RESET, this will invalidate t1\n        t3, payload3 = auth.create_temporary_token(\n            user, auth.PWD_RESET, duration=EXPIRATION\n        )\n        assert isinstance(t3, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t3, auth.PWD_RESET)\n        auth.save_token(user, t3, payload3, token_type=auth.PWD_RESET)\n        verify_token_is_valid(auth, t3, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1)\n        verify_token_is_not_valid(auth, t1, auth.FULL_TOKEN)\n        verify_token_is_not_valid(auth, t1, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t1, auth.ACTIVATE_ACCOUNT)\n\n        # Create another token ACTIVATE_ACCOUNT, this will invalidate t2\n        t4, payload4 = auth.create_temporary_token(\n            user, auth.ACTIVATE_ACCOUNT, duration=EXPIRATION\n        )\n        assert isinstance(t4, str)\n        # not valid if not saved\n        verify_token_is_not_valid(auth, t4, auth.ACTIVATE_ACCOUNT)\n        auth.save_token(user, t4, payload4, token_type=auth.ACTIVATE_ACCOUNT)\n        verify_token_is_valid(auth, t4, auth.ACTIVATE_ACCOUNT)\n        verify_token_is_not_valid(auth, t2)\n        verify_token_is_not_valid(auth, t2, auth.FULL_TOKEN)\n        verify_token_is_not_valid(auth, t2, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t2, auth.ACTIVATE_ACCOUNT)\n\n        # token expiration is only 3 seconds... let's test it\n        time.sleep(EXPIRATION + 1)\n        verify_token_is_not_valid(auth, t3, auth.PWD_RESET)\n        verify_token_is_not_valid(auth, t4, auth.ACTIVATE_ACCOUNT)\n\n        unpacked_token = auth.verify_token(None, raiseErrors=False)\n        assert not unpacked_token[0]\n\n        with pytest.raises(InvalidToken, match=r\"Missing token\"):\n            auth.verify_token(None, raiseErrors=True)\n\n        # Test token validiy\n        _, token = self.do_login(client, None, None)\n\n        tokens = auth.get_tokens(get_all=True)\n        jti = None\n        user = None\n        for t in tokens:\n            if t[\"token\"] == token:\n                jti = t[\"id\"]\n                user = t[\"user\"]\n                break\n        assert jti is not None\n        assert user is not None\n\n        assert auth.verify_token_validity(jti, user)\n\n        # Verify token against a wrong user\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        another_user = auth.create_user(\n            {\n                \"email\": faker.ascii_email(),\n                \"name\": \"Default\",\n                \"surname\": \"User\",\n                \"password\": faker.password(strong=True),\n                \"last_password_change\": datetime.now(pytz.utc),\n            },\n            # It will be expanded with the default role\n            roles=[],\n            group=group,\n        )\n        auth.save_user(another_user)\n\n        assert not auth.verify_token_validity(jti, another_user)\n\n    @staticmethod\n    def test_users_groups_roles(faker: Faker) -> None:\n        auth = Connector.get_authentication_instance()\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        group = auth.get_group(name=\"Default\")\n        assert user is not None\n\n        user = auth.get_user(user_id=user.uuid)\n        assert user is not None\n\n        user = auth.get_user(username=\"invalid\")\n        assert user is None\n\n        user = auth.get_user(user_id=\"invalid\")\n        assert user is None\n\n        user = auth.get_user(username=None, user_id=None)\n        assert user is None\n\n        # Test the precedence, username valid  and user invalid => user\n        user = auth.get_user(\n            username=BaseAuthentication.default_user, user_id=\"invalid\"\n        )\n        assert user is not None\n\n        # Test the precedence, username invalid and user valid => None\n        user = auth.get_user(username=\"invalid\", user_id=user.uuid)\n        assert user is None\n\n        assert auth.get_user(None, None) is None\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user is not None\n        assert not auth.save_user(None)\n        assert auth.save_user(user)\n        assert not auth.delete_user(None)\n\n        assert auth.get_group(None, None) is None\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert group is not None\n        assert not auth.save_group(None)\n        assert auth.save_group(group)\n        assert not auth.delete_group(None)\n\n        # None user has no roles ... verify_roles will always be False\n        assert not auth.verify_roles(None, [\"A\", \"B\"], required_roles=\"invalid\")\n        assert not auth.verify_roles(None, [\"A\", \"B\"], required_roles=\"ALL\")\n        assert not auth.verify_roles(None, [\"A\", \"B\"], required_roles=\"ANY\")\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user is not None\n        group = auth.get_group(name=\"Default\")\n        assert group is not None\n\n        assert not auth.delete_user(None)\n        assert not auth.delete_group(None)\n\n        # Delete default user, default group and all users belonging to it\n        members = auth.get_group_members(group)\n        for u in members:\n            assert auth.delete_user(u)\n        assert auth.delete_user(user)\n        assert auth.delete_group(group)\n\n        # Verify that both user and group are now deleted\n        assert auth.get_user(username=BaseAuthentication.default_user) is None\n        assert auth.get_group(name=\"Default\") is None\n\n        # init_auth_db should restore missing default user and group.\n        # But previous tests created additional users and groups, so that\n        # the init auth db without force flags is not able to re-add\n        # the missing and user and group\n        if Env.get_bool(\"MAIN_LOGIN_ENABLE\"):\n            auth.init_auth_db({})\n            assert auth.get_user(username=BaseAuthentication.default_user) is None\n            assert auth.get_group(name=\"Default\") is None\n\n        # Let's add the force flags to re-create the default user and group\n        auth.init_auth_db({\"force_user\": True, \"force_group\": True})\n        assert auth.get_user(username=BaseAuthentication.default_user) is not None\n        assert auth.get_group(name=\"Default\") is not None\n\n        # Let's save the current password to be checked later\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        # expected_pwd = user.password\n        # Let's verify that the user now is ADMIN\n        assert Role.ADMIN.value in auth.get_roles_from_user(user)\n\n        # Modify default user and group\n        # # Change name, password and roles\n        user.name = \"Changed\"\n        # user.password = BaseAuthentication.get_password_hash(\"new-pwd#2!\")\n        auth.link_roles(user, [Role.USER.value])\n        auth.save_user(user)\n\n        # Change fullname (not the shortname, since it is the primary key)\n        group = auth.get_group(name=\"Default\")\n        group.fullname = \"Changed\"\n        auth.save_group(group)\n\n        # Verify that user and group are changed\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user.name == \"Changed\"\n        # assert user.password != expected_pwd\n        assert Role.ADMIN.value not in auth.get_roles_from_user(user)\n        assert Role.USER.value in auth.get_roles_from_user(user)\n\n        group = auth.get_group(name=\"Default\")\n        assert group.fullname == \"Changed\"\n\n        roles: list[RoleObj] = auth.get_roles()\n        assert isinstance(roles, list)\n        assert len(roles) > 0\n\n        # Pick one of the default roles and change the description\n        role: RoleObj = roles[0]\n        assert role is not None\n        default_name = role.name\n        default_description = role.description\n        new_description = faker.pystr()\n        role.description = new_description\n        assert auth.save_role(role)\n        assert not auth.save_role(None)\n\n        # Create a new custom role\n        new_role_name = faker.pystr()\n        new_role_descr = faker.pystr()\n        auth.create_role(name=new_role_name, description=new_role_descr)\n\n        # Verify the change on the roles and the creation of the new one\n        for r in auth.get_roles():\n            if r.name == default_name:\n                assert r.description == new_description\n                assert r.description != default_description\n\n            if r.name == new_role_name:\n                assert r.description == new_role_descr\n\n        # Verify that duplicated role names are refused at init time\n        roles_data_backup = auth.roles_data\n        auth.roles_data = {\n            \"admin_root\": \"Admin\",\n            \"staff_user\": \"Coordinator\",\n            \"group_coordinator\": \"Coordinator\",\n            \"normal_user\": \"User\",\n        }\n        with pytest.raises(SystemExit):\n            auth.init_roles()\n\n        auth.roles_data = roles_data_backup\n\n        # Verify that init_roles restores description of default roles\n        # While custom roles are not modified\n        auth.init_roles()\n\n        for r in auth.get_roles():\n            # default description restored for this default role\n            if r.name == default_name:\n                assert r.description != new_description\n                assert r.description == default_description\n\n            # custom additional role not modified by init roles\n            if r.name == new_role_name:\n                assert r.description == new_role_descr\n\n        # Verify init without force flag will not restore default user and group\n        auth.init_auth_db({})\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user.name == \"Changed\"\n        # assert user.password != expected_pwd\n        assert Role.ADMIN.value not in auth.get_roles_from_user(user)\n        assert Role.USER.value in auth.get_roles_from_user(user)\n\n        group = auth.get_group(name=\"Default\")\n        assert group.fullname == \"Changed\"\n\n        # Verify init with force flag will not restore the default user and group\n        auth.init_auth_db({\"force_user\": True, \"force_group\": True})\n\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user.name != \"Changed\"\n        # assert user.password == expected_pwd\n        assert Role.ADMIN.value in auth.get_roles_from_user(user)\n        assert Role.USER.value in auth.get_roles_from_user(user)\n\n        group = auth.get_group(name=\"Default\")\n        assert group.fullname != \"Changed\"\n\n    @staticmethod\n    def test_authentication_abstract_methods(faker: Faker) -> None:\n        # Super trick!\n        # https://clamytoe.github.io/articles/2020/Mar/12/testing-abcs-with-abstract-methods-with-pytest\n        abstractmethods = BaseAuthentication.__abstractmethods__\n        BaseAuthentication.__abstractmethods__ = frozenset()\n\n        auth = Connector.get_authentication_instance()\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        role = auth.get_roles()[0]\n\n        auth = BaseAuthentication()  # type: ignore\n\n        assert (\n            auth.get_user(username=faker.ascii_email(), user_id=faker.pystr()) is None\n        )\n\n        assert auth.get_users() is None\n        assert auth.save_user(user=user) is None\n        assert auth.delete_user(user=user) is None\n\n        assert auth.get_group(group_id=faker.pystr(), name=faker.pystr()) is None\n\n        assert auth.get_groups() is None\n        assert auth.get_user_group(user=user) is None\n\n        assert auth.get_group_members(group=group) is None\n\n        assert auth.save_group(group=group) is None\n\n        assert auth.delete_group(group=group) is None\n\n        assert auth.get_tokens(user=user, token_jti=faker.pystr(), get_all=True) is None\n\n        assert auth.verify_token_validity(jti=faker.pystr(), user=user) is None\n\n        assert (\n            auth.save_token(\n                user=user, token=faker.pystr(), payload={}, token_type=faker.pystr()\n            )\n            is None\n        )\n\n        assert auth.invalidate_token(token=faker.pystr()) is None\n\n        assert auth.get_roles() is None\n\n        assert auth.get_roles_from_user(user=user) is None\n\n        assert auth.create_role(name=faker.pystr(), description=faker.pystr()) is None\n        assert auth.save_role(role=role) is None\n\n        group = auth.get_group(name=DEFAULT_GROUP_NAME)\n        assert auth.create_user(userdata={}, roles=[faker.pystr()], group=group) is None\n\n        assert auth.link_roles(user=user, roles=[faker.pystr()]) is None\n        assert auth.create_group(groupdata={}) is None\n\n        assert auth.add_user_to_group(user=user, group=group) is None\n\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=user, failed=True)\n            is None\n        )\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=None, failed=True)\n            is None\n        )\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=user, failed=False)\n            is None\n        )\n        assert (\n            auth.save_login(username=faker.ascii_email(), user=None, failed=False)\n            is None\n        )\n\n        assert auth.get_logins(username=faker.ascii_email) is None\n\n        assert auth.flush_failed_logins(username=faker.ascii_email) is None\n\n        BaseAuthentication.__abstractmethods__ = abstractmethods\n", "test_module_miscellanous.py": "import os\nimport tempfile\nimport time\nfrom datetime import date, datetime, timedelta\nfrom decimal import Decimal\nfrom pathlib import Path\nfrom typing import Any, Optional, Union\n\nimport psutil\nimport pytest\nfrom faker import Faker\nfrom marshmallow.exceptions import ValidationError\n\nfrom restapi.config import (\n    DOMAIN,\n    PRODUCTION,\n    get_backend_url,\n    get_frontend_url,\n    get_host_type,\n)\nfrom restapi.connectors.smtp.notifications import get_html_template\nfrom restapi.decorators import inject_callback_parameters, match_types\nfrom restapi.env import Env\nfrom restapi.exceptions import (\n    BadRequest,\n    Conflict,\n    Forbidden,\n    NotFound,\n    RestApiException,\n    ServerError,\n    ServiceUnavailable,\n    Unauthorized,\n)\nfrom restapi.models import Schema, fields\nfrom restapi.rest.definition import EndpointResource\nfrom restapi.rest.response import ResponseMaker, jsonifier\nfrom restapi.services.uploader import Uploader\nfrom restapi.tests import BaseTests\nfrom restapi.utilities.configuration import load_yaml_file, mix\nfrom restapi.utilities.logs import handle_log_output, obfuscate_dict\nfrom restapi.utilities.meta import Meta\nfrom restapi.utilities.processes import (\n    Timeout,\n    find_process,\n    start_timeout,\n    stop_timeout,\n    wait_socket,\n)\nfrom restapi.utilities.time import get_timedelta, seconds_to_human\n\n\nclass TestApp(BaseTests):\n    # #######################################\n    # ####      Env\n    #########################################\n    def test_env(self, faker: Faker) -> None:\n        assert not Env.to_bool(None)\n        assert Env.to_bool(None, True)\n        assert not Env.to_bool(False)\n        assert Env.to_bool(True)\n        assert not Env.to_bool(0)\n        assert Env.to_bool(1)\n        assert Env.to_bool(1 + faker.pyint())\n        assert Env.to_bool(-faker.pyint() - 1)\n        assert not Env.to_bool(\"\")\n        assert not Env.to_bool(\"false\")\n        assert not Env.to_bool(\"False\")\n        assert not Env.to_bool(\"FALSE\")\n        assert Env.to_bool(\"true\")\n        assert Env.to_bool(\"True\")\n        assert Env.to_bool(\"TRUE\")\n        assert Env.to_bool(faker.pystr())\n        assert not Env.to_bool(object)\n        assert Env.to_bool(object, True)\n\n        random_default = faker.pyint()\n        assert Env.to_int(None) == 0\n        assert Env.to_int(None, random_default) == random_default\n        assert Env.to_int(random_default) == random_default\n        assert Env.to_int(\"42\") == 42\n        assert Env.to_int(\"-42\") == -42\n        assert Env.to_int(str(random_default)) == random_default\n        assert Env.to_int(faker.pystr()) == 0\n        assert Env.to_int(faker.pystr(), random_default) == random_default\n        assert Env.to_bool(object) == 0\n\n        prefix = faker.pystr().lower()\n        var1 = faker.pystr()\n        var2 = faker.pystr().lower()\n        var3 = faker.pystr().upper()\n        val1 = faker.pystr()\n        val2 = faker.pystr()\n        val3 = faker.pystr()\n\n        os.environ[f\"{prefix}_{var1}\"] = val1\n        os.environ[f\"{prefix}_{var2}\"] = val2\n        os.environ[f\"{prefix}_{var3}\"] = val3\n        variables = Env.load_variables_group(prefix)\n        assert variables is not None\n        assert isinstance(variables, dict)\n        assert len(variables) == 3\n        assert var2 in variables\n        assert var3 not in variables\n        assert var3.lower() in variables\n        assert variables.get(var1.lower()) == val1\n        assert variables.get(var2.lower()) == val2\n        assert variables.get(var3.lower()) == val3\n\n    # #######################################\n    # ####      Responses\n    #########################################\n    def test_responses(self, faker: Faker) -> None:\n        class MySchema(Schema):\n            name = fields.Str()\n\n        f = \"myfield\"\n        assert (\n            ResponseMaker.get_schema_type(f, fields.Str(metadata={\"password\": True}))\n            == \"password\"\n        )\n        assert ResponseMaker.get_schema_type(f, fields.Bool()) == \"boolean\"\n        assert ResponseMaker.get_schema_type(f, fields.Boolean()) == \"boolean\"\n        assert ResponseMaker.get_schema_type(f, fields.Date()) == \"date\"\n        assert ResponseMaker.get_schema_type(f, fields.DateTime()) == \"datetime\"\n        assert ResponseMaker.get_schema_type(f, fields.AwareDateTime()) == \"datetime\"\n        assert ResponseMaker.get_schema_type(f, fields.NaiveDateTime()) == \"datetime\"\n        assert ResponseMaker.get_schema_type(f, fields.Decimal()) == \"number\"\n        assert ResponseMaker.get_schema_type(f, fields.Email()) == \"email\"\n        assert ResponseMaker.get_schema_type(f, fields.Float()) == \"number\"\n        assert ResponseMaker.get_schema_type(f, fields.Int()) == \"int\"\n        assert ResponseMaker.get_schema_type(f, fields.Integer()) == \"int\"\n        assert ResponseMaker.get_schema_type(f, fields.Number()) == \"number\"\n        assert ResponseMaker.get_schema_type(f, fields.Str()) == \"string\"\n        assert ResponseMaker.get_schema_type(f, fields.String()) == \"string\"\n        assert ResponseMaker.get_schema_type(f, fields.Dict()) == \"dictionary\"\n        assert ResponseMaker.get_schema_type(f, fields.List(fields.Str())) == \"string[]\"\n        assert ResponseMaker.get_schema_type(f, fields.Nested(MySchema())) == \"nested\"\n        # Unsupported types, fallback to string\n        assert ResponseMaker.get_schema_type(f, fields.URL()) == \"string\"\n        assert ResponseMaker.get_schema_type(f, fields.Url()) == \"string\"\n        assert ResponseMaker.get_schema_type(f, fields.UUID()) == \"string\"\n        # assert ResponseMaker.get_schema_type(f, fields.Constant(\"x\")) == \"string\"\n        assert ResponseMaker.get_schema_type(f, fields.Field()) == \"string\"\n        # assert ResponseMaker.get_schema_type(f, fields.Function()) == \"string\"\n        # assert ResponseMaker.get_schema_type(f, fields.Mapping()) == \"string\"\n        # assert ResponseMaker.get_schema_type(f, fields.Method()) == \"string\"\n        # assert ResponseMaker.get_schema_type(f, fields.Raw()) == \"string\"\n        # assert ResponseMaker.get_schema_type(f, fields.TimeDelta()) == \"string\"\n\n        assert not ResponseMaker.is_binary(None)\n        assert not ResponseMaker.is_binary(\"\")\n        assert not ResponseMaker.is_binary(\"application/json\")\n        assert ResponseMaker.is_binary(\"application/octet-stream\")\n        assert ResponseMaker.is_binary(\"application/x-bzip\")\n        assert ResponseMaker.is_binary(\"application/x-bzip2\")\n        assert ResponseMaker.is_binary(\"application/pdf\")\n        assert ResponseMaker.is_binary(\"application/msword\")\n        assert ResponseMaker.is_binary(\"application/rtf\")\n        assert ResponseMaker.is_binary(\"application/x-tar\")\n        assert ResponseMaker.is_binary(\"application/gzip\")\n        assert ResponseMaker.is_binary(\"application/zip\")\n        assert ResponseMaker.is_binary(\"application/x-7z-compressed\")\n        assert not ResponseMaker.is_binary(\"text/plain\")\n        assert not ResponseMaker.is_binary(\"text/css\")\n        assert not ResponseMaker.is_binary(\"text/csv\")\n        assert not ResponseMaker.is_binary(\"text/html\")\n        assert not ResponseMaker.is_binary(\"text/javascript\")\n        assert not ResponseMaker.is_binary(\"text/xml\")\n        assert ResponseMaker.is_binary(\"image/gif\")\n        assert ResponseMaker.is_binary(\"image/jpeg\")\n        assert ResponseMaker.is_binary(\"image/png\")\n        assert ResponseMaker.is_binary(\"image/svg+xml\")\n        assert ResponseMaker.is_binary(\"image/tiff\")\n        assert ResponseMaker.is_binary(\"image/webp\")\n        assert ResponseMaker.is_binary(\"image/bmp\")\n        assert ResponseMaker.is_binary(\"image/aac\")\n        assert ResponseMaker.is_binary(\"audio/midi\")\n        assert ResponseMaker.is_binary(\"audio/mpeg\")\n        assert ResponseMaker.is_binary(\"audio/wav\")\n        assert ResponseMaker.is_binary(\"audio/anyother\")\n        assert ResponseMaker.is_binary(\"video/mpeg\")\n        assert ResponseMaker.is_binary(\"video/ogg\")\n        assert ResponseMaker.is_binary(\"video/webm\")\n        assert ResponseMaker.is_binary(\"video/anyother\")\n        assert ResponseMaker.is_binary(\"video/anyother\")\n        assert not ResponseMaker.is_binary(faker.pystr())\n\n        response = EndpointResource.response(\"\", code=200)\n        assert response[1] == 200  # type: ignore\n        response = EndpointResource.response(None, code=200)\n        assert response[1] == 204  # type: ignore\n        response = EndpointResource.response(None, code=200, head_method=True)\n        assert response[1] == 200  # type: ignore\n\n    def test_jsonifier(self) -> None:\n        assert jsonifier(\"x\") == '\"x\"'\n        assert jsonifier(\"1\") == '\"1\"'\n        assert jsonifier(1) == \"1\"\n        assert jsonifier(1.2) == \"1.2\"\n        assert jsonifier(Decimal(\"1.2\")) == \"1.2\"\n        assert jsonifier([\"x\"]) == '[\"x\"]'\n        assert jsonifier({\"x\"}) == '[\"x\"]'\n        assert jsonifier((\"x\",)) == '[\"x\"]'\n        assert jsonifier(Path(\"test\")) == '\"test\"'\n        assert jsonifier(date(2023, 1, 21)) == '\"2023-01-21\"'\n        assert jsonifier(datetime(2023, 1, 21, 11, 34, 21)) == '\"2023-01-21T11:34:21\"'\n\n    # #######################################\n    # ####      Meta\n    #########################################\n    def test_meta(self) -> None:\n        # This is a valid package containing other packages... but no task will be found\n        tasks = Meta.get_celery_tasks(\"restapi.utilities\")\n        assert isinstance(tasks, list)\n        assert len(tasks) == 0\n\n        tasks = Meta.get_celery_tasks(\"this-should-not-exist\")\n        assert isinstance(tasks, list)\n        assert len(tasks) == 0\n\n        mcls = Meta.get_classes_from_module(\"this-should-not-exist\")  # type: ignore\n        assert isinstance(mcls, dict)\n        assert len(mcls) == 0\n\n        assert Meta.get_class(\"this-should-not-exist\", \"this-should-not-exist\") is None\n        assert Meta.get_class(\"initialization\", \"this-should-not-exist\") is None\n        assert Meta.get_class(\"initialization\", \"Initializer\") is not None\n\n        assert not Meta.get_module_from_string(\"this-should-not-exist\")\n\n        with pytest.raises(ModuleNotFoundError):\n            Meta.get_module_from_string(\n                \"this-should-not-exist\",\n                exit_on_fail=True,\n            )\n\n        # This method is not very robust... but... let's test the current implementation\n        # It basicaly return the first args if it is an instance of some classes\n        assert not Meta.get_self_reference_from_args()\n        selfref = Meta.get_self_reference_from_args(\"test\")\n        assert selfref == \"test\"\n\n        models = Meta.import_models(\"this-should\", \"not-exist\", mandatory=False)\n        assert isinstance(models, dict)\n        assert len(models) == 0\n\n        with pytest.raises(SystemExit):\n            Meta.import_models(\"this-should\", \"not-exist\", mandatory=True)\n\n        # Check exit_on_fail default value\n        models = Meta.import_models(\"this-should\", \"not-exist\")\n        assert isinstance(models, dict)\n        assert len(models) == 0\n\n    # #######################################\n    # ####      Templates\n    #########################################\n    def test_templates(self) -> None:\n        h, p = get_html_template(\"this-should-not-exist\", {})\n        assert h is None\n        assert p is None\n\n    # #######################################\n    # ####      Config Utilities\n    #########################################\n    def test_conf_utilities(self, faker: Faker) -> None:\n        assert get_host_type(\"backend-server\") == \"backend-server\"\n        assert get_host_type(\"docs-generation\") == \"docs-generation\"\n        assert get_host_type(\"celery\") == \"celery\"\n        assert get_host_type(\"celery-beat\") == \"celery-beat\"\n        assert get_host_type(\"flower\") == \"flower\"\n        assert get_host_type(\"whateverelse\") == \"celery\"\n        assert get_host_type(faker.pystr()) == \"celery\"\n\n    def test_get_backend_url(self) -> None:\n        # bypass the lru_cache decorator\n        func = get_backend_url.__wrapped__\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}\"\n        else:\n            assert func() == f\"http://{DOMAIN}:8080\"\n\n        os.environ[\"FLASK_PORT\"] = \"1234\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}\"\n        else:\n            assert func() == f\"http://{DOMAIN}:1234\"\n\n        os.environ[\"BACKEND_URL\"] = \"http://mydomain/xyz\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == \"http://mydomain/xyz\"\n        else:\n            assert func() == \"http://mydomain/xyz\"\n\n        os.environ[\"BACKEND_PREFIX\"] = \"abc\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == \"http://mydomain/xyz\"\n        else:\n            assert func() == \"http://mydomain/xyz\"\n\n        os.environ[\"BACKEND_URL\"] = \"\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc:1234\"\n\n        os.environ[\"FLASK_PORT\"] = \"8080\"\n        os.environ[\"BACKEND_PREFIX\"] = \"\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}\"\n        else:\n            assert func() == f\"http://{DOMAIN}:8080\"\n\n        os.environ[\"BACKEND_PREFIX\"] = \"/\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}\"\n        else:\n            assert func() == f\"http://{DOMAIN}:8080\"\n\n        os.environ[\"BACKEND_PREFIX\"] = \"abc/\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc:8080\"\n\n        os.environ[\"BACKEND_PREFIX\"] = \"/abc/\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc:8080\"\n\n        os.environ[\"BACKEND_PREFIX\"] = \"///abc//\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc:8080\"\n\n    def test_get_frontend_url(self) -> None:\n        # bypass the lru_cache decorator\n        func = get_frontend_url.__wrapped__\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}\"\n        else:\n            assert func() == f\"http://{DOMAIN}\"\n\n        os.environ[\"FRONTEND_URL\"] = \"http://mydomain/xyz\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == \"http://mydomain/xyz\"\n        else:\n            assert func() == \"http://mydomain/xyz\"\n\n        os.environ[\"FRONTEND_PREFIX\"] = \"abc\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == \"http://mydomain/xyz\"\n        else:\n            assert func() == \"http://mydomain/xyz\"\n\n        os.environ[\"FRONTEND_URL\"] = \"\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc\"\n\n        os.environ[\"FRONTEND_PREFIX\"] = \"\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}\"\n        else:\n            assert func() == f\"http://{DOMAIN}\"\n\n        os.environ[\"FRONTEND_PREFIX\"] = \"/\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}\"\n        else:\n            assert func() == f\"http://{DOMAIN}\"\n\n        os.environ[\"FRONTEND_PREFIX\"] = \"abc/\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc\"\n\n        os.environ[\"FRONTEND_PREFIX\"] = \"/abc/\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc\"\n\n        os.environ[\"FRONTEND_PREFIX\"] = \"///abc//\"\n        Env.get.cache_clear()\n\n        if PRODUCTION:\n            assert func() == f\"https://{DOMAIN}/abc\"\n        else:\n            assert func() == f\"http://{DOMAIN}/abc\"\n\n    # #######################################\n    # ####      Timeouts\n    #########################################\n    def test_timeouts(self) -> None:\n        start_timeout(1)\n        with pytest.raises(Timeout, match=r\"Operation timeout: interrupted\"):\n            # This operation will be interrupted because slower than timeout\n            time.sleep(2)\n\n        start_timeout(1)\n        try:\n            stop_timeout()\n            # This operation will not be interrupted\n            time.sleep(2)\n        except Exception:  # pragma: no cover\n            pytest.fail(\"Operation interrupted\")\n\n    # #######################################\n    # ####      Logging\n    #########################################\n    def test_logging(self) -> None:\n        log_output = handle_log_output(None)\n        assert isinstance(log_output, dict)\n        assert len(log_output) == 0\n\n        log_output = handle_log_output(\" \")\n        assert isinstance(log_output, dict)\n        assert len(log_output) == 0\n\n        assert handle_log_output(1) == 1\n\n        # obfuscate_dict only accepts dict\n        assert obfuscate_dict(None) is None  # type: ignore\n        assert obfuscate_dict(10) == 10  # type: ignore\n        assert obfuscate_dict([\"x\"]) == [\"x\"]  # type: ignore\n        assert len(obfuscate_dict({})) == 0\n        assert obfuscate_dict({\"x\": \"y\"}) == {\"x\": \"y\"}\n        assert obfuscate_dict({\"password\": \"y\"}) == {\"password\": \"****\"}\n        assert obfuscate_dict({\"pwd\": \"y\"}) == {\"pwd\": \"****\"}\n        assert obfuscate_dict({\"token\": \"y\"}) == {\"token\": \"****\"}\n        assert obfuscate_dict({\"access_token\": \"y\"}) == {\"access_token\": \"****\"}\n        assert obfuscate_dict({\"file\": \"y\"}) == {\"file\": \"****\"}\n        assert obfuscate_dict({\"filename\": \"y\"}) == {\"filename\": \"****\"}\n        assert obfuscate_dict({\"new_password\": \"y\"}) == {\"new_password\": \"****\"}\n        assert obfuscate_dict({\"password_confirm\": \"y\"}) == {\"password_confirm\": \"****\"}\n\n    # #######################################\n    # ####      YAML data load and mix\n    #########################################\n    def test_yaml(self) -> None:\n        data: dict[str, Any] = {\"a\": 1}\n        assert mix({}, data) == data\n\n        data1: dict[str, Any] = {\"a\": {\"b\": 1}, \"c\": 1}\n        data2: dict[str, Any] = {\"a\": {\"b\": 2}}\n        expected: dict[str, Any] = {\"a\": {\"b\": 2}, \"c\": 1}\n\n        assert mix(data1, data2) == expected\n\n        data1 = {\"a\": {\"b\": 1}, \"c\": 1}\n        data2 = {\"a\": None}\n        # Cannot replace with an empty list\n        assert mix(data1, data2) == data1\n\n        data1 = {\"a\": [1, 2]}\n        data2 = {\"a\": [3, 4]}\n        expected = {\"a\": [1, 2, 3, 4]}\n\n        assert mix(data1, data2) == expected\n\n        # Invalid file / path\n        with pytest.raises(AttributeError):\n            load_yaml_file(Path(\"path\", \"invalid\"))\n\n        with pytest.raises(AttributeError):\n            load_yaml_file(Path(\"tests\", \"invalid\"))\n\n        # Valid path, but not in yaml format\n        with pytest.raises(AttributeError):\n            load_yaml_file(Path(\"tests\", \"conftest.py\"))\n\n        # File is empty\n        tmpf = tempfile.NamedTemporaryFile()\n        with pytest.raises(AttributeError):\n            load_yaml_file(Path(tmpf.name))\n        tmpf.close()\n\n    # #######################################\n    # ####      Uploader\n    #########################################\n    def test_uploader(self) -> None:\n        meta = Uploader.get_file_metadata(\"invalid_file\")  # type: ignore\n        assert isinstance(meta, dict)\n        assert len(meta) == 0\n\n        metadata_file_path = \"confs/projects_defaults.yaml\"\n        meta = Uploader.get_file_metadata(metadata_file_path)  # type: ignore\n        assert isinstance(meta, dict)\n        assert len(meta) == 2\n        assert \"type\" in meta\n        assert \"charset\" in meta\n        assert meta[\"type\"] == \"text/plain\"\n        assert meta[\"charset\"] == \"utf-8\"\n\n        meta = Uploader.get_file_metadata(Path(\"invalid_file\"))\n        assert isinstance(meta, dict)\n        assert len(meta) == 0\n\n        meta = Uploader.get_file_metadata(Path(\"confs/projects_defaults.yaml\"))\n        assert isinstance(meta, dict)\n        assert len(meta) == 2\n        assert \"type\" in meta\n        assert \"charset\" in meta\n        assert meta[\"type\"] == \"text/plain\"\n        assert meta[\"charset\"] == \"utf-8\"\n\n        # t = total_length\n        # s = start\n        # e = end\n        tlen, start, end = Uploader.parse_content_range(None)\n        assert tlen is None\n        assert start is None\n        assert end is None\n\n        tlen, start, end = Uploader.parse_content_range(\"\")\n        assert tlen is None\n        assert start is None\n        assert end is None\n\n        tlen, start, end = Uploader.parse_content_range(\"test\")\n        assert tlen is None\n        assert start is None\n        assert end is None\n\n        tlen, start, end = Uploader.parse_content_range(\"test/test\")\n        assert tlen is None\n        assert start is None\n        assert end is None\n\n        tlen, start, end = Uploader.parse_content_range(\"test/1000\")\n        assert tlen == 1000\n        assert start == 0\n        assert end == 1000\n\n        tlen, start, end = Uploader.parse_content_range(\"bytes test/1000\")\n        assert tlen == 1000\n        assert start == 0\n        assert end == 1000\n\n        tlen, start, end = Uploader.parse_content_range(\"bytes */1000\")\n        assert tlen == 1000\n        assert start == 0\n        assert end == 1000\n\n        tlen, start, end = Uploader.parse_content_range(\"bytes 2-499/1000\")\n        assert tlen == 1000\n        assert start == 2\n        assert end == 500\n\n        tlen, start, end = Uploader.parse_content_range(\"bytes 2-499*/1000\")\n        assert tlen == 1000\n        assert start == 0\n        assert end == 1000\n\n        with pytest.raises(\n            BadRequest, match=r\"Invalid null byte in subfolder parameter\"\n        ):\n            Uploader.validate_upload_folder(Path(\"\\x00\"))\n\n        with pytest.raises(\n            BadRequest, match=r\"Invalid null byte in subfolder parameter\"\n        ):\n            Uploader.validate_upload_folder(Path(\"/uploads/\\x00\"))\n\n        with pytest.raises(\n            BadRequest, match=r\"Invalid null byte in subfolder parameter\"\n        ):\n            Uploader.validate_upload_folder(Path(\"/uploads/AA\\x00BB\"))\n\n        with pytest.raises(Forbidden, match=r\"Invalid file path\"):\n            Uploader.validate_upload_folder(Path(\"/etc/\"))\n\n        with pytest.raises(Forbidden, match=r\"Invalid file path\"):\n            Uploader.validate_upload_folder(Path(\"../../tmp/\"))\n\n    # #######################################\n    # ####      Time\n    #########################################\n    def test_time(self, faker: Faker) -> None:\n        every = faker.pyint()\n\n        t = get_timedelta(every, \"seconds\")\n        assert t is not None\n        assert isinstance(t, timedelta)\n        assert 86400 * t.days + t.seconds == every\n        assert t.microseconds == 0\n\n        t = get_timedelta(every, \"days\")\n        assert t is not None\n        assert isinstance(t, timedelta)\n        assert t.days == every\n        assert t.seconds == 0\n        assert t.microseconds == 0\n\n        t = get_timedelta(every, \"microseconds\")\n        assert t is not None\n        assert isinstance(t, timedelta)\n        assert t.days == 0\n        assert 1_000_000 * t.seconds + t.microseconds == every\n\n        t = get_timedelta(every, \"milliseconds\")\n        assert t is not None\n        assert isinstance(t, timedelta)\n        assert t.days == 0\n        assert 1_000_000 * t.seconds + t.microseconds == every * 1000\n\n        t = get_timedelta(every, \"minutes\")\n        assert t is not None\n        assert isinstance(t, timedelta)\n        assert 86400 * t.days + t.seconds == every * 60\n        assert t.microseconds == 0\n\n        t = get_timedelta(every, \"hours\")\n        assert t is not None\n        assert isinstance(t, timedelta)\n        assert 86400 * t.days + t.seconds == every * 3600\n        assert t.microseconds == 0\n\n        t = get_timedelta(every, \"weeks\")\n        assert t is not None\n        assert isinstance(t, timedelta)\n        assert t.days == every * 7\n        assert t.seconds == 0\n        assert t.microseconds == 0\n\n        with pytest.raises(BadRequest):\n            get_timedelta(every, \"months\")  # type: ignore\n\n        with pytest.raises(BadRequest):\n            get_timedelta(every, \"years\")  # type: ignore\n\n        with pytest.raises(BadRequest):\n            get_timedelta(every, faker.pystr())\n\n        assert seconds_to_human(0) == \"0 seconds\"\n        assert seconds_to_human(1) == \"1 second\"\n        assert seconds_to_human(2) == \"2 seconds\"\n        assert seconds_to_human(59) == \"59 seconds\"\n        assert seconds_to_human(60) == \"1 minute\"\n        assert seconds_to_human(61) == \"1 minute, 1 second\"\n        assert seconds_to_human(62) == \"1 minute, 2 seconds\"\n        assert seconds_to_human(119) == \"1 minute, 59 seconds\"\n        assert seconds_to_human(120) == \"2 minutes\"\n        assert seconds_to_human(121) == \"2 minutes, 1 second\"\n        assert seconds_to_human(122) == \"2 minutes, 2 seconds\"\n        assert seconds_to_human(179) == \"2 minutes, 59 seconds\"\n        assert seconds_to_human(532) == \"8 minutes, 52 seconds\"\n        assert seconds_to_human(3600) == \"1 hour\"\n        assert seconds_to_human(3601) == \"1 hour, 0 minutes, 1 second\"\n        assert seconds_to_human(3602) == \"1 hour, 0 minutes, 2 seconds\"\n        assert seconds_to_human(3660) == \"1 hour, 1 minute\"\n        assert seconds_to_human(3661) == \"1 hour, 1 minute, 1 second\"\n        assert seconds_to_human(3662) == \"1 hour, 1 minute, 2 seconds\"\n        assert seconds_to_human(3720) == \"1 hour, 2 minutes\"\n        assert seconds_to_human(7200) == \"2 hours\"\n        assert seconds_to_human(82800) == \"23 hours\"\n        assert seconds_to_human(86399) == \"23 hours, 59 minutes, 59 seconds\"\n        assert seconds_to_human(86400) == \"1 day\"\n        assert seconds_to_human(86401) == \"1 day, 0 hours, 0 minutes, 1 second\"\n        assert seconds_to_human(86402) == \"1 day, 0 hours, 0 minutes, 2 seconds\"\n        assert seconds_to_human(86460) == \"1 day, 0 hours, 1 minute\"\n        assert seconds_to_human(86461) == \"1 day, 0 hours, 1 minute, 1 second\"\n        assert seconds_to_human(86520) == \"1 day, 0 hours, 2 minutes\"\n        assert seconds_to_human(86521) == \"1 day, 0 hours, 2 minutes, 1 second\"\n        assert seconds_to_human(86522) == \"1 day, 0 hours, 2 minutes, 2 seconds\"\n        assert seconds_to_human(90000) == \"1 day, 1 hour\"\n        assert seconds_to_human(90060) == \"1 day, 1 hour, 1 minute\"\n        assert seconds_to_human(90061) == \"1 day, 1 hour, 1 minute, 1 second\"\n        assert seconds_to_human(90062) == \"1 day, 1 hour, 1 minute, 2 seconds\"\n        assert seconds_to_human(90120) == \"1 day, 1 hour, 2 minutes\"\n        assert seconds_to_human(90121) == \"1 day, 1 hour, 2 minutes, 1 second\"\n        assert seconds_to_human(90122) == \"1 day, 1 hour, 2 minutes, 2 seconds\"\n        assert seconds_to_human(93600) == \"1 day, 2 hours\"\n        assert seconds_to_human(777600) == \"9 days\"\n        assert seconds_to_human(10627200) == \"123 days\"\n        assert seconds_to_human(22222222) == \"257 days, 4 hours, 50 minutes, 22 seconds\"\n        assert seconds_to_human(63072000) == \"730 days\"\n\n    # #######################################\n    # ####      Exceptions\n    #########################################\n    def test_exceptions(self) -> None:\n        with pytest.raises(RestApiException) as e:\n            raise BadRequest(\"test\")\n        assert e.value.status_code == 400\n\n        with pytest.raises(RestApiException) as e:\n            raise Unauthorized(\"test\")\n        assert e.value.status_code == 401\n\n        with pytest.raises(RestApiException) as e:\n            raise Forbidden(\"test\")\n        assert e.value.status_code == 403\n\n        with pytest.raises(RestApiException) as e:\n            raise NotFound(\"test\")\n        assert e.value.status_code == 404\n\n        with pytest.raises(RestApiException) as e:\n            raise Conflict(\"test\")\n        assert e.value.status_code == 409\n\n        with pytest.raises(RestApiException) as e:\n            raise ServerError(\"test\")\n        assert e.value.status_code == 500\n\n        with pytest.raises(RestApiException) as e:\n            raise ServiceUnavailable(\"test\")\n        assert e.value.status_code == 503\n\n    def test_marshmallow_schemas(self) -> None:\n        class Input1(Schema):\n            # Note: This is a replacement of the normal DelimitedList defined by rapydo\n            unique_delimited_list = fields.DelimitedList(\n                fields.Str(), delimiter=\",\", required=True, unique=True\n            )\n            # Note: This is a replacement of the normal List list defined by rapydo\n            advanced_list = fields.List(\n                fields.Str(),\n                required=True,\n                unique=True,\n                min_items=2,\n            )\n\n        schema = Input1(strip_required=False)\n        with pytest.raises(ValidationError) as e:\n            schema.load({})\n            pytest.fail(\"No exception raised\")  # pragma: no cover\n        assert isinstance(e.value.messages, dict)\n        assert \"advanced_list\" in e.value.messages\n        err = \"Missing data for required field.\"\n        assert e.value.messages[\"advanced_list\"][0] == err\n        assert \"unique_delimited_list\" in e.value.messages\n        assert e.value.messages[\"unique_delimited_list\"][0] == err\n\n        schema = Input1(strip_required=True)\n        # ValidationError error is not raised because required is stripped of\n        assert len(schema.load({})) == 0\n\n        with pytest.raises(ValidationError) as e:\n            schema.load({\"advanced_list\": None})\n        assert isinstance(e.value.messages, dict)\n        assert \"advanced_list\" in e.value.messages\n        assert e.value.messages[\"advanced_list\"][0] == \"Field may not be null.\"\n\n        with pytest.raises(ValidationError) as e:\n            schema.load({\"advanced_list\": \"\"})\n        assert isinstance(e.value.messages, dict)\n        assert \"advanced_list\" in e.value.messages\n        assert e.value.messages[\"advanced_list\"][0] == \"Not a valid list.\"\n\n        with pytest.raises(ValidationError) as e:\n            schema.load({\"advanced_list\": [10]})\n        assert isinstance(e.value.messages, dict)\n        assert \"advanced_list\" in e.value.messages\n        assert 0 in e.value.messages[\"advanced_list\"]\n        assert e.value.messages[\"advanced_list\"][0][0] == \"Not a valid string.\"\n\n        min_items_error = \"Expected at least 2 items, received 1\"\n        with pytest.raises(ValidationError) as e:\n            schema.load({\"advanced_list\": [\"a\"]})\n        assert isinstance(e.value.messages, dict)\n        assert \"advanced_list\" in e.value.messages\n        assert e.value.messages[\"advanced_list\"][0] == min_items_error\n\n        with pytest.raises(ValidationError) as e:\n            schema.load({\"advanced_list\": [\"a\", \"a\"]})\n        assert isinstance(e.value.messages, dict)\n        assert \"advanced_list\" in e.value.messages\n        assert e.value.messages[\"advanced_list\"][0] == min_items_error\n\n        r = schema.load({\"advanced_list\": [\"a\", \"a\", \"b\"]})\n        assert \"advanced_list\" in r\n        assert len(r[\"advanced_list\"]) == 2\n\n        with pytest.raises(ValidationError) as e:\n            schema.load({\"advanced_list\": {\"a\": \"b\"}})\n        assert isinstance(e.value.messages, dict)\n        assert \"advanced_list\" in e.value.messages\n        assert e.value.messages[\"advanced_list\"][0] == \"Not a valid list.\"\n\n        r = schema.load({\"unique_delimited_list\": \"\"})\n        assert \"unique_delimited_list\" in r\n        # This is because I added a check to return value if value is \"\"\n        assert len(r[\"unique_delimited_list\"]) == 0\n        # assert len(r[\"unique_delimited_list\"]) == 1\n        # assert r[\"unique_delimited_list\"][0] == \"\"\n\n        r = schema.load({\"unique_delimited_list\": \"xyz\"})\n        assert \"unique_delimited_list\" in r\n        assert len(r[\"unique_delimited_list\"]) == 1\n        assert r[\"unique_delimited_list\"][0] == \"xyz\"\n\n        r = schema.load({\"unique_delimited_list\": \"a,b\"})\n        assert \"unique_delimited_list\" in r\n        assert len(r[\"unique_delimited_list\"]) == 2\n        assert r[\"unique_delimited_list\"][0] == \"a\"\n        assert r[\"unique_delimited_list\"][1] == \"b\"\n\n        r = schema.load({\"unique_delimited_list\": \"a,b,c\"})\n        assert \"unique_delimited_list\" in r\n        assert len(r[\"unique_delimited_list\"]) == 3\n        assert r[\"unique_delimited_list\"][0] == \"a\"\n        assert r[\"unique_delimited_list\"][1] == \"b\"\n        assert r[\"unique_delimited_list\"][2] == \"c\"\n\n        with pytest.raises(ValidationError) as e:\n            schema.load({\"unique_delimited_list\": \"a,b,b\"})\n        assert isinstance(e.value.messages, dict)\n        assert \"unique_delimited_list\" in e.value.messages\n        err = \"Input list contains duplicates\"\n        assert e.value.messages[\"unique_delimited_list\"][0] == err\n\n        # No strips on elements\n        r = schema.load({\"unique_delimited_list\": \"a,b, c\"})\n        assert \"unique_delimited_list\" in r\n        assert len(r[\"unique_delimited_list\"]) == 3\n        assert r[\"unique_delimited_list\"][0] == \"a\"\n        assert r[\"unique_delimited_list\"][1] == \"b\"\n        # assert r[\"unique_delimited_list\"][2] == \" c\"\n        # Now input is trimmed\n        assert r[\"unique_delimited_list\"][2] == \"c\"\n\n        r = schema.load({\"unique_delimited_list\": \"a,b,c \"})\n        assert \"unique_delimited_list\" in r\n        assert len(r[\"unique_delimited_list\"]) == 3\n        assert r[\"unique_delimited_list\"][0] == \"a\"\n        assert r[\"unique_delimited_list\"][1] == \"b\"\n        # assert r[\"unique_delimited_list\"][2] == \"c \"\n        # Now input is trimmed\n        assert r[\"unique_delimited_list\"][2] == \"c\"\n\n    def test_callbackend_parameters_injection(self, faker: Faker) -> None:\n        # These functions are not executed => no cover\n        def missing_endpoint() -> None:  # pragma: no cover\n            pass\n\n        # These functions are not executed => no cover\n        def wrong_endpoint(endpoint: str) -> None:  # pragma: no cover\n            pass\n\n        # These functions are not executed => no cover\n        def ok_endpoint_no_params(\n            endpoint: EndpointResource,\n        ) -> None:  # pragma: no cover\n            pass\n\n        # These functions are not executed => no cover\n        def ok_endpoint_with_params(\n            endpoint: EndpointResource, a: str, b: Faker\n        ) -> None:  # pragma: no cover\n            pass\n\n        # Wrong callback: endpoint parameter is missing\n        injected_parameters = inject_callback_parameters(missing_endpoint, {}, {})\n        assert injected_parameters is None\n\n        # Wrong callback: endpoint parameter is missing\n        injected_parameters = inject_callback_parameters(\n            missing_endpoint,\n            {\"endpoint\": None},\n            {\"endpoint\": None},\n        )\n        assert injected_parameters is None\n\n        # Wrong callback: endpoint parameter has a wrong type\n        injected_parameters = inject_callback_parameters(wrong_endpoint, {}, {})\n        assert injected_parameters is None\n\n        # Wrong callback: endpoint parameter has a wrong type\n        injected_parameters = inject_callback_parameters(\n            wrong_endpoint,\n            {\"endpoint\": None},\n            {\"endpoint\": None},\n        )\n        assert injected_parameters is None\n\n        # Callback is good and takes no parameters\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_no_params,\n            {},\n            {},\n        )\n        assert injected_parameters is not None\n\n        # Callback is good and takes no parameters\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_no_params,\n            {\"endpoint\": None, \"a\": \"abc\"},\n            {\"b\": \"aaa\"},\n        )\n        assert injected_parameters is not None\n\n        # Starting from here the callback wants two parameters\n\n        # Parameters not found in kwargs / view_args\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {},\n            {},\n        )\n        assert injected_parameters is None\n\n        # Only one parameter found in kwargs / view_args\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"a\": \"abc\"},\n            {},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found in kwargs / view_args\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"a\": \"abc\"},\n            {\"b\": faker},\n        )\n        assert injected_parameters is not None\n\n        # Both parameters found in kwargs / view_args\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"b\": faker},\n            {\"a\": \"abc\"},\n        )\n        assert injected_parameters is not None\n\n        # Both parameters found in kwargs / view_args\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"a\": \"abc\", \"b\": faker},\n            {},\n        )\n        assert injected_parameters is not None\n\n        # Both parameters found in kwargs / view_args\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {},\n            {\"a\": \"abc\", \"b\": faker},\n        )\n        assert injected_parameters is not None\n\n        # Both parameters found but with wrong type (int instead of str)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"a\": 10, \"b\": faker},\n            {},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found but with wrong type (str instead of Faker)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"a\": \"abc\", \"b\": \"faker\"},\n            {},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found but with wrong type (None instead of Faker)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"a\": \"abc\", \"b\": None},\n            {},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found but with wrong type (None instead of str)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {\"a\": None, \"b\": faker},\n            {},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found but with wrong type (int instead of str)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {},\n            {\"a\": 10, \"b\": faker},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found but with wrong type (str instead of Faker)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {},\n            {\"a\": \"abc\", \"b\": \"faker\"},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found but with wrong type (None instead of Faker)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {},\n            {\"a\": \"abc\", \"b\": None},\n        )\n        assert injected_parameters is None\n\n        # Both parameters found but with wrong type (None instead of str)\n        injected_parameters = inject_callback_parameters(\n            ok_endpoint_with_params,\n            {},\n            {\"a\": None, \"b\": faker},\n        )\n        assert injected_parameters is None\n\n        assert match_types(EndpointResource, EndpointResource)\n        assert not match_types(EndpointResource, \"EndpointResource\")\n        assert not match_types(EndpointResource, None)\n        assert not match_types(EndpointResource, type(None))\n        assert not match_types(EndpointResource, 1)\n        assert not match_types(EndpointResource, True)\n        assert not match_types(EndpointResource, False)\n        assert not match_types(EndpointResource, int)\n        assert not match_types(EndpointResource, [])\n        assert not match_types(EndpointResource, {})\n        assert not match_types(EndpointResource, [\"test\"])\n        assert not match_types(EndpointResource, {\"test\": 1})\n\n        assert match_types(Any, EndpointResource)\n        assert match_types(Any, \"EndpointResource\")\n        assert match_types(Any, None)\n        assert match_types(Any, type(None))\n        assert match_types(Any, 1)\n        assert match_types(Any, True)\n        assert match_types(Any, False)\n        assert match_types(Any, int)\n        assert match_types(Any, type([]))\n        assert match_types(Any, type({}))\n        assert match_types(Any, [\"test\"])\n        assert match_types(Any, {\"test\": 1})\n\n        assert not match_types(str, EndpointResource)\n        assert match_types(str, \"EndpointResource\")\n        assert not match_types(str, None)\n        assert not match_types(str, 1)\n        assert not match_types(str, True)\n        assert not match_types(str, False)\n        assert not match_types(str, [])\n        assert not match_types(str, {})\n        assert not match_types(str, [\"test\"])\n        assert not match_types(str, {\"test\": 1})\n\n        assert not match_types(Optional[str], EndpointResource)\n        assert match_types(Optional[str], \"EndpointResource\")\n        assert match_types(Optional[str], type(None))\n        assert not match_types(Optional[str], 1)\n        assert not match_types(Optional[str], [])\n        assert not match_types(Optional[str], {})\n        assert not match_types(Optional[str], [\"test\"])\n        assert not match_types(Optional[str], {\"test\": 1})\n\n        assert match_types(Union[str, int], 1)\n        assert match_types(Union[str, int], \"1\")\n        assert not match_types(Union[str, int], [])\n\n        assert match_types(bool, True)\n        assert match_types(bool, False)\n        assert not match_types(bool, 0)\n        assert not match_types(bool, 1)\n        assert not match_types(bool, \"...\")\n        assert not match_types(bool, [])\n        assert not match_types(bool, [1])\n\n        # please note the \"not Union\" that I added for a mistake\n        # leading to a infinite recursion loop\n        # before adding as specific case in match_types\n        assert not match_types(not Union[str, int], [])\n\n    # #######################################\n    # ####      Processes\n    #########################################\n    def test_processes(self) -> None:\n        assert not find_process(\"this-should-not-exist\")\n        assert find_process(\"restapi\")\n        assert find_process(\"dumb-init\")\n        # current process is not retrieved by find_process\n        current_pid = os.getpid()\n        process = psutil.Process(current_pid)\n        assert not find_process(process.name())\n\n        start_timeout(15)\n        with pytest.raises(Timeout):\n            wait_socket(\"invalid\", 123, service_name=\"test\")\n\n        start_timeout(15)\n        with pytest.raises(ServiceUnavailable):\n            wait_socket(\"invalid\", 123, service_name=\"test\", retries=2)\n", "test_xxx_unused_credentials_step2.py": "\"\"\"\nThis will used credentials created at the beginning of the suite\nto verify that unused credentialas are banned\n\"\"\"\n\nfrom faker import Faker\n\nfrom restapi.env import Env\nfrom restapi.tests import AUTH_URI, BaseTests, FlaskClient\nfrom restapi.utilities.logs import Events\n\nif Env.get_int(\"AUTH_DISABLE_UNUSED_CREDENTIALS_AFTER\") > 0:\n\n    class TestApp1(BaseTests):\n        def test_test_unused_credentials(\n            self, client: FlaskClient, faker: Faker\n        ) -> None:\n            assert BaseTests.unused_credentials is not None\n            assert len(BaseTests.unused_credentials) == 3\n\n            data = {\n                \"username\": BaseTests.unused_credentials[0],\n                \"password\": faker.password(strong=True),\n            }\n\n            # Credentials are verified before the inactivity check\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 401\n            resp = self.get_content(r)\n            assert resp == \"Invalid access credentials\"\n\n            data = {\n                \"username\": BaseTests.unused_credentials[0],\n                \"password\": BaseTests.unused_credentials[1],\n            }\n\n            # Login is blocked due to inactivity\n            r = client.post(f\"{AUTH_URI}/login\", json=data)\n            assert r.status_code == 403\n            resp = self.get_content(r)\n            assert resp == \"Sorry, this account is blocked for inactivity\"\n\n            # Also password reset is blocked... how to recover the account !?\n            reset_data = {\"reset_email\": BaseTests.unused_credentials[0]}\n            r = client.post(f\"{AUTH_URI}/reset\", json=reset_data)\n            assert r.status_code == 403\n            resp = self.get_content(r)\n            assert resp == \"Sorry, this account is blocked for inactivity\"\n\n            events = self.get_last_events(2)\n            assert events[0].event == Events.refused_login.value\n            assert events[0].payload[\"username\"] == BaseTests.unused_credentials[0]\n            assert (\n                events[0].payload[\"motivation\"] == \"account blocked due to inactivity\"\n            )\n            assert events[1].event == Events.refused_login.value\n            assert events[1].payload[\"username\"] == BaseTests.unused_credentials[0]\n            assert (\n                events[1].payload[\"motivation\"] == \"account blocked due to inactivity\"\n            )\n            assert events[1].url == \"/auth/reset\"\n\n            # Goodbye temporary user\n            self.delete_user(client, BaseTests.unused_credentials[2])\n", "test_zzz1_destroy.py": "\"\"\"\nThis test is intended to be executed as second-last, just before the re-init test\n(this is why it is prefixed as zzz1)\nBeware: if env TEST_DESTROY_MODE == 1 this test will destroy your database, be careful\n\"\"\"\n\nimport os\n\nimport pytest\n\nfrom restapi.connectors import Connector\nfrom restapi.exceptions import ServiceUnavailable\nfrom restapi.server import ServerModes, create_app\nfrom restapi.services.authentication import BaseAuthentication\n\n\n# Only executed if tests are run with --destroy flag\n@pytest.mark.skipif(\n    not Connector.check_availability(\"authentication\")\n    or os.getenv(\"TEST_DESTROY_MODE\", \"0\") != \"1\",\n    reason=\"This test needs authentication and TEST_DESTROY_MODE to be enabled\",\n)\ndef test_destroy() -> None:\n    auth = Connector.get_authentication_instance()\n\n    user = auth.get_user(username=BaseAuthentication.default_user)\n    assert user is not None\n\n    create_app(name=\"Flask Tests\", mode=ServerModes.DESTROY, options={})\n\n    if Connector.check_availability(\"sqlalchemy\"):\n        with pytest.raises(ServiceUnavailable):\n            auth = Connector.get_authentication_instance()\n            user = auth.get_user(username=BaseAuthentication.default_user)\n    else:\n        auth = Connector.get_authentication_instance()\n        user = auth.get_user(username=BaseAuthentication.default_user)\n        assert user is None\n", "test_zzz2_re-init.py": "\"\"\"\nThis test is intended to be executed as last, just after the destroy test\n(this is why it is prefixed as zzz2)\nBeware: if env TEST_DESTROY_MODE == 1 this test will destroy your database, be careful\n\"\"\"\n\nimport os\n\nimport pytest\n\nfrom restapi.connectors import Connector\nfrom restapi.server import ServerModes, create_app\nfrom restapi.services.authentication import BaseAuthentication\n\n\n# Only executed if tests are run with --destroy flag\n@pytest.mark.skipif(\n    not Connector.check_availability(\"authentication\")\n    or os.getenv(\"TEST_DESTROY_MODE\", \"0\") != \"1\",\n    reason=\"This test needs authentication and TEST_DESTROY_MODE to be enabled\",\n)\ndef test_init() -> None:\n    if Connector.check_availability(\"sqlalchemy\"):\n        # Prevents errors like:\n        # sqlalchemy.exc.ResourceClosedError: This Connection is closed\n        Connector.disconnect_all()\n\n    try:\n        create_app(name=\"Flask Tests\", mode=ServerModes.INIT, options={})\n        # This is only a rough retry to prevent random errors from sqlalchemy\n    except Exception:  # pragma: no cover\n        create_app(name=\"Flask Tests\", mode=ServerModes.INIT, options={})\n\n    auth = Connector.get_authentication_instance()\n    try:\n        user = auth.get_user(username=BaseAuthentication.default_user)\n    # SqlAlchemy sometimes can raise an:\n    # AttributeError: 'NoneType' object has no attribute 'twophase'\n    # due to the multiple app created... should be an issue specific of this test\n    # In that case... simply retry.\n    except AttributeError:  # pragma: no cover\n        user = auth.get_user(username=BaseAuthentication.default_user)\n\n    assert user is not None\n", "conftest.py": "import pytest\nfrom faker import Faker\nfrom flask import Flask\n\nfrom restapi.server import ServerModes, create_app\nfrom restapi.tests import BaseTests\n\n\n@pytest.fixture\ndef app() -> Flask:\n    return create_app(name=\"Flask Tests\", mode=ServerModes.NORMAL, options={})\n\n\n# Beware, this replaces the standard faker fixture provided by Faker it-self\n@pytest.fixture\ndef faker() -> Faker:\n    return BaseTests.faker\n", "create_template.sh": "#!/bin/bash\nset -e\n\nTEMPLATE=$1\nAUTH=$2\nPROJECT_NAME=\"prj\"\n\nif [[ \"$TEMPLATE\" == \"postgres\" ]]; then\n  rapydo create ${PROJECT_NAME} --auth postgres --frontend no -e AUTH_TOKEN_IP_GRACE_PERIOD=2\nelif [[ \"$TEMPLATE\" == \"neo4j\" ]]; then\n  rapydo create ${PROJECT_NAME} --auth neo4j --frontend no -e AUTH_TOKEN_IP_GRACE_PERIOD=2\nelif [[ \"$TEMPLATE\" == \"celery-rabbit-rabbit\" ]]; then\n  rapydo create ${PROJECT_NAME} -s celery -s rabbit --auth ${AUTH} --frontend no;\nelif [[ \"$TEMPLATE\" == \"celery-rabbit-redis\" ]]; then\n  rapydo create ${PROJECT_NAME} -s celery -s rabbit -s redis --auth ${AUTH} --frontend no;\nelif [[ \"$TEMPLATE\" == \"celery-redis-redis\" ]]; then\n  rapydo create ${PROJECT_NAME} -s celery -s redis --auth ${AUTH} --frontend no;\nelif [[ \"$TEMPLATE\" == \"low_security\" ]]; then\n  rapydo --testing create ${PROJECT_NAME} --current \\\n                    --auth ${AUTH} \\\n                    --frontend no \\\n                    -e AUTH_FORCE_FIRST_PASSWORD_CHANGE=0 \\\n                    -e AUTH_MAX_PASSWORD_VALIDITY=0 \\\n                    -e AUTH_DISABLE_UNUSED_CREDENTIALS_AFTER=0 \\\n                    -e AUTH_MAX_LOGIN_ATTEMPTS=0 \\\n                    -e AUTH_SECOND_FACTOR_AUTHENTICATION=0 \\\n                    -e AUTH_TOKEN_IP_GRACE_PERIOD=99999999999\nelif [[ \"$TEMPLATE\" == \"noauth\" ]]; then\n  rapydo create ${PROJECT_NAME} --auth no --frontend no\n\nelif [[ \"$TEMPLATE\" == \"extra\" ]]; then\n  rapydo create prjbase --auth ${AUTH} --frontend no -e PROXIED_CONNECTION=1\n  # the --testing flag here (not included in others templates) will extend the\n  # customizer class with additinal input/output fields to test these customizations\n  # The flag is not included in all templates to be able to also test the cases\n  # when input and output models are not extended\n\n  rapydo --testing create ${PROJECT_NAME} --current \\\n                    --add-optionals \\\n                    --extend prjbase \\\n                    --auth ${AUTH} \\\n                    --frontend no \\\n                    -s ftp \\\n                    -e AUTH_FORCE_FIRST_PASSWORD_CHANGE=1 \\\n                    -e AUTH_MAX_PASSWORD_VALIDITY=60 \\\n                    -e AUTH_DISABLE_UNUSED_CREDENTIALS_AFTER=60 \\\n                    -e AUTH_MAX_LOGIN_ATTEMPTS=10 \\\n                    -e AUTH_SECOND_FACTOR_AUTHENTICATION=1 \\\n                    -e AUTH_TOKEN_IP_GRACE_PERIOD=2\n\nelif [[ \"$TEMPLATE\" == \"legacy39\" ]]; then\n  rapydo create ${PROJECT_NAME} --add-optionals \\\n                    --auth ${AUTH} \\\n                    --frontend no \\\n                    -e AUTH_FORCE_FIRST_PASSWORD_CHANGE=1 \\\n                    -e AUTH_MAX_PASSWORD_VALIDITY=60 \\\n                    -e AUTH_DISABLE_UNUSED_CREDENTIALS_AFTER=60 \\\n                    -e AUTH_MAX_LOGIN_ATTEMPTS=10 \\\n                    -e AUTH_SECOND_FACTOR_AUTHENTICATION=1 \\\n                    -e AUTH_TOKEN_IP_GRACE_PERIOD=2 \\\n                    -e BACKEND_PYTHON_VERSION=\"v3.9\"\n\nelif [[ \"$TEMPLATE\" == \"legacy310\" ]]; then\n  rapydo create ${PROJECT_NAME} --add-optionals \\\n                    --auth ${AUTH} \\\n                    --frontend no \\\n                    -e AUTH_FORCE_FIRST_PASSWORD_CHANGE=1 \\\n                    -e AUTH_MAX_PASSWORD_VALIDITY=60 \\\n                    -e AUTH_DISABLE_UNUSED_CREDENTIALS_AFTER=60 \\\n                    -e AUTH_MAX_LOGIN_ATTEMPTS=10 \\\n                    -e AUTH_SECOND_FACTOR_AUTHENTICATION=1 \\\n                    -e AUTH_TOKEN_IP_GRACE_PERIOD=2 \\\n                    -e BACKEND_PYTHON_VERSION=\"v3.10\"\nelif [[ \"$TEMPLATE\" == \"legacy311\" ]]; then\n  rapydo create ${PROJECT_NAME} --add-optionals \\\n                    --auth ${AUTH} \\\n                    --frontend no \\\n                    -e AUTH_FORCE_FIRST_PASSWORD_CHANGE=1 \\\n                    -e AUTH_MAX_PASSWORD_VALIDITY=60 \\\n                    -e AUTH_DISABLE_UNUSED_CREDENTIALS_AFTER=60 \\\n                    -e AUTH_MAX_LOGIN_ATTEMPTS=10 \\\n                    -e AUTH_SECOND_FACTOR_AUTHENTICATION=1 \\\n                    -e AUTH_TOKEN_IP_GRACE_PERIOD=2 \\\n                    -e BACKEND_PYTHON_VERSION=\"v3.11\"\nelse\n  echo \"Unknown template: ${TEMPLATE}\";\n  exit 1;\nfi\n\ngit remote add origin https://your_remote_git/your_project.git\n\n# REF contains the branch when commit, but contains refs/pull/XXX/merge on PRs\n# with PRs use HEAD_REF\n\n# Strip out refs/heads/ prefix\nif [[ ! -z $HEAD_REF_BRANCH ]];\nthen\n  BRANCH=${HEAD_REF_BRANCH/refs\\/heads\\//}\nelse\n  BRANCH=${REF_BRANCH/refs\\/heads\\//}\nfi\n\n# Also strip out tags from the branch\nBRANCH=${BRANCH/refs\\/tags\\/v/}\n\necho \"Forcing http-api to branch ${BRANCH}\"\necho \"\"\"\n  submodules:\n    http-api:\n      branch: \\\"${BRANCH}\\\"\n\"\"\" >> projects/${PROJECT_NAME}/project_configuration.yaml\n", "customize_template.sh": "#!/bin/bash\nset -e\n\nTEMPLATE=$1\n\nif [[ \"$TEMPLATE\" == \"celery-rabbit-redis\" ]]; then\n  rapydo add task test_task;\nelif [[ \"$TEMPLATE\" == \"celery-redis-redis\" ]]; then\n  rapydo add task test_task;\nelif [[ \"$TEMPLATE\" == \"celery-rabbit-rabbit\" ]]; then\n  rapydo add task test_task;\nfi\n", "tests.sh": "#!/bin/bash\nset -e\n\nif [ ! -d \"tests\" ]; then\n    echo \"Missing 'tests' directory\"\n    exit 1\nfi\n\nexport COVERAGE_FILE=\"/tmp/.coverage\"\n\nif [[ -z \"$1\" ]]; then\n    CURRENT_PACKAGE=\"restapi\"\nelse\n    CURRENT_PACKAGE=$1\nfi\n\nif [[ \"${CURRENT_PACKAGE}\" == \"restapi\" ]]; then\n    coverage_folder=\"tests/base\"\nelse\n    coverage_folder=\"tests/custom\"\nfi\necho \"Launching unittests with coverage on tests/${2}\"\necho \"Package: $CURRENT_PACKAGE\"\nsleep 1\n\n# --timeout is provided by pytest-timeout\n# --cov is provided by pytest-cov\nif [[ -z \"$2\" ]]; then\n    test_folder=\"tests/custom tests/base\"\nelse\n    test_folder=\"tests/${2}\"\nfi\n\npy.test --confcutdir=tests --timeout=300 --durations=5 -x -s --cov-report=xml:/tmp/coverage.xml --cov=${CURRENT_PACKAGE} --cov=${coverage_folder} -o cache_dir=/tmp/ ${test_folder}\n"}